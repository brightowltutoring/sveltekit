import {
  require_fs,
  require_path,
  require_url,
  require_util
} from "./chunk-GMKM4UDP.js";
import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-NKHIPFFU.js";

// node_modules/prismjs/components.json
var require_components = __commonJS({
  "node_modules/prismjs/components.json"(exports, module) {
    module.exports = {
      core: {
        meta: {
          path: "components/prism-core.js",
          option: "mandatory"
        },
        core: "Core"
      },
      themes: {
        meta: {
          path: "themes/{id}.css",
          link: "index.html?theme={id}",
          exclusive: true
        },
        prism: {
          title: "Default",
          option: "default"
        },
        "prism-dark": "Dark",
        "prism-funky": "Funky",
        "prism-okaidia": {
          title: "Okaidia",
          owner: "ocodia"
        },
        "prism-twilight": {
          title: "Twilight",
          owner: "remybach"
        },
        "prism-coy": {
          title: "Coy",
          owner: "tshedor"
        },
        "prism-solarizedlight": {
          title: "Solarized Light",
          owner: "hectormatos2011 "
        },
        "prism-tomorrow": {
          title: "Tomorrow Night",
          owner: "Rosey"
        }
      },
      languages: {
        meta: {
          path: "components/prism-{id}",
          noCSS: true,
          examplesPath: "examples/prism-{id}",
          addCheckAll: true
        },
        markup: {
          title: "Markup",
          alias: ["html", "xml", "svg", "mathml", "ssml", "atom", "rss"],
          aliasTitles: {
            html: "HTML",
            xml: "XML",
            svg: "SVG",
            mathml: "MathML",
            ssml: "SSML",
            atom: "Atom",
            rss: "RSS"
          },
          option: "default"
        },
        css: {
          title: "CSS",
          option: "default",
          modify: "markup"
        },
        clike: {
          title: "C-like",
          option: "default"
        },
        javascript: {
          title: "JavaScript",
          require: "clike",
          modify: "markup",
          optional: "regex",
          alias: "js",
          option: "default"
        },
        abap: {
          title: "ABAP",
          owner: "dellagustin"
        },
        abnf: {
          title: "ABNF",
          owner: "RunDevelopment"
        },
        actionscript: {
          title: "ActionScript",
          require: "javascript",
          modify: "markup",
          owner: "Golmote"
        },
        ada: {
          title: "Ada",
          owner: "Lucretia"
        },
        agda: {
          title: "Agda",
          owner: "xy-ren"
        },
        al: {
          title: "AL",
          owner: "RunDevelopment"
        },
        antlr4: {
          title: "ANTLR4",
          alias: "g4",
          owner: "RunDevelopment"
        },
        apacheconf: {
          title: "Apache Configuration",
          owner: "GuiTeK"
        },
        apex: {
          title: "Apex",
          require: ["clike", "sql"],
          owner: "RunDevelopment"
        },
        apl: {
          title: "APL",
          owner: "ngn"
        },
        applescript: {
          title: "AppleScript",
          owner: "Golmote"
        },
        aql: {
          title: "AQL",
          owner: "RunDevelopment"
        },
        arduino: {
          title: "Arduino",
          require: "cpp",
          alias: "ino",
          owner: "dkern"
        },
        arff: {
          title: "ARFF",
          owner: "Golmote"
        },
        armasm: {
          title: "ARM Assembly",
          alias: "arm-asm",
          owner: "RunDevelopment"
        },
        arturo: {
          title: "Arturo",
          alias: "art",
          optional: [
            "bash",
            "css",
            "javascript",
            "markup",
            "markdown",
            "sql"
          ],
          owner: "drkameleon"
        },
        asciidoc: {
          alias: "adoc",
          title: "AsciiDoc",
          owner: "Golmote"
        },
        aspnet: {
          title: "ASP.NET (C#)",
          require: ["markup", "csharp"],
          owner: "nauzilus"
        },
        asm6502: {
          title: "6502 Assembly",
          owner: "kzurawel"
        },
        asmatmel: {
          title: "Atmel AVR Assembly",
          owner: "cerkit"
        },
        autohotkey: {
          title: "AutoHotkey",
          owner: "aviaryan"
        },
        autoit: {
          title: "AutoIt",
          owner: "Golmote"
        },
        avisynth: {
          title: "AviSynth",
          alias: "avs",
          owner: "Zinfidel"
        },
        "avro-idl": {
          title: "Avro IDL",
          alias: "avdl",
          owner: "RunDevelopment"
        },
        awk: {
          title: "AWK",
          alias: "gawk",
          aliasTitles: {
            gawk: "GAWK"
          },
          owner: "RunDevelopment"
        },
        bash: {
          title: "Bash",
          alias: ["sh", "shell"],
          aliasTitles: {
            sh: "Shell",
            shell: "Shell"
          },
          owner: "zeitgeist87"
        },
        basic: {
          title: "BASIC",
          owner: "Golmote"
        },
        batch: {
          title: "Batch",
          owner: "Golmote"
        },
        bbcode: {
          title: "BBcode",
          alias: "shortcode",
          aliasTitles: {
            shortcode: "Shortcode"
          },
          owner: "RunDevelopment"
        },
        bbj: {
          title: "BBj",
          owner: "hyyan"
        },
        bicep: {
          title: "Bicep",
          owner: "johnnyreilly"
        },
        birb: {
          title: "Birb",
          require: "clike",
          owner: "Calamity210"
        },
        bison: {
          title: "Bison",
          require: "c",
          owner: "Golmote"
        },
        bnf: {
          title: "BNF",
          alias: "rbnf",
          aliasTitles: {
            rbnf: "RBNF"
          },
          owner: "RunDevelopment"
        },
        bqn: {
          title: "BQN",
          owner: "yewscion"
        },
        brainfuck: {
          title: "Brainfuck",
          owner: "Golmote"
        },
        brightscript: {
          title: "BrightScript",
          owner: "RunDevelopment"
        },
        bro: {
          title: "Bro",
          owner: "wayward710"
        },
        bsl: {
          title: "BSL (1C:Enterprise)",
          alias: "oscript",
          aliasTitles: {
            oscript: "OneScript"
          },
          owner: "Diversus23"
        },
        c: {
          title: "C",
          require: "clike",
          owner: "zeitgeist87"
        },
        csharp: {
          title: "C#",
          require: "clike",
          alias: ["cs", "dotnet"],
          owner: "mvalipour"
        },
        cpp: {
          title: "C++",
          require: "c",
          owner: "zeitgeist87"
        },
        cfscript: {
          title: "CFScript",
          require: "clike",
          alias: "cfc",
          owner: "mjclemente"
        },
        chaiscript: {
          title: "ChaiScript",
          require: ["clike", "cpp"],
          owner: "RunDevelopment"
        },
        cil: {
          title: "CIL",
          owner: "sbrl"
        },
        cilkc: {
          title: "Cilk/C",
          require: "c",
          alias: "cilk-c",
          owner: "OpenCilk"
        },
        cilkcpp: {
          title: "Cilk/C++",
          require: "cpp",
          alias: ["cilk-cpp", "cilk"],
          owner: "OpenCilk"
        },
        clojure: {
          title: "Clojure",
          owner: "troglotit"
        },
        cmake: {
          title: "CMake",
          owner: "mjrogozinski"
        },
        cobol: {
          title: "COBOL",
          owner: "RunDevelopment"
        },
        coffeescript: {
          title: "CoffeeScript",
          require: "javascript",
          alias: "coffee",
          owner: "R-osey"
        },
        concurnas: {
          title: "Concurnas",
          alias: "conc",
          owner: "jasontatton"
        },
        csp: {
          title: "Content-Security-Policy",
          owner: "ScottHelme"
        },
        cooklang: {
          title: "Cooklang",
          owner: "ahue"
        },
        coq: {
          title: "Coq",
          owner: "RunDevelopment"
        },
        crystal: {
          title: "Crystal",
          require: "ruby",
          owner: "MakeNowJust"
        },
        "css-extras": {
          title: "CSS Extras",
          require: "css",
          modify: "css",
          owner: "milesj"
        },
        csv: {
          title: "CSV",
          owner: "RunDevelopment"
        },
        cue: {
          title: "CUE",
          owner: "RunDevelopment"
        },
        cypher: {
          title: "Cypher",
          owner: "RunDevelopment"
        },
        d: {
          title: "D",
          require: "clike",
          owner: "Golmote"
        },
        dart: {
          title: "Dart",
          require: "clike",
          owner: "Golmote"
        },
        dataweave: {
          title: "DataWeave",
          owner: "machaval"
        },
        dax: {
          title: "DAX",
          owner: "peterbud"
        },
        dhall: {
          title: "Dhall",
          owner: "RunDevelopment"
        },
        diff: {
          title: "Diff",
          owner: "uranusjr"
        },
        django: {
          title: "Django/Jinja2",
          require: "markup-templating",
          alias: "jinja2",
          owner: "romanvm"
        },
        "dns-zone-file": {
          title: "DNS zone file",
          owner: "RunDevelopment",
          alias: "dns-zone"
        },
        docker: {
          title: "Docker",
          alias: "dockerfile",
          owner: "JustinBeckwith"
        },
        dot: {
          title: "DOT (Graphviz)",
          alias: "gv",
          optional: "markup",
          owner: "RunDevelopment"
        },
        ebnf: {
          title: "EBNF",
          owner: "RunDevelopment"
        },
        editorconfig: {
          title: "EditorConfig",
          owner: "osipxd"
        },
        eiffel: {
          title: "Eiffel",
          owner: "Conaclos"
        },
        ejs: {
          title: "EJS",
          require: ["javascript", "markup-templating"],
          owner: "RunDevelopment",
          alias: "eta",
          aliasTitles: {
            eta: "Eta"
          }
        },
        elixir: {
          title: "Elixir",
          owner: "Golmote"
        },
        elm: {
          title: "Elm",
          owner: "zwilias"
        },
        etlua: {
          title: "Embedded Lua templating",
          require: ["lua", "markup-templating"],
          owner: "RunDevelopment"
        },
        erb: {
          title: "ERB",
          require: ["ruby", "markup-templating"],
          owner: "Golmote"
        },
        erlang: {
          title: "Erlang",
          owner: "Golmote"
        },
        "excel-formula": {
          title: "Excel Formula",
          alias: ["xlsx", "xls"],
          owner: "RunDevelopment"
        },
        fsharp: {
          title: "F#",
          require: "clike",
          owner: "simonreynolds7"
        },
        factor: {
          title: "Factor",
          owner: "catb0t"
        },
        false: {
          title: "False",
          owner: "edukisto"
        },
        "firestore-security-rules": {
          title: "Firestore security rules",
          require: "clike",
          owner: "RunDevelopment"
        },
        flow: {
          title: "Flow",
          require: "javascript",
          owner: "Golmote"
        },
        fortran: {
          title: "Fortran",
          owner: "Golmote"
        },
        ftl: {
          title: "FreeMarker Template Language",
          require: "markup-templating",
          owner: "RunDevelopment"
        },
        gml: {
          title: "GameMaker Language",
          alias: "gamemakerlanguage",
          require: "clike",
          owner: "LiarOnce"
        },
        gap: {
          title: "GAP (CAS)",
          owner: "RunDevelopment"
        },
        gcode: {
          title: "G-code",
          owner: "RunDevelopment"
        },
        gdscript: {
          title: "GDScript",
          owner: "RunDevelopment"
        },
        gedcom: {
          title: "GEDCOM",
          owner: "Golmote"
        },
        gettext: {
          title: "gettext",
          alias: "po",
          owner: "RunDevelopment"
        },
        gherkin: {
          title: "Gherkin",
          owner: "hason"
        },
        git: {
          title: "Git",
          owner: "lgiraudel"
        },
        glsl: {
          title: "GLSL",
          require: "c",
          owner: "Golmote"
        },
        gn: {
          title: "GN",
          alias: "gni",
          owner: "RunDevelopment"
        },
        "linker-script": {
          title: "GNU Linker Script",
          alias: "ld",
          owner: "RunDevelopment"
        },
        go: {
          title: "Go",
          require: "clike",
          owner: "arnehormann"
        },
        "go-module": {
          title: "Go module",
          alias: "go-mod",
          owner: "RunDevelopment"
        },
        gradle: {
          title: "Gradle",
          require: "clike",
          owner: "zeabdelkhalek-badido18"
        },
        graphql: {
          title: "GraphQL",
          optional: "markdown",
          owner: "Golmote"
        },
        groovy: {
          title: "Groovy",
          require: "clike",
          owner: "robfletcher"
        },
        haml: {
          title: "Haml",
          require: "ruby",
          optional: [
            "css",
            "css-extras",
            "coffeescript",
            "erb",
            "javascript",
            "less",
            "markdown",
            "scss",
            "textile"
          ],
          owner: "Golmote"
        },
        handlebars: {
          title: "Handlebars",
          require: "markup-templating",
          alias: ["hbs", "mustache"],
          aliasTitles: {
            mustache: "Mustache"
          },
          owner: "Golmote"
        },
        haskell: {
          title: "Haskell",
          alias: "hs",
          owner: "bholst"
        },
        haxe: {
          title: "Haxe",
          require: "clike",
          optional: "regex",
          owner: "Golmote"
        },
        hcl: {
          title: "HCL",
          owner: "outsideris"
        },
        hlsl: {
          title: "HLSL",
          require: "c",
          owner: "RunDevelopment"
        },
        hoon: {
          title: "Hoon",
          owner: "matildepark"
        },
        http: {
          title: "HTTP",
          optional: [
            "csp",
            "css",
            "hpkp",
            "hsts",
            "javascript",
            "json",
            "markup",
            "uri"
          ],
          owner: "danielgtaylor"
        },
        hpkp: {
          title: "HTTP Public-Key-Pins",
          owner: "ScottHelme"
        },
        hsts: {
          title: "HTTP Strict-Transport-Security",
          owner: "ScottHelme"
        },
        ichigojam: {
          title: "IchigoJam",
          owner: "BlueCocoa"
        },
        icon: {
          title: "Icon",
          owner: "Golmote"
        },
        "icu-message-format": {
          title: "ICU Message Format",
          owner: "RunDevelopment"
        },
        idris: {
          title: "Idris",
          alias: "idr",
          owner: "KeenS",
          require: "haskell"
        },
        ignore: {
          title: ".ignore",
          owner: "osipxd",
          alias: [
            "gitignore",
            "hgignore",
            "npmignore"
          ],
          aliasTitles: {
            gitignore: ".gitignore",
            hgignore: ".hgignore",
            npmignore: ".npmignore"
          }
        },
        inform7: {
          title: "Inform 7",
          owner: "Golmote"
        },
        ini: {
          title: "Ini",
          owner: "aviaryan"
        },
        io: {
          title: "Io",
          owner: "AlesTsurko"
        },
        j: {
          title: "J",
          owner: "Golmote"
        },
        java: {
          title: "Java",
          require: "clike",
          owner: "sherblot"
        },
        javadoc: {
          title: "JavaDoc",
          require: ["markup", "java", "javadoclike"],
          modify: "java",
          optional: "scala",
          owner: "RunDevelopment"
        },
        javadoclike: {
          title: "JavaDoc-like",
          modify: [
            "java",
            "javascript",
            "php"
          ],
          owner: "RunDevelopment"
        },
        javastacktrace: {
          title: "Java stack trace",
          owner: "RunDevelopment"
        },
        jexl: {
          title: "Jexl",
          owner: "czosel"
        },
        jolie: {
          title: "Jolie",
          require: "clike",
          owner: "thesave"
        },
        jq: {
          title: "JQ",
          owner: "RunDevelopment"
        },
        jsdoc: {
          title: "JSDoc",
          require: ["javascript", "javadoclike", "typescript"],
          modify: "javascript",
          optional: [
            "actionscript",
            "coffeescript"
          ],
          owner: "RunDevelopment"
        },
        "js-extras": {
          title: "JS Extras",
          require: "javascript",
          modify: "javascript",
          optional: [
            "actionscript",
            "coffeescript",
            "flow",
            "n4js",
            "typescript"
          ],
          owner: "RunDevelopment"
        },
        json: {
          title: "JSON",
          alias: "webmanifest",
          aliasTitles: {
            webmanifest: "Web App Manifest"
          },
          owner: "CupOfTea696"
        },
        json5: {
          title: "JSON5",
          require: "json",
          owner: "RunDevelopment"
        },
        jsonp: {
          title: "JSONP",
          require: "json",
          owner: "RunDevelopment"
        },
        jsstacktrace: {
          title: "JS stack trace",
          owner: "sbrl"
        },
        "js-templates": {
          title: "JS Templates",
          require: "javascript",
          modify: "javascript",
          optional: [
            "css",
            "css-extras",
            "graphql",
            "markdown",
            "markup",
            "sql"
          ],
          owner: "RunDevelopment"
        },
        julia: {
          title: "Julia",
          owner: "cdagnino"
        },
        keepalived: {
          title: "Keepalived Configure",
          owner: "dev-itsheng"
        },
        keyman: {
          title: "Keyman",
          owner: "mcdurdin"
        },
        kotlin: {
          title: "Kotlin",
          alias: ["kt", "kts"],
          aliasTitles: {
            kts: "Kotlin Script"
          },
          require: "clike",
          owner: "Golmote"
        },
        kumir: {
          title: "KuMir (\u041A\u0443\u041C\u0438\u0440)",
          alias: "kum",
          owner: "edukisto"
        },
        kusto: {
          title: "Kusto",
          owner: "RunDevelopment"
        },
        latex: {
          title: "LaTeX",
          alias: ["tex", "context"],
          aliasTitles: {
            tex: "TeX",
            context: "ConTeXt"
          },
          owner: "japborst"
        },
        latte: {
          title: "Latte",
          require: ["clike", "markup-templating", "php"],
          owner: "nette"
        },
        less: {
          title: "Less",
          require: "css",
          optional: "css-extras",
          owner: "Golmote"
        },
        lilypond: {
          title: "LilyPond",
          require: "scheme",
          alias: "ly",
          owner: "RunDevelopment"
        },
        liquid: {
          title: "Liquid",
          require: "markup-templating",
          owner: "cinhtau"
        },
        lisp: {
          title: "Lisp",
          alias: ["emacs", "elisp", "emacs-lisp"],
          owner: "JuanCaicedo"
        },
        livescript: {
          title: "LiveScript",
          owner: "Golmote"
        },
        llvm: {
          title: "LLVM IR",
          owner: "porglezomp"
        },
        log: {
          title: "Log file",
          optional: "javastacktrace",
          owner: "RunDevelopment"
        },
        lolcode: {
          title: "LOLCODE",
          owner: "Golmote"
        },
        lua: {
          title: "Lua",
          owner: "Golmote"
        },
        magma: {
          title: "Magma (CAS)",
          owner: "RunDevelopment"
        },
        makefile: {
          title: "Makefile",
          owner: "Golmote"
        },
        markdown: {
          title: "Markdown",
          require: "markup",
          optional: "yaml",
          alias: "md",
          owner: "Golmote"
        },
        "markup-templating": {
          title: "Markup templating",
          require: "markup",
          owner: "Golmote"
        },
        mata: {
          title: "Mata",
          owner: "RunDevelopment"
        },
        matlab: {
          title: "MATLAB",
          owner: "Golmote"
        },
        maxscript: {
          title: "MAXScript",
          owner: "RunDevelopment"
        },
        mel: {
          title: "MEL",
          owner: "Golmote"
        },
        mermaid: {
          title: "Mermaid",
          owner: "RunDevelopment"
        },
        metafont: {
          title: "METAFONT",
          owner: "LaeriExNihilo"
        },
        mizar: {
          title: "Mizar",
          owner: "Golmote"
        },
        mongodb: {
          title: "MongoDB",
          owner: "airs0urce",
          require: "javascript"
        },
        monkey: {
          title: "Monkey",
          owner: "Golmote"
        },
        moonscript: {
          title: "MoonScript",
          alias: "moon",
          owner: "RunDevelopment"
        },
        n1ql: {
          title: "N1QL",
          owner: "TMWilds"
        },
        n4js: {
          title: "N4JS",
          require: "javascript",
          optional: "jsdoc",
          alias: "n4jsd",
          owner: "bsmith-n4"
        },
        "nand2tetris-hdl": {
          title: "Nand To Tetris HDL",
          owner: "stephanmax"
        },
        naniscript: {
          title: "Naninovel Script",
          owner: "Elringus",
          alias: "nani"
        },
        nasm: {
          title: "NASM",
          owner: "rbmj"
        },
        neon: {
          title: "NEON",
          owner: "nette"
        },
        nevod: {
          title: "Nevod",
          owner: "nezaboodka"
        },
        nginx: {
          title: "nginx",
          owner: "volado"
        },
        nim: {
          title: "Nim",
          owner: "Golmote"
        },
        nix: {
          title: "Nix",
          owner: "Golmote"
        },
        nsis: {
          title: "NSIS",
          owner: "idleberg"
        },
        objectivec: {
          title: "Objective-C",
          require: "c",
          alias: "objc",
          owner: "uranusjr"
        },
        ocaml: {
          title: "OCaml",
          owner: "Golmote"
        },
        odin: {
          title: "Odin",
          owner: "edukisto"
        },
        opencl: {
          title: "OpenCL",
          require: "c",
          modify: [
            "c",
            "cpp"
          ],
          owner: "Milania1"
        },
        openqasm: {
          title: "OpenQasm",
          alias: "qasm",
          owner: "RunDevelopment"
        },
        oz: {
          title: "Oz",
          owner: "Golmote"
        },
        parigp: {
          title: "PARI/GP",
          owner: "Golmote"
        },
        parser: {
          title: "Parser",
          require: "markup",
          owner: "Golmote"
        },
        pascal: {
          title: "Pascal",
          alias: "objectpascal",
          aliasTitles: {
            objectpascal: "Object Pascal"
          },
          owner: "Golmote"
        },
        pascaligo: {
          title: "Pascaligo",
          owner: "DefinitelyNotAGoat"
        },
        psl: {
          title: "PATROL Scripting Language",
          owner: "bertysentry"
        },
        pcaxis: {
          title: "PC-Axis",
          alias: "px",
          owner: "RunDevelopment"
        },
        peoplecode: {
          title: "PeopleCode",
          alias: "pcode",
          owner: "RunDevelopment"
        },
        perl: {
          title: "Perl",
          owner: "Golmote"
        },
        php: {
          title: "PHP",
          require: "markup-templating",
          owner: "milesj"
        },
        phpdoc: {
          title: "PHPDoc",
          require: ["php", "javadoclike"],
          modify: "php",
          owner: "RunDevelopment"
        },
        "php-extras": {
          title: "PHP Extras",
          require: "php",
          modify: "php",
          owner: "milesj"
        },
        "plant-uml": {
          title: "PlantUML",
          alias: "plantuml",
          owner: "RunDevelopment"
        },
        plsql: {
          title: "PL/SQL",
          require: "sql",
          owner: "Golmote"
        },
        powerquery: {
          title: "PowerQuery",
          alias: ["pq", "mscript"],
          owner: "peterbud"
        },
        powershell: {
          title: "PowerShell",
          owner: "nauzilus"
        },
        processing: {
          title: "Processing",
          require: "clike",
          owner: "Golmote"
        },
        prolog: {
          title: "Prolog",
          owner: "Golmote"
        },
        promql: {
          title: "PromQL",
          owner: "arendjr"
        },
        properties: {
          title: ".properties",
          owner: "Golmote"
        },
        protobuf: {
          title: "Protocol Buffers",
          require: "clike",
          owner: "just-boris"
        },
        pug: {
          title: "Pug",
          require: ["markup", "javascript"],
          optional: [
            "coffeescript",
            "ejs",
            "handlebars",
            "less",
            "livescript",
            "markdown",
            "scss",
            "stylus",
            "twig"
          ],
          owner: "Golmote"
        },
        puppet: {
          title: "Puppet",
          owner: "Golmote"
        },
        pure: {
          title: "Pure",
          optional: [
            "c",
            "cpp",
            "fortran"
          ],
          owner: "Golmote"
        },
        purebasic: {
          title: "PureBasic",
          require: "clike",
          alias: "pbfasm",
          owner: "HeX0R101"
        },
        purescript: {
          title: "PureScript",
          require: "haskell",
          alias: "purs",
          owner: "sriharshachilakapati"
        },
        python: {
          title: "Python",
          alias: "py",
          owner: "multipetros"
        },
        qsharp: {
          title: "Q#",
          require: "clike",
          alias: "qs",
          owner: "fedonman"
        },
        q: {
          title: "Q (kdb+ database)",
          owner: "Golmote"
        },
        qml: {
          title: "QML",
          require: "javascript",
          owner: "RunDevelopment"
        },
        qore: {
          title: "Qore",
          require: "clike",
          owner: "temnroegg"
        },
        r: {
          title: "R",
          owner: "Golmote"
        },
        racket: {
          title: "Racket",
          require: "scheme",
          alias: "rkt",
          owner: "RunDevelopment"
        },
        cshtml: {
          title: "Razor C#",
          alias: "razor",
          require: ["markup", "csharp"],
          optional: [
            "css",
            "css-extras",
            "javascript",
            "js-extras"
          ],
          owner: "RunDevelopment"
        },
        jsx: {
          title: "React JSX",
          require: ["markup", "javascript"],
          optional: [
            "jsdoc",
            "js-extras",
            "js-templates"
          ],
          owner: "vkbansal"
        },
        tsx: {
          title: "React TSX",
          require: ["jsx", "typescript"]
        },
        reason: {
          title: "Reason",
          require: "clike",
          owner: "Golmote"
        },
        regex: {
          title: "Regex",
          owner: "RunDevelopment"
        },
        rego: {
          title: "Rego",
          owner: "JordanSh"
        },
        renpy: {
          title: "Ren'py",
          alias: "rpy",
          owner: "HyuchiaDiego"
        },
        rescript: {
          title: "ReScript",
          alias: "res",
          owner: "vmarcosp"
        },
        rest: {
          title: "reST (reStructuredText)",
          owner: "Golmote"
        },
        rip: {
          title: "Rip",
          owner: "ravinggenius"
        },
        roboconf: {
          title: "Roboconf",
          owner: "Golmote"
        },
        robotframework: {
          title: "Robot Framework",
          alias: "robot",
          owner: "RunDevelopment"
        },
        ruby: {
          title: "Ruby",
          require: "clike",
          alias: "rb",
          owner: "samflores"
        },
        rust: {
          title: "Rust",
          owner: "Golmote"
        },
        sas: {
          title: "SAS",
          optional: ["groovy", "lua", "sql"],
          owner: "Golmote"
        },
        sass: {
          title: "Sass (Sass)",
          require: "css",
          optional: "css-extras",
          owner: "Golmote"
        },
        scss: {
          title: "Sass (SCSS)",
          require: "css",
          optional: "css-extras",
          owner: "MoOx"
        },
        scala: {
          title: "Scala",
          require: "java",
          owner: "jozic"
        },
        scheme: {
          title: "Scheme",
          owner: "bacchus123"
        },
        "shell-session": {
          title: "Shell session",
          require: "bash",
          alias: ["sh-session", "shellsession"],
          owner: "RunDevelopment"
        },
        smali: {
          title: "Smali",
          owner: "RunDevelopment"
        },
        smalltalk: {
          title: "Smalltalk",
          owner: "Golmote"
        },
        smarty: {
          title: "Smarty",
          require: "markup-templating",
          optional: "php",
          owner: "Golmote"
        },
        sml: {
          title: "SML",
          alias: "smlnj",
          aliasTitles: {
            smlnj: "SML/NJ"
          },
          owner: "RunDevelopment"
        },
        solidity: {
          title: "Solidity (Ethereum)",
          alias: "sol",
          require: "clike",
          owner: "glachaud"
        },
        "solution-file": {
          title: "Solution file",
          alias: "sln",
          owner: "RunDevelopment"
        },
        soy: {
          title: "Soy (Closure Template)",
          require: "markup-templating",
          owner: "Golmote"
        },
        sparql: {
          title: "SPARQL",
          require: "turtle",
          owner: "Triply-Dev",
          alias: "rq"
        },
        "splunk-spl": {
          title: "Splunk SPL",
          owner: "RunDevelopment"
        },
        sqf: {
          title: "SQF: Status Quo Function (Arma 3)",
          require: "clike",
          owner: "RunDevelopment"
        },
        sql: {
          title: "SQL",
          owner: "multipetros"
        },
        squirrel: {
          title: "Squirrel",
          require: "clike",
          owner: "RunDevelopment"
        },
        stan: {
          title: "Stan",
          owner: "RunDevelopment"
        },
        stata: {
          title: "Stata Ado",
          require: ["mata", "java", "python"],
          owner: "RunDevelopment"
        },
        iecst: {
          title: "Structured Text (IEC 61131-3)",
          owner: "serhioromano"
        },
        stylus: {
          title: "Stylus",
          owner: "vkbansal"
        },
        supercollider: {
          title: "SuperCollider",
          alias: "sclang",
          owner: "RunDevelopment"
        },
        swift: {
          title: "Swift",
          owner: "chrischares"
        },
        systemd: {
          title: "Systemd configuration file",
          owner: "RunDevelopment"
        },
        "t4-templating": {
          title: "T4 templating",
          owner: "RunDevelopment"
        },
        "t4-cs": {
          title: "T4 Text Templates (C#)",
          require: ["t4-templating", "csharp"],
          alias: "t4",
          owner: "RunDevelopment"
        },
        "t4-vb": {
          title: "T4 Text Templates (VB)",
          require: ["t4-templating", "vbnet"],
          owner: "RunDevelopment"
        },
        tap: {
          title: "TAP",
          owner: "isaacs",
          require: "yaml"
        },
        tcl: {
          title: "Tcl",
          owner: "PeterChaplin"
        },
        tt2: {
          title: "Template Toolkit 2",
          require: ["clike", "markup-templating"],
          owner: "gflohr"
        },
        textile: {
          title: "Textile",
          require: "markup",
          optional: "css",
          owner: "Golmote"
        },
        toml: {
          title: "TOML",
          owner: "RunDevelopment"
        },
        tremor: {
          title: "Tremor",
          alias: [
            "trickle",
            "troy"
          ],
          owner: "darach",
          aliasTitles: {
            trickle: "trickle",
            troy: "troy"
          }
        },
        turtle: {
          title: "Turtle",
          alias: "trig",
          aliasTitles: {
            trig: "TriG"
          },
          owner: "jakubklimek"
        },
        twig: {
          title: "Twig",
          require: "markup-templating",
          owner: "brandonkelly"
        },
        typescript: {
          title: "TypeScript",
          require: "javascript",
          optional: "js-templates",
          alias: "ts",
          owner: "vkbansal"
        },
        typoscript: {
          title: "TypoScript",
          alias: "tsconfig",
          aliasTitles: {
            tsconfig: "TSConfig"
          },
          owner: "dkern"
        },
        unrealscript: {
          title: "UnrealScript",
          alias: ["uscript", "uc"],
          owner: "RunDevelopment"
        },
        uorazor: {
          title: "UO Razor Script",
          owner: "jaseowns"
        },
        uri: {
          title: "URI",
          alias: "url",
          aliasTitles: {
            url: "URL"
          },
          owner: "RunDevelopment"
        },
        v: {
          title: "V",
          require: "clike",
          owner: "taggon"
        },
        vala: {
          title: "Vala",
          require: "clike",
          optional: "regex",
          owner: "TemplarVolk"
        },
        vbnet: {
          title: "VB.Net",
          require: "basic",
          owner: "Bigsby"
        },
        velocity: {
          title: "Velocity",
          require: "markup",
          owner: "Golmote"
        },
        verilog: {
          title: "Verilog",
          owner: "a-rey"
        },
        vhdl: {
          title: "VHDL",
          owner: "a-rey"
        },
        vim: {
          title: "vim",
          owner: "westonganger"
        },
        "visual-basic": {
          title: "Visual Basic",
          alias: ["vb", "vba"],
          aliasTitles: {
            vba: "VBA"
          },
          owner: "Golmote"
        },
        warpscript: {
          title: "WarpScript",
          owner: "RunDevelopment"
        },
        wasm: {
          title: "WebAssembly",
          owner: "Golmote"
        },
        "web-idl": {
          title: "Web IDL",
          alias: "webidl",
          owner: "RunDevelopment"
        },
        wgsl: {
          title: "WGSL",
          owner: "Dr4gonthree"
        },
        wiki: {
          title: "Wiki markup",
          require: "markup",
          owner: "Golmote"
        },
        wolfram: {
          title: "Wolfram language",
          alias: ["mathematica", "nb", "wl"],
          aliasTitles: {
            mathematica: "Mathematica",
            nb: "Mathematica Notebook"
          },
          owner: "msollami"
        },
        wren: {
          title: "Wren",
          owner: "clsource"
        },
        xeora: {
          title: "Xeora",
          require: "markup",
          alias: "xeoracube",
          aliasTitles: {
            xeoracube: "XeoraCube"
          },
          owner: "freakmaxi"
        },
        "xml-doc": {
          title: "XML doc (.net)",
          require: "markup",
          modify: ["csharp", "fsharp", "vbnet"],
          owner: "RunDevelopment"
        },
        xojo: {
          title: "Xojo (REALbasic)",
          owner: "Golmote"
        },
        xquery: {
          title: "XQuery",
          require: "markup",
          owner: "Golmote"
        },
        yaml: {
          title: "YAML",
          alias: "yml",
          owner: "hason"
        },
        yang: {
          title: "YANG",
          owner: "RunDevelopment"
        },
        zig: {
          title: "Zig",
          owner: "RunDevelopment"
        }
      },
      plugins: {
        meta: {
          path: "plugins/{id}/prism-{id}",
          link: "plugins/{id}/"
        },
        "line-highlight": {
          title: "Line Highlight",
          description: "Highlights specific lines and/or line ranges."
        },
        "line-numbers": {
          title: "Line Numbers",
          description: "Line number at the beginning of code lines.",
          owner: "kuba-kubula"
        },
        "show-invisibles": {
          title: "Show Invisibles",
          description: "Show hidden characters such as tabs and line breaks.",
          optional: [
            "autolinker",
            "data-uri-highlight"
          ]
        },
        autolinker: {
          title: "Autolinker",
          description: "Converts URLs and emails in code to clickable links. Parses Markdown links in comments."
        },
        wpd: {
          title: "WebPlatform Docs",
          description: 'Makes tokens link to <a href="https://webplatform.github.io/docs/">WebPlatform.org documentation</a>. The links open in a new tab.'
        },
        "custom-class": {
          title: "Custom Class",
          description: "This plugin allows you to prefix Prism's default classes (<code>.comment</code> can become <code>.namespace--comment</code>) or replace them with your defined ones (like <code>.editor__comment</code>). You can even add new classes.",
          owner: "dvkndn",
          noCSS: true
        },
        "file-highlight": {
          title: "File Highlight",
          description: "Fetch external files and highlight them with Prism. Used on the Prism website itself.",
          noCSS: true
        },
        "show-language": {
          title: "Show Language",
          description: "Display the highlighted language in code blocks (inline code does not show the label).",
          owner: "nauzilus",
          noCSS: true,
          require: "toolbar"
        },
        "jsonp-highlight": {
          title: "JSONP Highlight",
          description: "Fetch content with JSONP and highlight some interesting content (e.g. GitHub/Gists or Bitbucket API).",
          noCSS: true,
          owner: "nauzilus"
        },
        "highlight-keywords": {
          title: "Highlight Keywords",
          description: "Adds special CSS classes for each keyword for fine-grained highlighting.",
          owner: "vkbansal",
          noCSS: true
        },
        "remove-initial-line-feed": {
          title: "Remove initial line feed",
          description: "Removes the initial line feed in code blocks.",
          owner: "Golmote",
          noCSS: true
        },
        "inline-color": {
          title: "Inline color",
          description: "Adds a small inline preview for colors in style sheets.",
          require: "css-extras",
          owner: "RunDevelopment"
        },
        previewers: {
          title: "Previewers",
          description: "Previewers for angles, colors, gradients, easing and time.",
          require: "css-extras",
          owner: "Golmote"
        },
        autoloader: {
          title: "Autoloader",
          description: "Automatically loads the needed languages to highlight the code blocks.",
          owner: "Golmote",
          noCSS: true
        },
        "keep-markup": {
          title: "Keep Markup",
          description: "Prevents custom markup from being dropped out during highlighting.",
          owner: "Golmote",
          optional: "normalize-whitespace",
          noCSS: true
        },
        "command-line": {
          title: "Command Line",
          description: "Display a command line with a prompt and, optionally, the output/response from the commands.",
          owner: "chriswells0"
        },
        "unescaped-markup": {
          title: "Unescaped Markup",
          description: "Write markup without having to escape anything."
        },
        "normalize-whitespace": {
          title: "Normalize Whitespace",
          description: "Supports multiple operations to normalize whitespace in code blocks.",
          owner: "zeitgeist87",
          optional: "unescaped-markup",
          noCSS: true
        },
        "data-uri-highlight": {
          title: "Data-URI Highlight",
          description: "Highlights data-URI contents.",
          owner: "Golmote",
          noCSS: true
        },
        toolbar: {
          title: "Toolbar",
          description: "Attach a toolbar for plugins to easily register buttons on the top of a code block.",
          owner: "mAAdhaTTah"
        },
        "copy-to-clipboard": {
          title: "Copy to Clipboard Button",
          description: "Add a button that copies the code block to the clipboard when clicked.",
          owner: "mAAdhaTTah",
          require: "toolbar",
          noCSS: true
        },
        "download-button": {
          title: "Download Button",
          description: "A button in the toolbar of a code block adding a convenient way to download a code file.",
          owner: "Golmote",
          require: "toolbar",
          noCSS: true
        },
        "match-braces": {
          title: "Match braces",
          description: "Highlights matching braces.",
          owner: "RunDevelopment"
        },
        "diff-highlight": {
          title: "Diff Highlight",
          description: "Highlights the code inside diff blocks.",
          owner: "RunDevelopment",
          require: "diff"
        },
        "filter-highlight-all": {
          title: "Filter highlightAll",
          description: "Filters the elements the <code>highlightAll</code> and <code>highlightAllUnder</code> methods actually highlight.",
          owner: "RunDevelopment",
          noCSS: true
        },
        treeview: {
          title: "Treeview",
          description: "A language with special styles to highlight file system tree structures.",
          owner: "Golmote"
        }
      }
    };
  }
});

// node_modules/prismjs/prism.js
var require_prism = __commonJS({
  "node_modules/prismjs/prism.js"(exports, module) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism2 = function(_self2) {
      var lang3 = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _ = {
        manual: _self2.Prism && _self2.Prism.manual,
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        util: {
          encode: function encode3(tokens) {
            if (tokens instanceof Token3) {
              return new Token3(tokens.type, encode3(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode3);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone3;
            var id2;
            switch (_.util.type(o)) {
              case "Object":
                id2 = _.util.objId(o);
                if (visited[id2]) {
                  return visited[id2];
                }
                clone3 = {};
                visited[id2] = clone3;
                for (var key in o) {
                  if (o.hasOwnProperty(key)) {
                    clone3[key] = deepClone(o[key], visited);
                  }
                }
                return clone3;
              case "Array":
                id2 = _.util.objId(o);
                if (visited[id2]) {
                  return visited[id2];
                }
                clone3 = [];
                visited[id2] = clone3;
                o.forEach(function(v, i) {
                  clone3[i] = deepClone(v, visited);
                });
                return clone3;
              default:
                return o;
            }
          },
          getLanguage: function(element2) {
            while (element2) {
              var m = lang3.exec(element2.className);
              if (m) {
                return m[1].toLowerCase();
              }
              element2 = element2.parentElement;
            }
            return "none";
          },
          setLanguage: function(element2, language) {
            element2.className = element2.className.replace(RegExp(lang3, "gi"), "");
            element2.classList.add("language-" + language);
          },
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if ("currentScript" in document && 1 < 2) {
              return document.currentScript;
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i in scripts) {
                  if (scripts[i].src == src) {
                    return scripts[i];
                  }
                }
              }
              return null;
            }
          },
          isActive: function(element2, className, defaultActivation) {
            var no2 = "no-" + className;
            while (element2) {
              var classList = element2.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no2)) {
                return false;
              }
              element2 = element2.parentElement;
            }
            return !!defaultActivation;
          }
        },
        languages: {
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          extend: function(id2, redef) {
            var lang4 = _.util.clone(_.languages[id2]);
            for (var key in redef) {
              lang4[key] = redef[key];
            }
            return lang4;
          },
          insertBefore: function(inside, before2, insert2, root2) {
            root2 = root2 || _.languages;
            var grammar = root2[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before2) {
                  for (var newToken in insert2) {
                    if (insert2.hasOwnProperty(newToken)) {
                      ret[newToken] = insert2[newToken];
                    }
                  }
                }
                if (!insert2.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root2[inside];
            root2[inside] = ret;
            _.languages.DFS(_.languages, function(key, value2) {
              if (value2 === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          DFS: function DFS(o, callback, type2, visited) {
            visited = visited || {};
            var objId = _.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type2 || i);
                var property = o[i];
                var propertyType = _.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        highlightAll: function(async, callback) {
          _.highlightAllUnder(document, async, callback);
        },
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _.hooks.run("before-all-elements-highlight", env);
          for (var i = 0, element2; element2 = env.elements[i++]; ) {
            _.highlightElement(element2, async === true, env.callback);
          }
        },
        highlightElement: function(element2, async, callback) {
          var language = _.util.getLanguage(element2);
          var grammar = _.languages[language];
          _.util.setLanguage(element2, language);
          var parent = element2.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _.util.setLanguage(parent, language);
          }
          var code2 = element2.textContent;
          var env = {
            element: element2,
            language,
            grammar,
            code: code2
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _.hooks.run("after-highlight", env);
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
          }
        },
        highlight: function(text3, grammar, language) {
          var env = {
            code: text3,
            grammar,
            language
          };
          _.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _.tokenize(env.code, env.grammar);
          _.hooks.run("after-tokenize", env);
          return Token3.stringify(_.util.encode(env.tokens), env.language);
        },
        tokenize: function(text3, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text3);
          matchGrammar(text3, tokenList, grammar, tokenList.head, 0);
          return toArray2(tokenList);
        },
        hooks: {
          all: {},
          add: function(name2, callback) {
            var hooks = _.hooks.all;
            hooks[name2] = hooks[name2] || [];
            hooks[name2].push(callback);
          },
          run: function(name2, env) {
            var callbacks = _.hooks.all[name2];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token: Token3
      };
      _self2.Prism = _;
      function Token3(type2, content, alias, matchedStr) {
        this.type = type2;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token3.stringify = function stringify2(o, language) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s = "";
          o.forEach(function(e) {
            s += stringify2(e, language);
          });
          return s;
        }
        var env = {
          type: o.type,
          content: stringify2(o.content, language),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language
        };
        var aliases = o.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _.hooks.run("wrap", env);
        var attributes2 = "";
        for (var name2 in env.attributes) {
          attributes2 += " " + name2 + '="' + (env.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes2 + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text3, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text3);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text3, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j = 0; j < patterns.length; ++j) {
            if (rematch && rematch.cause == token + "," + j) {
              return;
            }
            var patternObj = patterns[j];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str2 = currentNode.value;
              if (tokenList.length > text3.length) {
                return;
              }
              if (str2 instanceof Token3) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text3, lookbehind);
                if (!match || match.index >= text3.length) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p2 = pos;
                p2 += currentNode.value.length;
                while (from >= p2) {
                  currentNode = currentNode.next;
                  p2 += currentNode.value.length;
                }
                p2 -= currentNode.value.length;
                pos = p2;
                if (currentNode.value instanceof Token3) {
                  continue;
                }
                for (var k = currentNode; k !== tokenList.tail && (p2 < to || typeof k.value === "string"); k = k.next) {
                  removeCount++;
                  p2 += k.value.length;
                }
                removeCount--;
                str2 = text3.slice(pos, p2);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str2, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before2 = str2.slice(0, from);
              var after2 = str2.slice(from + matchStr.length);
              var reach = pos + str2.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before2) {
                removeFrom = addAfter(tokenList, removeFrom, before2);
                pos += before2.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token3(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after2) {
                addAfter(tokenList, currentNode, after2);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j,
                  reach
                };
                matchGrammar(text3, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head2 = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head2, next: null };
        head2.next = tail;
        this.head = head2;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list2, node2, value2) {
        var next = node2.next;
        var newNode = { value: value2, prev: node2, next };
        node2.next = newNode;
        next.prev = newNode;
        list2.length++;
        return newNode;
      }
      function removeRange(list2, node2, count) {
        var next = node2.next;
        for (var i = 0; i < count && next !== list2.tail; i++) {
          next = next.next;
        }
        node2.next = next;
        next.prev = node2;
        list2.length -= i;
      }
      function toArray2(list2) {
        var array = [];
        var node2 = list2.head.next;
        while (node2 !== list2.tail) {
          array.push(node2.value);
          node2 = node2.next;
        }
        return array;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _;
        }
        if (!_.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message2 = JSON.parse(evt.data);
            var lang4 = message2.language;
            var code2 = message2.code;
            var immediateClose = message2.immediateClose;
            _self2.postMessage(_.highlight(code2, _.languages[lang4], lang4));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _;
      }
      var script = _.util.currentScript();
      if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_.manual) {
          _.highlightAll();
        }
      }
      if (!_.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _;
    }(_self);
    if (typeof module !== "undefined" && module.exports) {
      module.exports = Prism2;
    }
    if (typeof global !== "undefined") {
      global.Prism = Prism2;
    }
    Prism2.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
    Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
    Prism2.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
      value: function addInlined(tagName, lang3) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang3] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism2.languages[lang3]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang3] = {
          pattern: /[\s\S]+/,
          inside: Prism2.languages[lang3]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism2.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
      value: function(attrName, lang3) {
        Prism2.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang3, "language-" + lang3],
                  inside: Prism2.languages[lang3]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism2.languages.html = Prism2.languages.markup;
    Prism2.languages.mathml = Prism2.languages.markup;
    Prism2.languages.svg = Prism2.languages.markup;
    Prism2.languages.xml = Prism2.languages.extend("markup", {});
    Prism2.languages.ssml = Prism2.languages.xml;
    Prism2.languages.atom = Prism2.languages.xml;
    Prism2.languages.rss = Prism2.languages.xml;
    (function(Prism3) {
      var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism3.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
          }
        },
        "url": {
          pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
      var markup = Prism3.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism2);
    Prism2.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism2.languages.javascript = Prism2.languages.extend("clike", {
      "class-name": [
        Prism2.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + (/NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism2.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism2.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism2.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism2.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism2.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism2.languages.markup) {
      Prism2.languages.markup.tag.addInlined("script", "javascript");
      Prism2.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism2.languages.js = Prism2.languages.javascript;
    (function() {
      if (typeof Prism2 === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading\u2026";
      var FAILURE_MESSAGE = function(status, message2) {
        return "\u2716 Error " + status + " while fetching file: " + message2;
      };
      var FAILURE_EMPTY_MESSAGE = "\u2716 Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      function loadFile(src, success, error2) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              success(xhr.responseText);
            } else {
              if (xhr.status >= 400) {
                error2(FAILURE_MESSAGE(xhr.status, xhr.statusText));
              } else {
                error2(FAILURE_EMPTY_MESSAGE);
              }
            }
          }
        };
        xhr.send(null);
      }
      function parseRange(range2) {
        var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range2 || "");
        if (m) {
          var start2 = Number(m[1]);
          var comma2 = m[2];
          var end2 = m[3];
          if (!comma2) {
            return [start2, start2];
          }
          if (!end2) {
            return [start2, void 0];
          }
          return [start2, Number(end2)];
        }
        return void 0;
      }
      Prism2.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
      });
      Prism2.hooks.add("before-sanity-check", function(env) {
        var pre2 = env.element;
        if (pre2.matches(SELECTOR)) {
          env.code = "";
          pre2.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code2 = pre2.appendChild(document.createElement("CODE"));
          code2.textContent = LOADING_MESSAGE;
          var src = pre2.getAttribute("data-src");
          var language = env.language;
          if (language === "none") {
            var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
            language = EXTENSIONS[extension] || extension;
          }
          Prism2.util.setLanguage(code2, language);
          Prism2.util.setLanguage(pre2, language);
          var autoloader = Prism2.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language);
          }
          loadFile(
            src,
            function(text3) {
              pre2.setAttribute(STATUS_ATTR, STATUS_LOADED);
              var range2 = parseRange(pre2.getAttribute("data-range"));
              if (range2) {
                var lines = text3.split(/\r\n?|\n/g);
                var start2 = range2[0];
                var end2 = range2[1] == null ? lines.length : range2[1];
                if (start2 < 0) {
                  start2 += lines.length;
                }
                start2 = Math.max(0, Math.min(start2 - 1, lines.length));
                if (end2 < 0) {
                  end2 += lines.length;
                }
                end2 = Math.max(0, Math.min(end2, lines.length));
                text3 = lines.slice(start2, end2).join("\n");
                if (!pre2.hasAttribute("data-start")) {
                  pre2.setAttribute("data-start", String(start2 + 1));
                }
              }
              code2.textContent = text3;
              Prism2.highlightElement(code2);
            },
            function(error2) {
              pre2.setAttribute(STATUS_ATTR, STATUS_FAILED);
              code2.textContent = error2;
            }
          );
        }
      });
      Prism2.plugins.fileHighlight = {
        highlight: function highlight(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i = 0, element2; element2 = elements[i++]; ) {
            Prism2.highlightElement(element2);
          }
        }
      };
      var logged = false;
      Prism2.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  }
});

// node_modules/mdsvex/dist/main.es.js
var path = __toESM(require_path());
var import_path = __toESM(require_path());
var import_fs = __toESM(require_fs());

// node_modules/svelte/compiler.mjs
var now = typeof process !== "undefined" && process.hrtime ? () => {
  const t = process.hrtime();
  return t[0] * 1e3 + t[1] / 1e6;
} : () => self.performance.now();
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code2, set2) {
  var pos = 65536;
  for (var i = 0; i < set2.length; i += 2) {
    pos += set2[i];
    if (pos > code2) {
      return false;
    }
    pos += set2[i + 1];
    if (pos >= code2) {
      return true;
    }
  }
}
function isIdentifierStart(code2, astral) {
  if (code2 < 65) {
    return code2 === 36;
  }
  if (code2 < 91) {
    return true;
  }
  if (code2 < 97) {
    return code2 === 95;
  }
  if (code2 < 123) {
    return true;
  }
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code2, astralIdentifierStartCodes);
}
function isIdentifierChar(code2, astral) {
  if (code2 < 48) {
    return code2 === 36;
  }
  if (code2 < 58) {
    return true;
  }
  if (code2 < 65) {
    return false;
  }
  if (code2 < 91) {
    return true;
  }
  if (code2 < 97) {
    return code2 === 95;
  }
  if (code2 < 123) {
    return true;
  }
  if (code2 <= 65535) {
    return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0)
    conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name2, prec2) {
  return new TokenType(name2, { beforeExpr: true, binop: prec2 });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name2, options2) {
  if (options2 === void 0)
    options2 = {};
  options2.keyword = name2;
  return keywords[name2] = new TokenType(name2, options2);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code2) {
  return code2 === 10 || code2 === 13 || code2 === 8232 || code2 === 8233;
}
function nextLineBreak(code2, from, end2) {
  if (end2 === void 0)
    end2 = code2.length;
  for (var i = from; i < end2; i++) {
    var next = code2.charCodeAt(i);
    if (isNewLine(next)) {
      return i < end2 - 1 && next === 13 && code2.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString.call(obj) === "[object Array]";
};
function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}
function codePointToString(code2) {
  if (code2 <= 65535) {
    return String.fromCharCode(code2);
  }
  code2 -= 65536;
  return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line2, col) {
  this.line = line2;
  this.column = col;
};
Position.prototype.offset = function offset(n2) {
  return new Position(this.line, this.column + n2);
};
var SourceLocation = function SourceLocation2(p2, start2, end2) {
  this.start = start2;
  this.end = end2;
  if (p2.sourceFile !== null) {
    this.source = p2.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line2 = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line2, offset2 - cur);
    }
    ++line2;
    cur = nextBreak;
  }
}
var defaultOptions = {
  ecmaVersion: null,
  sourceType: "script",
  onInsertedSemicolon: null,
  onTrailingComma: null,
  allowReserved: null,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowAwaitOutsideFunction: null,
  allowSuperOutsideMethod: null,
  allowHashBang: false,
  locations: false,
  onToken: null,
  onComment: null,
  ranges: false,
  program: null,
  sourceFile: null,
  directSourceFile: null,
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options2 = {};
  for (var opt in defaultOptions) {
    options2[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options2.ecmaVersion === "latest") {
    options2.ecmaVersion = 1e8;
  } else if (options2.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options2.ecmaVersion = 11;
  } else if (options2.ecmaVersion >= 2015) {
    options2.ecmaVersion -= 2009;
  }
  if (options2.allowReserved == null) {
    options2.allowReserved = options2.ecmaVersion < 5;
  }
  if (isArray(options2.onToken)) {
    var tokens = options2.onToken;
    options2.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options2.onComment)) {
    options2.onComment = pushComment(options2, options2.onComment);
  }
  return options2;
}
function pushComment(options2, array) {
  return function(block2, text3, start2, end2, startLoc, endLoc) {
    var comment2 = {
      type: block2 ? "Block" : "Line",
      value: text3,
      start: start2,
      end: end2
    };
    if (options2.locations) {
      comment2.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options2.ranges) {
      comment2.range = [start2, end2];
    }
    array.push(comment2);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options2, input, startPos) {
  this.options = options2 = getOptions(options2);
  this.sourceFile = options2.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options2.ecmaVersion >= 6 ? 6 : options2.sourceType === "module" ? "5module" : 5]);
  var reserved2 = "";
  if (options2.allowReserved !== true) {
    reserved2 = reservedWords[options2.ecmaVersion >= 6 ? 6 : options2.ecmaVersion === 5 ? 5 : 3];
    if (options2.sourceType === "module") {
      reserved2 += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved2);
  var reservedStrict = (reserved2 ? reserved2 + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options2.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options2.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse() {
  var node2 = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node2);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var scope2 = this.scopeStack[i];
    if (scope2.inClassFieldInit || scope2.flags & SCOPE_CLASS_STATIC_BLOCK) {
      return false;
    }
    if (scope2.flags & SCOPE_FUNCTION) {
      return (scope2.flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend() {
  var plugins = [], len = arguments.length;
  while (len--)
    plugins[len] = arguments[len];
  var cls = this;
  for (var i = 0; i < plugins.length; i++) {
    cls = plugins[i](cls);
  }
  return cls;
};
Parser.parse = function parse2(input, options2) {
  return new this(options2, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options2) {
  var parser3 = new this(options2, input, pos);
  parser3.nextToken();
  return parser3.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options2) {
  return new this(options2, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start2) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start2;
    start2 += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start2));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start2 + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end2 = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end2);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end2 + 1) === "=");
    }
    start2 += match[0].length;
    skipWhiteSpace.lastIndex = start2;
    start2 += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start2] === ";") {
      start2++;
    }
  }
};
pp$9.eat = function(type2) {
  if (this.type === type2) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name2) {
  return this.type === types$1.name && this.value === name2 && !this.containsEsc;
};
pp$9.eatContextual = function(name2) {
  if (!this.isContextual(name2)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name2) {
  if (!this.eatContextual(name2)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type2) {
  this.eat(type2) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node2) {
  var exports = /* @__PURE__ */ Object.create(null);
  if (!node2.body) {
    node2.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node2.body.push(stmt);
  }
  if (this.inModule) {
    for (var i = 0, list2 = Object.keys(this.undefinedExports); i < list2.length; i += 1) {
      var name2 = list2[i];
      this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node2.body);
  this.next();
  node2.sourceType = this.options.sourceType;
  return this.finishNode(node2, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context2) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (context2) {
    return false;
  }
  if (nextCh === 123) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after2;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after2 = this.input.charCodeAt(next + 8)) || after2 > 55295 && after2 < 56320));
};
pp$8.parseStatement = function(context2, topLevel, exports) {
  var starttype = this.type, node2 = this.startNode(), kind;
  if (this.isLet(context2)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node2, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node2);
    case types$1._do:
      return this.parseDoStatement(node2);
    case types$1._for:
      return this.parseForStatement(node2);
    case types$1._function:
      if (context2 && (this.strict || context2 !== "if" && context2 !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node2, false, !context2);
    case types$1._class:
      if (context2) {
        this.unexpected();
      }
      return this.parseClass(node2, true);
    case types$1._if:
      return this.parseIfStatement(node2);
    case types$1._return:
      return this.parseReturnStatement(node2);
    case types$1._switch:
      return this.parseSwitchStatement(node2);
    case types$1._throw:
      return this.parseThrowStatement(node2);
    case types$1._try:
      return this.parseTryStatement(node2);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context2 && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node2, kind);
    case types$1._while:
      return this.parseWhileStatement(node2);
    case types$1._with:
      return this.parseWithStatement(node2);
    case types$1.braceL:
      return this.parseBlock(true, node2);
    case types$1.semi:
      return this.parseEmptyStatement(node2);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node2, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node2) : this.parseExport(node2, exports);
    default:
      if (this.isAsyncFunction()) {
        if (context2) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node2, true, !context2);
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node2, maybeName, expr, context2);
      } else {
        return this.parseExpressionStatement(node2, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node2, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node2.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node2.label = this.parseIdent();
    this.semicolon();
  }
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node2.label == null || lab.name === node2.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node2.label && isBreak) {
        break;
      }
    }
  }
  if (i === this.labels.length) {
    this.raise(node2.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node2) {
  this.next();
  this.semicolon();
  return this.finishNode(node2, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node2) {
  this.next();
  this.labels.push(loopLabel);
  node2.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node2.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node2, "DoWhileStatement");
};
pp$8.parseForStatement = function(node2) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node2.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node2, init$1);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, init$1);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var refDestructuringErrors = new DestructuringErrors();
  var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node2.await = awaitAt > -1;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node2, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node2, init);
};
pp$8.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node2) {
  this.next();
  node2.test = this.parseParenExpression();
  node2.consequent = this.parseStatement("if");
  node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node2, "IfStatement");
};
pp$8.parseReturnStatement = function(node2) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node2.argument = null;
  } else {
    node2.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node2, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node2) {
  this.next();
  node2.discriminant = this.parseParenExpression();
  node2.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node2.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node2, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node2) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node2.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node2, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseTryStatement = function(node2) {
  this.next();
  node2.block = this.parseBlock();
  node2.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types$1.parenR);
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node2.handler = this.finishNode(clause, "CatchClause");
  }
  node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node2.handler && !node2.finalizer) {
    this.raise(node2.start, "Missing catch or finally clause");
  }
  return this.finishNode(node2, "TryStatement");
};
pp$8.parseVarStatement = function(node2, kind) {
  this.next();
  this.parseVar(node2, false, kind);
  this.semicolon();
  return this.finishNode(node2, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node2) {
  this.next();
  node2.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node2.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node2, "WhileStatement");
};
pp$8.parseWithStatement = function(node2) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node2.object = this.parseParenExpression();
  node2.body = this.parseStatement("with");
  return this.finishNode(node2, "WithStatement");
};
pp$8.parseEmptyStatement = function(node2) {
  this.next();
  return this.finishNode(node2, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node2, maybeName, expr, context2) {
  for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
    var label = list2[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node2.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node2.body = this.parseStatement(context2 ? context2.indexOf("label") === -1 ? context2 + "label" : context2 : "label");
  this.labels.pop();
  node2.label = expr;
  return this.finishNode(node2, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node2, expr) {
  node2.expression = expr;
  this.semicolon();
  return this.finishNode(node2, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
  if (createNewLexicalScope === void 0)
    createNewLexicalScope = true;
  if (node2 === void 0)
    node2 = this.startNode();
  node2.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node2.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node2, "BlockStatement");
};
pp$8.parseFor = function(node2, init) {
  node2.init = init;
  this.expect(types$1.semi);
  node2.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node2.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node2.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node2, "ForStatement");
};
pp$8.parseForIn = function(node2, init) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node2.left = init;
  node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node2.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node2, isFor, kind) {
  node2.declarations = [];
  node2.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node2;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node2.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node2.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node2.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node2.async, node2.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node2.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node2);
  this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node2) {
  this.expect(types$1.parenL);
  node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node2, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node2, isStatement);
  this.parseClassSuper(node2);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element2 = this.parseClassElement(node2.superClass !== null);
    if (element2) {
      classBody.body.push(element2);
      if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
        if (hadConstructor) {
          this.raise(element2.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element2)) {
        this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node2.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node2 = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node2);
      return node2;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node2.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node2.computed = false;
    node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node2.key.name = keyName;
    this.finishNode(node2.key, "Identifier");
  } else {
    this.parseClassElementName(node2);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node2.static && checkKeyName(node2, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node2.key.start, "Constructor can't have get/set modifier");
    }
    node2.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node2);
  }
  return node2;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element2) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element2.computed = false;
    element2.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element2);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value2.params.length !== 0) {
    this.raiseRecoverable(value2.start, "getter should have no params");
  }
  if (method.kind === "set" && value2.params.length !== 1) {
    this.raiseRecoverable(value2.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value2.params[0].type === "RestElement") {
    this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    var scope2 = this.currentThisScope();
    var inClassFieldInit = scope2.inClassFieldInit;
    scope2.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope2.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node2) {
  node2.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node2.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node2, "StaticBlock");
};
pp$8.parseClassId = function(node2, isStatement) {
  if (this.type === types$1.name) {
    node2.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node2.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node2.id = null;
  }
};
pp$8.parseClassSuper = function(node2) {
  node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(false) : null;
};
pp$8.enterClassBody = function() {
  var element2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element2);
  return element2.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id2 = used[i];
    if (!hasOwn(declared, id2.name)) {
      if (parent) {
        parent.used.push(id2);
      } else {
        this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element2) {
  var name2 = element2.key.name;
  var curr = privateNameMap[name2];
  var next = "true";
  if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
    next = (element2.static ? "s" : "i") + element2.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name2] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name2] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node2, name2) {
  var computed = node2.computed;
  var key = node2.key;
  return !computed && (key.type === "Identifier" && key.name === name2 || key.type === "Literal" && key.value === name2);
}
pp$8.parseExport = function(node2, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    if (this.options.ecmaVersion >= 11) {
      if (this.eatContextual("as")) {
        node2.exported = this.parseModuleExportName();
        this.checkExport(exports, node2.exported, this.lastTokStart);
      } else {
        node2.exported = null;
      }
    }
    this.expectContextual("from");
    if (this.type !== types$1.string) {
      this.unexpected();
    }
    node2.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node2, "ExportAllDeclaration");
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) {
        this.next();
      }
      node2.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types$1._class) {
      var cNode = this.startNode();
      node2.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node2.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node2, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node2.declaration = this.parseStatement(null);
    if (node2.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node2.declaration.declarations);
    } else {
      this.checkExport(exports, node2.declaration.id, node2.declaration.id.start);
    }
    node2.specifiers = [];
    node2.source = null;
  } else {
    node2.declaration = null;
    node2.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node2.source = this.parseExprAtom();
    } else {
      for (var i = 0, list2 = node2.specifiers; i < list2.length; i += 1) {
        var spec = list2[i];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node2.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node2, "ExportNamedDeclaration");
};
pp$8.checkExport = function(exports, name2, pos) {
  if (!exports) {
    return;
  }
  if (typeof name2 !== "string") {
    name2 = name2.type === "Identifier" ? name2.name : name2.value;
  }
  if (hasOwn(exports, name2)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
  }
  exports[name2] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type2 = pat.type;
  if (type2 === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type2 === "ObjectPattern") {
    for (var i = 0, list2 = pat.properties; i < list2.length; i += 1) {
      var prop2 = list2[i];
      this.checkPatternExport(exports, prop2);
    }
  } else if (type2 === "ArrayPattern") {
    for (var i$1 = 0, list$13 = pat.elements; i$1 < list$13.length; i$1 += 1) {
      var elt = list$13[i$1];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type2 === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type2 === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type2 === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  } else if (type2 === "ParenthesizedExpression") {
    this.checkPatternExport(exports, pat.expression);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i = 0, list2 = decls; i < list2.length; i += 1) {
    var decl = list2[i];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first2 = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first2 = false;
    }
    var node2 = this.startNode();
    node2.local = this.parseModuleExportName();
    node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
    this.checkExport(
      exports,
      node2.exported,
      node2.exported.start
    );
    nodes.push(this.finishNode(node2, "ExportSpecifier"));
  }
  return nodes;
};
pp$8.parseImport = function(node2) {
  this.next();
  if (this.type === types$1.string) {
    node2.specifiers = empty$1;
    node2.source = this.parseExprAtom();
  } else {
    node2.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node2.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node2, "ImportDeclaration");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first2 = true;
  if (this.type === types$1.name) {
    var node2 = this.startNode();
    node2.local = this.parseIdent();
    this.checkLValSimple(node2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node2, "ImportDefaultSpecifier"));
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLValSimple(node$1.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first2 = false;
    }
    var node$2 = this.startNode();
    node$2.imported = this.parseModuleExportName();
    if (this.eatContextual("as")) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLValSimple(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes;
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node2, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node2) {
    switch (node2.type) {
      case "Identifier":
        if (this.inAsync && node2.name === "await") {
          this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node2.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i = 0, list2 = node2.properties; i < list2.length; i += 1) {
          var prop2 = list2[i];
          this.toAssignable(prop2, isBinding);
          if (prop2.type === "RestElement" && (prop2.argument.type === "ArrayPattern" || prop2.argument.type === "ObjectPattern")) {
            this.raise(prop2.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node2.kind !== "init") {
          this.raise(node2.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node2.value, isBinding);
        break;
      case "ArrayExpression":
        node2.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node2.elements, isBinding);
        break;
      case "SpreadElement":
        node2.type = "RestElement";
        this.toAssignable(node2.argument, isBinding);
        if (node2.argument.type === "AssignmentPattern") {
          this.raise(node2.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node2.operator !== "=") {
          this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node2.type = "AssignmentPattern";
        delete node2.operator;
        this.toAssignable(node2.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node2.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node2;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end2 = exprList.length;
  for (var i = 0; i < end2; i++) {
    var elt = exprList[i];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end2) {
    var last = exprList[end2 - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node2 = this.startNode();
  this.next();
  node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node2, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node2 = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node2.argument = this.parseBindingAtom();
  return this.finishNode(node2, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node2 = this.startNode();
        this.next();
        node2.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node2, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first2 = true;
  while (!this.eat(close)) {
    if (first2) {
      first2 = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close);
      break;
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left2) {
  left2 = left2 || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left2;
  }
  var node2 = this.startNodeAt(startPos, startLoc);
  node2.left = left2;
  node2.right = this.parseMaybeAssign();
  return this.finishNode(node2, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list2 = expr.properties; i < list2.length; i += 1) {
        var prop2 = list2[i];
        this.checkLValInnerPattern(prop2, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$13 = expr.elements; i$1 < list$13.length; i$1 += 1) {
        var elem = list$13[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p2) {
    return p2.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context2 = this.context[i];
    if (context2.token === "function") {
      return context2.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type2 = this.type;
  if (type2.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type2.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type2.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index2 = this.context.length - 1;
    if (this.context[index2] === types.f_expr) {
      this.context[index2] = types.f_expr_gen;
    } else {
      this.context[index2] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop2, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop2.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop2.computed || prop2.method || prop2.shorthand)) {
    return;
  }
  var key = prop2.key;
  var name2;
  switch (key.type) {
    case "Identifier":
      name2 = key.name;
      break;
    case "Literal":
      name2 = String(key.value);
      break;
    default:
      return;
  }
  var kind = prop2.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name2 === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name2 = "$" + name2;
  var other = propHash[name2];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name2] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node2, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left2 = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left2 = afterLeftParse.call(this, left2, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.operator = this.value;
    if (this.type === types$1.eq) {
      left2 = this.toAssignable(left2, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left2.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left2);
    } else {
      this.checkLValSimple(left2);
    }
    node2.left = left2;
    this.next();
    node2.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node2, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left2;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.test = expr;
    node2.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node2.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node2, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left2, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec2 = this.type.binop;
  if (prec2 != null && (!forInit || this.type !== types$1._in)) {
    if (prec2 > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec2 = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right2 = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec2, forInit);
      var node2 = this.buildBinary(leftStartPos, leftStartLoc, left2, right2, op, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left2;
};
pp$5.buildBinary = function(startPos, startLoc, left2, right2, op, logical) {
  if (right2.type === "PrivateIdentifier") {
    this.raise(right2.start, "Private identifier can only be left side of binary expression");
  }
  var node2 = this.startNodeAt(startPos, startLoc);
  node2.left = left2;
  node2.operator = op;
  node2.right = right2;
  return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node2 = this.startNode(), update = this.type === types$1.incDec;
    node2.operator = this.value;
    node2.prefix = true;
    this.next();
    node2.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node2.argument);
    } else if (this.strict && node2.operator === "delete" && node2.argument.type === "Identifier") {
      this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
    } else if (node2.operator === "delete" && isPrivateFieldAccess(node2.argument)) {
      this.raiseRecoverable(node2.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if (forInit || this.privateNameStack.length === 0) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isPrivateFieldAccess(node2) {
  return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess(node2.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;
  while (true) {
    var element2 = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element2.optional) {
      optionalChained = true;
    }
    if (element2 === base || element2.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element2;
        element2 = this.finishNode(chainNode, "ChainExpression");
      }
      return element2;
    }
    base = element2;
  }
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional2 = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional2) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional2 && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.object = base;
    if (computed) {
      node2.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node2.property = this.parsePrivateIdent();
    } else {
      node2.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node2.computed = !!computed;
    if (optionalSupported) {
      node2.optional = optional2;
    }
    base = this.finishNode(node2, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional2 && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional2;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional2 || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node2, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node2 = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node2.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node2, "Super");
    case types$1._this:
      node2 = this.startNode();
      this.next();
      return this.finishNode(node2, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id2 = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id2 = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true, forInit);
        }
      }
      return id2;
    case types$1.regexp:
      var value2 = this.value;
      node2 = this.parseLiteral(value2.value);
      node2.regex = { pattern: value2.pattern, flags: value2.flags };
      return node2;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node2 = this.startNode();
      node2.value = this.type === types$1._null ? null : this.type === types$1._true;
      node2.raw = this.type.keyword;
      this.next();
      return this.finishNode(node2, "Literal");
    case types$1.parenL:
      var start2 = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start2;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start2;
        }
      }
      return expr;
    case types$1.bracketL:
      node2 = this.startNode();
      this.next();
      node2.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node2, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node2 = this.startNode();
      this.next();
      return this.parseFunction(node2, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport();
      } else {
        return this.unexpected();
      }
    default:
      this.unexpected();
  }
};
pp$5.parseExprImport = function() {
  var node2 = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  var meta2 = this.parseIdent(true);
  switch (this.type) {
    case types$1.parenL:
      return this.parseDynamicImport(node2);
    case types$1.dot:
      node2.meta = meta2;
      return this.parseImportMeta(node2);
    default:
      this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node2) {
  this.next();
  node2.source = this.parseMaybeAssign();
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }
  return this.finishNode(node2, "ImportExpression");
};
pp$5.parseImportMeta = function(node2) {
  this.next();
  var containsEsc = this.containsEsc;
  node2.property = this.parseIdent(true);
  if (node2.property.name !== "meta") {
    this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node2, "MetaProperty");
};
pp$5.parseLiteral = function(value2) {
  var node2 = this.startNode();
  node2.value = value2;
  node2.raw = this.input.slice(this.start, this.end);
  if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
    node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node2, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first2 = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first2 ? first2 = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par2 = this.startNodeAt(startPos, startLoc);
    par2.expression = val;
    return this.finishNode(par2, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node2 = this.startNode();
  var meta2 = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
    node2.meta = meta2;
    var containsEsc = this.containsEsc;
    node2.property = this.parseIdent(true);
    if (node2.property.name !== "target") {
      this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node2, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
  node2.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
  if (isImport && node2.callee.type === "ImportExpression") {
    this.raise(startPos, "Cannot use new with import()");
  }
  if (this.eat(types$1.parenL)) {
    node2.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node2.arguments = empty;
  }
  return this.finishNode(node2, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0)
    isTagged = false;
  var node2 = this.startNode();
  this.next();
  node2.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node2.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node2.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node2, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop2) {
  return !prop2.computed && prop2.key.type === "Identifier" && prop2.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node2 = this.startNode(), first2 = true, propHash = {};
  node2.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first2 = false;
    }
    var prop2 = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop2, propHash, refDestructuringErrors);
    }
    node2.properties.push(prop2);
  }
  return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop2 = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop2.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop2, "RestElement");
    }
    if (this.type === types$1.parenL && refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }
      if (refDestructuringErrors.parenthesizedBind < 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    }
    prop2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop2, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop2.method = false;
    prop2.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop2);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop2)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop2, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop2, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop2, "Property");
};
pp$5.parsePropertyValue = function(prop2, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop2.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop2.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop2.kind = "init";
    prop2.method = true;
    prop2.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop2.computed && prop2.key.type === "Identifier" && (prop2.key.name === "get" || prop2.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    prop2.kind = prop2.key.name;
    this.parsePropertyName(prop2);
    prop2.value = this.parseMethod(false);
    var paramCount = prop2.kind === "get" ? 0 : 1;
    if (prop2.value.params.length !== paramCount) {
      var start2 = prop2.value.start;
      if (prop2.kind === "get") {
        this.raiseRecoverable(start2, "getter should have no params");
      } else {
        this.raiseRecoverable(start2, "setter should have exactly one param");
      }
    } else {
      if (prop2.kind === "set" && prop2.value.params[0].type === "RestElement") {
        this.raiseRecoverable(prop2.value.params[0].start, "Setter cannot use rest params");
      }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop2.computed && prop2.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop2.key);
    if (prop2.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    prop2.kind = "init";
    if (isPattern) {
      prop2.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop2.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop2.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop2.key));
    } else {
      prop2.value = this.copyNode(prop2.key);
    }
    prop2.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop2) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop2.computed = true;
      prop2.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop2.key;
    } else {
      prop2.computed = false;
    }
  }
  return prop2.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node2) {
  node2.id = null;
  if (this.options.ecmaVersion >= 6) {
    node2.generator = node2.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 6) {
    node2.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node2.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node2, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node2, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node2.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node2, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node2.body = this.parseMaybeAssign(forInit);
    node2.expression = true;
    this.checkParams(node2, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
    if (this.strict && node2.id) {
      this.checkLValSimple(node2.id, BIND_OUTSIDE);
    }
    node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node2.expression = false;
    this.adaptDirectivePrologue(node2.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list2 = params; i < list2.length; i += 1) {
    var param = list2[i];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node2, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i = 0, list2 = node2.params; i < list2.length; i += 1) {
    var param = list2[i];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first2 = true;
  while (!this.eat(close)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) {
        break;
      }
    } else {
      first2 = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start2 = ref2.start;
  var end2 = ref2.end;
  var name2 = ref2.name;
  if (this.inGenerator && name2 === "yield") {
    this.raiseRecoverable(start2, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name2 === "await") {
    this.raiseRecoverable(start2, "Cannot use 'await' as identifier inside an async function");
  }
  if (this.currentThisScope().inClassFieldInit && name2 === "arguments") {
    this.raiseRecoverable(start2, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
    this.raise(start2, "Cannot use " + name2 + " in class static initialization block");
  }
  if (this.keywords.test(name2)) {
    this.raise(start2, "Unexpected keyword '" + name2 + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start2, end2).indexOf("\\") !== -1) {
    return;
  }
  var re3 = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re3.test(name2)) {
    if (!this.inAsync && name2 === "await") {
      this.raiseRecoverable(start2, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start2, "The keyword '" + name2 + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal, isBinding) {
  var node2 = this.startNode();
  if (this.type === types$1.name) {
    node2.name = this.value;
  } else if (this.type.keyword) {
    node2.name = this.type.keyword;
    if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next(!!liberal);
  this.finishNode(node2, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node2);
    if (node2.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node2.start;
    }
  }
  return node2;
};
pp$5.parsePrivateIdent = function() {
  var node2 = this.startNode();
  if (this.type === types$1.privateId) {
    node2.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node2, "PrivateIdentifier");
  if (this.privateNameStack.length === 0) {
    this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
  } else {
    this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
  }
  return node2;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node2 = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node2.delegate = false;
    node2.argument = null;
  } else {
    node2.delegate = this.eat(types$1.star);
    node2.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node2, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node2 = this.startNode();
  this.next();
  node2.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node2, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message2) {
  var loc = getLineInfo(this.input, pos);
  message2 += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message2);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
  this.inClassFieldInit = false;
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope2) {
  return scope2.flags & SCOPE_FUNCTION || !this.inModule && scope2.flags & SCOPE_TOP;
};
pp$3.declareName = function(name2, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope2 = this.currentScope();
    redeclared = scope2.lexical.indexOf(name2) > -1 || scope2.functions.indexOf(name2) > -1 || scope2.var.indexOf(name2) > -1;
    scope2.lexical.push(name2);
    if (this.inModule && scope2.flags & SCOPE_TOP) {
      delete this.undefinedExports[name2];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name2);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name2) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
    }
    scope$2.functions.push(name2);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name2);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name2];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id2) {
  if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
    this.undefinedExports[id2.name] = id2;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope2 = this.scopeStack[i];
    if (scope2.flags & SCOPE_VAR) {
      return scope2;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope2 = this.scopeStack[i];
    if (scope2.flags & SCOPE_VAR && !(scope2.flags & SCOPE_ARROW)) {
      return scope2;
    }
  }
};
var Node = function Node2(parser3, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser3.options.locations) {
    this.loc = new SourceLocation(parser3, loc);
  }
  if (parser3.options.directSourceFile) {
    this.sourceFile = parser3.options.directSourceFile;
  }
  if (parser3.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node2, type2, pos, loc) {
  node2.type = type2;
  node2.end = pos;
  if (this.options.locations) {
    node2.loc.end = loc;
  }
  if (this.options.ranges) {
    node2.range[1] = pos;
  }
  return node2;
}
pp$2.finishNode = function(node2, type2) {
  return finishNodeAt.call(this, node2, type2, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node2, type2, pos, loc) {
  return finishNodeAt.call(this, node2, type2, pos, loc);
};
pp$2.copyNode = function(node2) {
  var newNode = new Node(this, node2.start, this.startLoc);
  for (var prop2 in node2) {
    newNode[prop2] = node2[prop2];
  }
  return newNode;
};
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (i = 0, list2 = [9, 10, 11, 12, 13]; i < list2.length; i += 1) {
  ecmaVersion = list2[i];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i;
var list2;
var pp$1 = Parser.prototype;
var RegExpValidationState = function RegExpValidationState2(parser3) {
  this.parser = parser3;
  this.validFlags = "gim" + (parser3.options.ecmaVersion >= 6 ? "uy" : "") + (parser3.options.ecmaVersion >= 9 ? "s" : "") + (parser3.options.ecmaVersion >= 13 ? "d" : "");
  this.unicodeProperties = data[parser3.options.ecmaVersion >= 13 ? 13 : parser3.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};
RegExpValidationState.prototype.reset = function reset(start2, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start2 | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};
RegExpValidationState.prototype.raise = function raise(message2) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message2);
};
RegExpValidationState.prototype.at = function at(i, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l2 = s.length;
  if (i >= l2) {
    return -1;
  }
  var c2 = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i + 1 >= l2) {
    return c2;
  }
  var next = s.charCodeAt(i + 1);
  return next >= 56320 && next <= 57343 ? (c2 << 10) + next - 56613888 : c2;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s = this.source;
  var l2 = s.length;
  if (i >= l2) {
    return l2;
  }
  var c2 = s.charCodeAt(i), next;
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i + 1 >= l2 || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
    return i + 1;
  }
  return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0)
    forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0)
    forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
  }
};
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(41)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(93) || state.eat(125)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list2 = state.backReferenceNames; i < list2.length; i += 1) {
    var name2 = list2[i];
    if (state.groupNames.indexOf(name2) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(124)) {
    this.regexp_alternative(state);
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(123)) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start2 = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(94) || state.eat(36)) {
    return true;
  }
  if (state.eat(92)) {
    if (state.eat(66) || state.eat(98)) {
      return true;
    }
    state.pos = start2;
  }
  if (state.eat(40) && state.eat(63)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(60);
    }
    if (state.eat(61) || state.eat(33)) {
      this.regexp_disjunction(state);
      if (!state.eat(41)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start2;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0)
    noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(63);
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start2 = state.pos;
  if (state.eat(123)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(125)) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start2 = state.pos;
  if (state.eat(92)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start2 = state.pos;
  if (state.eat(40)) {
    if (state.eat(63) && state.eat(58)) {
      this.regexp_disjunction(state);
      if (state.eat(41)) {
        return true;
      }
      state.raise("Unterminated group");
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(40)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(41)) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start2 = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start2;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(63)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return;
    }
    state.raise("Invalid group");
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(60)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start2 = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start2;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start2 = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start2;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start2 = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n2 = state.lastIntValue;
    if (state.switchU) {
      if (n2 > state.maxBackReference) {
        state.maxBackReference = n2;
      }
      return true;
    }
    if (n2 <= state.numCapturingParens) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(107)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start2 = state.pos;
  if (state.eat(99)) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0)
    forceU = false;
  var start2 = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(117)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start2;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(47)) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true;
  }
  if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    if (state.eat(123) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(125)) {
      return true;
    }
    state.raise("Invalid property name");
  }
  return false;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start2 = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
    var name2 = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value2 = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name2, value2);
      return true;
    }
  }
  state.pos = start2;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true;
  }
  return false;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value2) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name2)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name2].test(value2)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue)) {
    state.raise("Invalid property name");
  }
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(91)) {
    state.eat(94);
    this.regexp_classRanges(state);
    if (state.eat(93)) {
      return true;
    }
    state.raise("Unterminated character class");
  }
  return false;
};
pp$1.regexp_classRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left2 = state.lastIntValue;
    if (state.eat(45) && this.regexp_eatClassAtom(state)) {
      var right2 = state.lastIntValue;
      if (state.switchU && (left2 === -1 || right2 === -1)) {
        state.raise("Invalid character class");
      }
      if (left2 !== -1 && right2 !== -1 && left2 > right2) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start2 = state.pos;
  if (state.eat(92)) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start2;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start2 = state.pos;
  if (state.eat(98)) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(45)) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(99)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start2;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start2 = state.pos;
  if (state.eat(120)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start2;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start2 = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start2;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start2 = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start2;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length2) {
  var start2 = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length2; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start2;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p2) {
  this.type = p2.type;
  this.value = p2.value;
  this.start = p2.start;
  this.end = p2.end;
  if (p2.options.locations) {
    this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc);
  }
  if (p2.options.ranges) {
    this.range = [p2.start, p2.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code2) {
  if (isIdentifierStart(code2, this.options.ecmaVersion >= 6) || code2 === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code2);
};
pp.fullCharCodeAtPos = function() {
  var code2 = this.input.charCodeAt(this.pos);
  if (code2 <= 55295 || code2 >= 56320) {
    return code2;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 56319 || next >= 57344 ? code2 : (code2 << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start2 = this.pos, end2 = this.input.indexOf("*/", this.pos += 2);
  if (end2 === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end2 + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start2; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start2 + 2, end2),
      start2,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start2 = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start2 + startSkip, this.pos),
      start2,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop:
    while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10:
        case 8232:
        case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break loop;
          }
          break;
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break loop;
          }
      }
    }
};
pp.finishToken = function(type2, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type2;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code2 === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code2 === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code2) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code2 === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code2 === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code2) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code2) {
    size = code2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next === 33 && code2 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code2) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code2 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code2 === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code2 = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code2 = this.fullCharCodeAtPos();
    if (isIdentifierStart(code2, true) || code2 === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
};
pp.getTokenFromCode = function(code2) {
  switch (code2) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        }
        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code2);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code2);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code2);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code2);
    case 60:
    case 62:
      return this.readToken_lt_gt(code2);
    case 61:
    case 33:
      return this.readToken_eq_excl(code2);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
};
pp.finishOp = function(type2, size) {
  var str2 = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type2, str2);
};
pp.readRegexp = function() {
  var escaped, inClass, start2 = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start2, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start2, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped = ch === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start2, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start2, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value2 = null;
  try {
    value2 = new RegExp(pattern, flags);
  } catch (e) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value: value2 });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start2 = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
    var code2 = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code2 === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code2;
      continue;
    }
    if (code2 >= 97) {
      val = code2 - 97 + 10;
    } else if (code2 >= 65) {
      val = code2 - 65 + 10;
    } else if (code2 >= 48 && code2 <= 57) {
      val = code2 - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code2;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start2 || len != null && this.pos - start2 !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str2, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str2, 8);
  }
  return parseFloat(str2.replace(/_/g, ""));
}
function stringToBigInt(str2) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str2.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start2 = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start2, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start2 = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start2, "Invalid number");
  }
  var octal = this.pos - start2 >= 2 && this.input.charCodeAt(start2) === 48;
  if (octal && this.strict) {
    this.raise(start2, "Invalid number");
  }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start2, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start2, this.pos))) {
    octal = false;
  }
  if (next === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start2, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start2, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code2;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code2 > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code2 = this.readHexChar(4);
  }
  return code2;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position2, message2) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position2, message2);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
        return null;
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n2 = this.readInt(16, len);
  if (n2 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n2;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word2 = "", first2 = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word2 += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first2 ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word2 += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first2 = false;
  }
  return word2 + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word2 = this.readWord1();
  var type2 = types$1.name;
  if (this.keywords.test(word2)) {
    type2 = keywords[word2];
  }
  return this.finishToken(type2, word2);
};
var version = "8.7.1";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse3(input, options2) {
  return Parser.parse(input, options2);
}
function parseExpressionAt2(input, pos, options2) {
  return Parser.parseExpressionAt(input, pos, options2);
}
var regex_whitespace = /\s/;
var regex_starts_with_whitespaces = /^[ \t\r\n]*/;
var regex_ends_with_whitespaces = /[ \t\r\n]*$/;
var regex_not_newline_characters = /[^\n]/g;
var regex_svelte_ignore = /^\s*svelte-ignore\s+([\s\S]+)\s*$/m;
function extract_svelte_ignore(text3) {
  const match = regex_svelte_ignore.exec(text3);
  return match ? match[1].split(regex_whitespace).map((x2) => x2.trim()).filter(Boolean) : [];
}
function fuzzymatch(name2, names2) {
  const set2 = new FuzzySet(names2);
  const matches2 = set2.get(name2);
  return matches2 && matches2[0] && matches2[0][0] > 0.7 ? matches2[0][1] : null;
}
var GRAM_SIZE_LOWER = 2;
var GRAM_SIZE_UPPER = 3;
function _distance(str1, str2) {
  if (str1 === null && str2 === null) {
    throw "Trying to compare two null values";
  }
  if (str1 === null || str2 === null)
    return 0;
  str1 = String(str1);
  str2 = String(str2);
  const distance = levenshtein(str1, str2);
  if (str1.length > str2.length) {
    return 1 - distance / str1.length;
  } else {
    return 1 - distance / str2.length;
  }
}
function levenshtein(str1, str2) {
  const current2 = [];
  let prev;
  let value2;
  for (let i = 0; i <= str2.length; i++) {
    for (let j = 0; j <= str1.length; j++) {
      if (i && j) {
        if (str1.charAt(j - 1) === str2.charAt(i - 1)) {
          value2 = prev;
        } else {
          value2 = Math.min(current2[j], current2[j - 1], prev) + 1;
        }
      } else {
        value2 = i + j;
      }
      prev = current2[j];
      current2[j] = value2;
    }
  }
  return current2.pop();
}
var non_word_regex = /[^\w, ]+/;
function iterate_grams(value2, gram_size = 2) {
  const simplified = "-" + value2.toLowerCase().replace(non_word_regex, "") + "-";
  const len_diff = gram_size - simplified.length;
  const results = [];
  if (len_diff > 0) {
    for (let i = 0; i < len_diff; ++i) {
      value2 += "-";
    }
  }
  for (let i = 0; i < simplified.length - gram_size + 1; ++i) {
    results.push(simplified.slice(i, i + gram_size));
  }
  return results;
}
function gram_counter(value2, gram_size = 2) {
  const result = {};
  const grams = iterate_grams(value2, gram_size);
  let i = 0;
  for (i; i < grams.length; ++i) {
    if (grams[i] in result) {
      result[grams[i]] += 1;
    } else {
      result[grams[i]] = 1;
    }
  }
  return result;
}
function sort_descending(a, b) {
  return b[0] - a[0];
}
var FuzzySet = class {
  constructor(arr) {
    this.exact_set = {};
    this.match_dict = {};
    this.items = {};
    for (let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i) {
      this.items[i] = [];
    }
    for (let i = 0; i < arr.length; ++i) {
      this.add(arr[i]);
    }
  }
  add(value2) {
    const normalized_value = value2.toLowerCase();
    if (normalized_value in this.exact_set) {
      return false;
    }
    let i = GRAM_SIZE_LOWER;
    for (i; i < GRAM_SIZE_UPPER + 1; ++i) {
      this._add(value2, i);
    }
  }
  _add(value2, gram_size) {
    const normalized_value = value2.toLowerCase();
    const items = this.items[gram_size] || [];
    const index2 = items.length;
    items.push(0);
    const gram_counts = gram_counter(normalized_value, gram_size);
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        this.match_dict[gram].push([index2, gram_count]);
      } else {
        this.match_dict[gram] = [[index2, gram_count]];
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    items[index2] = [vector_normal, normalized_value];
    this.items[gram_size] = items;
    this.exact_set[normalized_value] = value2;
  }
  get(value2) {
    const normalized_value = value2.toLowerCase();
    const result = this.exact_set[normalized_value];
    if (result) {
      return [[1, result]];
    }
    let results = [];
    for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) {
      results = this.__get(value2, gram_size);
      if (results) {
        return results;
      }
    }
    return null;
  }
  __get(value2, gram_size) {
    const normalized_value = value2.toLowerCase();
    const matches2 = {};
    const gram_counts = gram_counter(normalized_value, gram_size);
    const items = this.items[gram_size];
    let sum_of_square_gram_counts = 0;
    let gram;
    let gram_count;
    let i;
    let index2;
    let other_gram_count;
    for (gram in gram_counts) {
      gram_count = gram_counts[gram];
      sum_of_square_gram_counts += Math.pow(gram_count, 2);
      if (gram in this.match_dict) {
        for (i = 0; i < this.match_dict[gram].length; ++i) {
          index2 = this.match_dict[gram][i][0];
          other_gram_count = this.match_dict[gram][i][1];
          if (index2 in matches2) {
            matches2[index2] += gram_count * other_gram_count;
          } else {
            matches2[index2] = gram_count * other_gram_count;
          }
        }
      }
    }
    const vector_normal = Math.sqrt(sum_of_square_gram_counts);
    let results = [];
    let match_score;
    for (const match_index in matches2) {
      match_score = matches2[match_index];
      results.push([
        match_score / (vector_normal * items[match_index][0]),
        items[match_index][1]
      ]);
    }
    results.sort(sort_descending);
    let new_results = [];
    const end_index = Math.min(50, results.length);
    for (let i2 = 0; i2 < end_index; ++i2) {
      new_results.push([
        _distance(results[i2][1], normalized_value),
        results[i2][1]
      ]);
    }
    results = new_results;
    results.sort(sort_descending);
    new_results = [];
    for (let i2 = 0; i2 < results.length; ++i2) {
      if (results[i2][0] == results[0][0]) {
        new_results.push([results[i2][0], this.exact_set[results[i2][1]]]);
      }
    }
    return new_results;
  }
};
var void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
function is_void(name2) {
  return void_element_names.test(name2) || name2.toLowerCase() === "!doctype";
}
function list$1(items, conjunction = "or") {
  if (items.length === 1)
    return items[0];
  return `${items.slice(0, -1).join(", ")} ${conjunction} ${items[items.length - 1]}`;
}
var parser_errors = {
  css_syntax_error: (message2) => ({
    code: "css-syntax-error",
    message: message2
  }),
  duplicate_attribute: {
    code: "duplicate-attribute",
    message: "Attributes need to be unique"
  },
  duplicate_element: (slug, name2) => ({
    code: `duplicate-${slug}`,
    message: `A component can only have one <${name2}> tag`
  }),
  duplicate_style: {
    code: "duplicate-style",
    message: "You can only have one top-level <style> tag per component"
  },
  empty_attribute_shorthand: {
    code: "empty-attribute-shorthand",
    message: "Attribute shorthand cannot be empty"
  },
  empty_directive_name: (type2) => ({
    code: "empty-directive-name",
    message: `${type2} name cannot be empty`
  }),
  empty_global_selector: {
    code: "css-syntax-error",
    message: ":global() must contain a selector"
  },
  expected_block_type: {
    code: "expected-block-type",
    message: "Expected if, each or await"
  },
  expected_name: {
    code: "expected-name",
    message: "Expected name"
  },
  invalid_catch_placement_unclosed_block: (block2) => ({
    code: "invalid-catch-placement",
    message: `Expected to close ${block2} before seeing {:catch} block`
  }),
  invalid_catch_placement_without_await: {
    code: "invalid-catch-placement",
    message: "Cannot have an {:catch} block outside an {#await ...} block"
  },
  invalid_component_definition: {
    code: "invalid-component-definition",
    message: "invalid component definition"
  },
  invalid_closing_tag_unopened: (name2) => ({
    code: "invalid-closing-tag",
    message: `</${name2}> attempted to close an element that was not open`
  }),
  invalid_closing_tag_autoclosed: (name2, reason) => ({
    code: "invalid-closing-tag",
    message: `</${name2}> attempted to close <${name2}> that was already automatically closed by <${reason}>`
  }),
  invalid_debug_args: {
    code: "invalid-debug-args",
    message: "{@debug ...} arguments must be identifiers, not arbitrary expressions"
  },
  invalid_declaration: {
    code: "invalid-declaration",
    message: "Declaration cannot be empty"
  },
  invalid_directive_value: {
    code: "invalid-directive-value",
    message: "Directive value must be a JavaScript expression enclosed in curly braces"
  },
  invalid_elseif: {
    code: "invalid-elseif",
    message: "'elseif' should be 'else if'"
  },
  invalid_elseif_placement_outside_if: {
    code: "invalid-elseif-placement",
    message: "Cannot have an {:else if ...} block outside an {#if ...} block"
  },
  invalid_elseif_placement_unclosed_block: (block2) => ({
    code: "invalid-elseif-placement",
    message: `Expected to close ${block2} before seeing {:else if ...} block`
  }),
  invalid_else_placement_outside_if: {
    code: "invalid-else-placement",
    message: "Cannot have an {:else} block outside an {#if ...} or {#each ...} block"
  },
  invalid_else_placement_unclosed_block: (block2) => ({
    code: "invalid-else-placement",
    message: `Expected to close ${block2} before seeing {:else} block`
  }),
  invalid_element_content: (slug, name2) => ({
    code: `invalid-${slug}-content`,
    message: `<${name2}> cannot have children`
  }),
  invalid_element_definition: {
    code: "invalid-element-definition",
    message: "Invalid element definition"
  },
  invalid_element_placement: (slug, name2) => ({
    code: `invalid-${slug}-placement`,
    message: `<${name2}> tags cannot be inside elements or blocks`
  }),
  invalid_logic_block_placement: (location, name2) => ({
    code: "invalid-logic-block-placement",
    message: `{#${name2}} logic block cannot be ${location}`
  }),
  invalid_tag_placement: (location, name2) => ({
    code: "invalid-tag-placement",
    message: `{@${name2}} tag cannot be ${location}`
  }),
  invalid_ref_directive: (name2) => ({
    code: "invalid-ref-directive",
    message: `The ref directive is no longer supported \u2014 use \`bind:this={${name2}}\` instead`
  }),
  invalid_ref_selector: {
    code: "invalid-ref-selector",
    message: "ref selectors are no longer supported"
  },
  invalid_self_placement: {
    code: "invalid-self-placement",
    message: "<svelte:self> components can only exist inside {#if} blocks, {#each} blocks, or slots passed to components"
  },
  invalid_script_instance: {
    code: "invalid-script",
    message: "A component can only have one instance-level <script> element"
  },
  invalid_script_module: {
    code: "invalid-script",
    message: 'A component can only have one <script context="module"> element'
  },
  invalid_script_context_attribute: {
    code: "invalid-script",
    message: "context attribute must be static"
  },
  invalid_script_context_value: {
    code: "invalid-script",
    message: 'If the context attribute is supplied, its value must be "module"'
  },
  invalid_tag_name: {
    code: "invalid-tag-name",
    message: "Expected valid tag name"
  },
  invalid_tag_name_svelte_element: (tags, match) => ({
    code: "invalid-tag-name",
    message: `Valid <svelte:...> tag names are ${list$1(tags)}${match ? " (did you mean " + match + "?)" : ""}`
  }),
  invalid_then_placement_unclosed_block: (block2) => ({
    code: "invalid-then-placement",
    message: `Expected to close ${block2} before seeing {:then} block`
  }),
  invalid_then_placement_without_await: {
    code: "invalid-then-placement",
    message: "Cannot have an {:then} block outside an {#await ...} block"
  },
  invalid_void_content: (name2) => ({
    code: "invalid-void-content",
    message: `<${name2}> is a void element and cannot have children, or a closing tag`
  }),
  missing_component_definition: {
    code: "missing-component-definition",
    message: "<svelte:component> must have a 'this' attribute"
  },
  missing_attribute_value: {
    code: "missing-attribute-value",
    message: "Expected value for the attribute"
  },
  missing_element_definition: {
    code: "missing-element-definition",
    message: "<svelte:element> must have a 'this' attribute"
  },
  unclosed_script: {
    code: "unclosed-script",
    message: "<script> must have a closing tag"
  },
  unclosed_style: {
    code: "unclosed-style",
    message: "<style> must have a closing tag"
  },
  unclosed_comment: {
    code: "unclosed-comment",
    message: "comment was left open, expected -->"
  },
  unclosed_attribute_value: (token) => ({
    code: "unclosed-attribute-value",
    message: `Expected to close the attribute value with ${token}`
  }),
  unexpected_block_close: {
    code: "unexpected-block-close",
    message: "Unexpected block closing tag"
  },
  unexpected_eof: {
    code: "unexpected-eof",
    message: "Unexpected end of input"
  },
  unexpected_eof_token: (token) => ({
    code: "unexpected-eof",
    message: `Unexpected ${token}`
  }),
  unexpected_token: (token) => ({
    code: "unexpected-token",
    message: `Expected ${token}`
  }),
  unexpected_token_destructure: {
    code: "unexpected-token",
    message: "Expected identifier or destructure pattern"
  }
};
var WalkerBase = class {
  constructor() {
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node2) => this.replacement = node2
    };
  }
  replace(parent, prop2, index2, node2) {
    if (parent) {
      if (index2 !== null) {
        parent[prop2][index2] = node2;
      } else {
        parent[prop2] = node2;
      }
    }
  }
  remove(parent, prop2, index2) {
    if (parent) {
      if (index2 !== null) {
        parent[prop2].splice(index2, 1);
      } else {
        delete parent[prop2];
      }
    }
  }
};
var SyncWalker = class extends WalkerBase {
  constructor(enter, leave) {
    super();
    this.enter = enter;
    this.leave = leave;
  }
  visit(node2, parent, prop2, index2) {
    if (node2) {
      if (this.enter) {
        const _should_skip = this.should_skip;
        const _should_remove = this.should_remove;
        const _replacement = this.replacement;
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        this.enter.call(this.context, node2, parent, prop2, index2);
        if (this.replacement) {
          node2 = this.replacement;
          this.replace(parent, prop2, index2, node2);
        }
        if (this.should_remove) {
          this.remove(parent, prop2, index2);
        }
        const skipped = this.should_skip;
        const removed = this.should_remove;
        this.should_skip = _should_skip;
        this.should_remove = _should_remove;
        this.replacement = _replacement;
        if (skipped)
          return node2;
        if (removed)
          return null;
      }
      for (const key in node2) {
        const value2 = node2[key];
        if (typeof value2 !== "object") {
          continue;
        } else if (Array.isArray(value2)) {
          for (let i = 0; i < value2.length; i += 1) {
            if (value2[i] !== null && typeof value2[i].type === "string") {
              if (!this.visit(value2[i], node2, key, i)) {
                i--;
              }
            }
          }
        } else if (value2 !== null && typeof value2.type === "string") {
          this.visit(value2, node2, key, null);
        }
      }
      if (this.leave) {
        const _replacement = this.replacement;
        const _should_remove = this.should_remove;
        this.replacement = null;
        this.should_remove = false;
        this.leave.call(this.context, node2, parent, prop2, index2);
        if (this.replacement) {
          node2 = this.replacement;
          this.replace(parent, prop2, index2, node2);
        }
        if (this.should_remove) {
          this.remove(parent, prop2, index2);
        }
        const removed = this.should_remove;
        this.replacement = _replacement;
        this.should_remove = _should_remove;
        if (removed)
          return null;
      }
    }
    return node2;
  }
};
function walk(ast2, { enter, leave }) {
  const instance = new SyncWalker(enter, leave);
  return instance.visit(ast2, null);
}
var id = Math.round(Math.random() * 1e20).toString(36);
var re = new RegExp(`_${id}_(?:(\\d+)|(AT)|(HASH))_(\\w+)?`, "g");
var get_comment_handlers = (comments, raw2) => ({
  onComment: (block2, value2, start2, end2) => {
    if (block2 && /\n/.test(value2)) {
      let a = start2;
      while (a > 0 && raw2[a - 1] !== "\n")
        a -= 1;
      let b = a;
      while (/[ \t]/.test(raw2[b]))
        b += 1;
      const indentation2 = raw2.slice(a, b);
      value2 = value2.replace(new RegExp(`^${indentation2}`, "gm"), "");
    }
    comments.push({ type: block2 ? "Block" : "Line", value: value2, start: start2, end: end2 });
  },
  enter(node2) {
    let comment2;
    while (comments[0] && comments[0].start < node2.start) {
      comment2 = comments.shift();
      comment2.value = comment2.value.replace(re, (match, id2, at2, hash, value2) => {
        if (hash)
          return `#${value2}`;
        if (at2)
          return `@${value2}`;
        return match;
      });
      const next = comments[0] || node2;
      comment2.has_trailing_newline = comment2.type === "Line" || /\n/.test(raw2.slice(comment2.end, next.start));
      (node2.leadingComments || (node2.leadingComments = [])).push(comment2);
    }
  },
  leave(node2) {
    if (comments[0]) {
      const slice3 = raw2.slice(node2.end, comments[0].start);
      if (/^[,) \t]*$/.test(slice3)) {
        node2.trailingComments = [comments.shift()];
      }
    }
  }
});
function push_array(array, items) {
  for (let i = 0; i < items.length; i++) {
    array.push(items[i]);
  }
}
function handle(node2, state) {
  const handler = handlers[node2.type];
  if (!handler) {
    throw new Error(`Not implemented ${node2.type}`);
  }
  const result = handler(node2, state);
  if (node2.leadingComments) {
    result.unshift(c(node2.leadingComments.map((comment2) => comment2.type === "Block" ? `/*${comment2.value}*/${comment2.has_trailing_newline ? `
${state.indent}` : ` `}` : `//${comment2.value}${comment2.has_trailing_newline ? `
${state.indent}` : ` `}`).join(``)));
  }
  if (node2.trailingComments) {
    state.comments.push(node2.trailingComments[0]);
  }
  return result;
}
function c(content, node2) {
  return {
    content,
    loc: node2 && node2.loc,
    has_newline: /\n/.test(content)
  };
}
var OPERATOR_PRECEDENCE = {
  "||": 2,
  "&&": 3,
  "??": 4,
  "|": 5,
  "^": 6,
  "&": 7,
  "==": 8,
  "!=": 8,
  "===": 8,
  "!==": 8,
  "<": 9,
  ">": 9,
  "<=": 9,
  ">=": 9,
  in: 9,
  instanceof: 9,
  "<<": 10,
  ">>": 10,
  ">>>": 10,
  "+": 11,
  "-": 11,
  "*": 12,
  "%": 12,
  "/": 12,
  "**": 13
};
var EXPRESSIONS_PRECEDENCE = {
  ArrayExpression: 20,
  TaggedTemplateExpression: 20,
  ThisExpression: 20,
  Identifier: 20,
  Literal: 18,
  TemplateLiteral: 20,
  Super: 20,
  SequenceExpression: 20,
  MemberExpression: 19,
  CallExpression: 19,
  NewExpression: 19,
  AwaitExpression: 17,
  ClassExpression: 17,
  FunctionExpression: 17,
  ObjectExpression: 17,
  UpdateExpression: 16,
  UnaryExpression: 15,
  BinaryExpression: 14,
  LogicalExpression: 13,
  ConditionalExpression: 4,
  ArrowFunctionExpression: 3,
  AssignmentExpression: 3,
  YieldExpression: 2,
  RestElement: 1
};
function needs_parens(node2, parent, is_right) {
  if (node2.type === "LogicalExpression" && parent.type === "LogicalExpression" && (parent.operator === "??" && node2.operator !== "??" || parent.operator !== "??" && node2.operator === "??")) {
    return true;
  }
  const precedence = EXPRESSIONS_PRECEDENCE[node2.type];
  const parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];
  if (precedence !== parent_precedence) {
    return !is_right && precedence === 15 && parent_precedence === 14 && parent.operator === "**" || precedence < parent_precedence;
  }
  if (precedence !== 13 && precedence !== 14) {
    return false;
  }
  if (node2.operator === "**" && parent.operator === "**") {
    return !is_right;
  }
  if (is_right) {
    return OPERATOR_PRECEDENCE[node2.operator] <= OPERATOR_PRECEDENCE[parent.operator];
  }
  return OPERATOR_PRECEDENCE[node2.operator] < OPERATOR_PRECEDENCE[parent.operator];
}
function has_call_expression(node2) {
  while (node2) {
    if (node2.type[0] === "CallExpression") {
      return true;
    } else if (node2.type === "MemberExpression") {
      node2 = node2.object;
    } else {
      return false;
    }
  }
}
var has_newline = (chunks) => {
  for (let i = 0; i < chunks.length; i += 1) {
    if (chunks[i].has_newline)
      return true;
  }
  return false;
};
var get_length = (chunks) => {
  let total = 0;
  for (let i = 0; i < chunks.length; i += 1) {
    total += chunks[i].content.length;
  }
  return total;
};
var sum = (a, b) => a + b;
var join = (nodes, separator) => {
  if (nodes.length === 0)
    return [];
  const joined = [...nodes[0]];
  for (let i = 1; i < nodes.length; i += 1) {
    joined.push(separator);
    push_array(joined, nodes[i]);
  }
  return joined;
};
var scoped = (fn) => {
  const scoped_fn = (node2, state) => {
    return fn(node2, {
      ...state,
      scope: state.scope_map.get(node2)
    });
  };
  return scoped_fn;
};
var deconflict = (name2, names2) => {
  const original = name2;
  let i = 1;
  while (names2.has(name2)) {
    name2 = `${original}$${i++}`;
  }
  return name2;
};
var handle_body = (nodes, state) => {
  const chunks = [];
  const body2 = nodes.map((statement) => {
    const chunks2 = handle(statement, {
      ...state,
      indent: state.indent
    });
    let add_newline = false;
    while (state.comments.length) {
      const comment2 = state.comments.shift();
      const prefix = add_newline ? `
${state.indent}` : ` `;
      chunks2.push(c(comment2.type === "Block" ? `${prefix}/*${comment2.value}*/` : `${prefix}//${comment2.value}`));
      add_newline = comment2.type === "Line";
    }
    return chunks2;
  });
  let needed_padding = false;
  for (let i = 0; i < body2.length; i += 1) {
    const needs_padding = has_newline(body2[i]);
    if (i > 0) {
      chunks.push(
        c(needs_padding || needed_padding ? `

${state.indent}` : `
${state.indent}`)
      );
    }
    push_array(chunks, body2[i]);
    needed_padding = needs_padding;
  }
  return chunks;
};
var handle_var_declaration = (node2, state) => {
  const chunks = [c(`${node2.kind} `)];
  const declarators = node2.declarations.map((d) => handle(d, {
    ...state,
    indent: state.indent + (node2.declarations.length === 1 ? "" : "	")
  }));
  const multiple_lines = declarators.some(has_newline) || declarators.map(get_length).reduce(sum, 0) + (state.indent.length + declarators.length - 1) * 2 > 80;
  const separator = c(multiple_lines ? `,
${state.indent}	` : ", ");
  push_array(chunks, join(declarators, separator));
  return chunks;
};
var handlers = {
  Program(node2, state) {
    return handle_body(node2.body, state);
  },
  BlockStatement: scoped((node2, state) => {
    return [
      c(`{
${state.indent}	`),
      ...handle_body(node2.body, { ...state, indent: state.indent + "	" }),
      c(`
${state.indent}}`)
    ];
  }),
  EmptyStatement(node2, state) {
    return [c(";")];
  },
  ParenthesizedExpression(node2, state) {
    return handle(node2.expression, state);
  },
  ExpressionStatement(node2, state) {
    if (node2.expression.type === "AssignmentExpression" && node2.expression.left.type === "ObjectPattern") {
      return [
        c("("),
        ...handle(node2.expression, state),
        c(");")
      ];
    }
    return [
      ...handle(node2.expression, state),
      c(";")
    ];
  },
  IfStatement(node2, state) {
    const chunks = [
      c("if ("),
      ...handle(node2.test, state),
      c(") "),
      ...handle(node2.consequent, state)
    ];
    if (node2.alternate) {
      chunks.push(c(" else "));
      push_array(chunks, handle(node2.alternate, state));
    }
    return chunks;
  },
  LabeledStatement(node2, state) {
    return [
      ...handle(node2.label, state),
      c(": "),
      ...handle(node2.body, state)
    ];
  },
  BreakStatement(node2, state) {
    return node2.label ? [c("break "), ...handle(node2.label, state), c(";")] : [c("break;")];
  },
  ContinueStatement(node2, state) {
    return node2.label ? [c("continue "), ...handle(node2.label, state), c(";")] : [c("continue;")];
  },
  WithStatement(node2, state) {
    return [
      c("with ("),
      ...handle(node2.object, state),
      c(") "),
      ...handle(node2.body, state)
    ];
  },
  SwitchStatement(node2, state) {
    const chunks = [
      c("switch ("),
      ...handle(node2.discriminant, state),
      c(") {")
    ];
    node2.cases.forEach((block2) => {
      if (block2.test) {
        chunks.push(c(`
${state.indent}	case `));
        push_array(chunks, handle(block2.test, { ...state, indent: `${state.indent}	` }));
        chunks.push(c(":"));
      } else {
        chunks.push(c(`
${state.indent}	default:`));
      }
      block2.consequent.forEach((statement) => {
        chunks.push(c(`
${state.indent}		`));
        push_array(chunks, handle(statement, { ...state, indent: `${state.indent}		` }));
      });
    });
    chunks.push(c(`
${state.indent}}`));
    return chunks;
  },
  ReturnStatement(node2, state) {
    if (node2.argument) {
      const contains_comment = node2.argument.leadingComments && node2.argument.leadingComments.some((comment2) => comment2.has_trailing_newline);
      return [
        c(contains_comment ? "return (" : "return "),
        ...handle(node2.argument, state),
        c(contains_comment ? ");" : ";")
      ];
    } else {
      return [c("return;")];
    }
  },
  ThrowStatement(node2, state) {
    return [
      c("throw "),
      ...handle(node2.argument, state),
      c(";")
    ];
  },
  TryStatement(node2, state) {
    const chunks = [
      c("try "),
      ...handle(node2.block, state)
    ];
    if (node2.handler) {
      if (node2.handler.param) {
        chunks.push(c(" catch("));
        push_array(chunks, handle(node2.handler.param, state));
        chunks.push(c(") "));
      } else {
        chunks.push(c(" catch "));
      }
      push_array(chunks, handle(node2.handler.body, state));
    }
    if (node2.finalizer) {
      chunks.push(c(" finally "));
      push_array(chunks, handle(node2.finalizer, state));
    }
    return chunks;
  },
  WhileStatement(node2, state) {
    return [
      c("while ("),
      ...handle(node2.test, state),
      c(") "),
      ...handle(node2.body, state)
    ];
  },
  DoWhileStatement(node2, state) {
    return [
      c("do "),
      ...handle(node2.body, state),
      c(" while ("),
      ...handle(node2.test, state),
      c(");")
    ];
  },
  ForStatement: scoped((node2, state) => {
    const chunks = [c("for (")];
    if (node2.init) {
      if (node2.init.type === "VariableDeclaration") {
        push_array(chunks, handle_var_declaration(node2.init, state));
      } else {
        push_array(chunks, handle(node2.init, state));
      }
    }
    chunks.push(c("; "));
    if (node2.test)
      push_array(chunks, handle(node2.test, state));
    chunks.push(c("; "));
    if (node2.update)
      push_array(chunks, handle(node2.update, state));
    chunks.push(c(") "));
    push_array(chunks, handle(node2.body, state));
    return chunks;
  }),
  ForInStatement: scoped((node2, state) => {
    const chunks = [
      c(`for ${node2.await ? "await " : ""}(`)
    ];
    if (node2.left.type === "VariableDeclaration") {
      push_array(chunks, handle_var_declaration(node2.left, state));
    } else {
      push_array(chunks, handle(node2.left, state));
    }
    chunks.push(c(node2.type === "ForInStatement" ? ` in ` : ` of `));
    push_array(chunks, handle(node2.right, state));
    chunks.push(c(") "));
    push_array(chunks, handle(node2.body, state));
    return chunks;
  }),
  DebuggerStatement(node2, state) {
    return [c("debugger", node2), c(";")];
  },
  FunctionDeclaration: scoped((node2, state) => {
    const chunks = [];
    if (node2.async)
      chunks.push(c("async "));
    chunks.push(c(node2.generator ? "function* " : "function "));
    if (node2.id)
      push_array(chunks, handle(node2.id, state));
    chunks.push(c("("));
    const params = node2.params.map((p2) => handle(p2, {
      ...state,
      indent: state.indent + "	"
    }));
    const multiple_lines = params.some(has_newline) || params.map(get_length).reduce(sum, 0) + (state.indent.length + params.length - 1) * 2 > 80;
    const separator = c(multiple_lines ? `,
${state.indent}` : ", ");
    if (multiple_lines) {
      chunks.push(c(`
${state.indent}	`));
      push_array(chunks, join(params, separator));
      chunks.push(c(`
${state.indent}`));
    } else {
      push_array(chunks, join(params, separator));
    }
    chunks.push(c(") "));
    push_array(chunks, handle(node2.body, state));
    return chunks;
  }),
  VariableDeclaration(node2, state) {
    return handle_var_declaration(node2, state).concat(c(";"));
  },
  VariableDeclarator(node2, state) {
    if (node2.init) {
      return [
        ...handle(node2.id, state),
        c(" = "),
        ...handle(node2.init, state)
      ];
    } else {
      return handle(node2.id, state);
    }
  },
  ClassDeclaration(node2, state) {
    const chunks = [c("class ")];
    if (node2.id) {
      push_array(chunks, handle(node2.id, state));
      chunks.push(c(" "));
    }
    if (node2.superClass) {
      chunks.push(c("extends "));
      push_array(chunks, handle(node2.superClass, state));
      chunks.push(c(" "));
    }
    push_array(chunks, handle(node2.body, state));
    return chunks;
  },
  ImportDeclaration(node2, state) {
    const chunks = [c("import ")];
    const { length: length2 } = node2.specifiers;
    const source = handle(node2.source, state);
    if (length2 > 0) {
      let i = 0;
      while (i < length2) {
        if (i > 0) {
          chunks.push(c(", "));
        }
        const specifier = node2.specifiers[i];
        if (specifier.type === "ImportDefaultSpecifier") {
          chunks.push(c(specifier.local.name, specifier));
          i += 1;
        } else if (specifier.type === "ImportNamespaceSpecifier") {
          chunks.push(c("* as " + specifier.local.name, specifier));
          i += 1;
        } else {
          break;
        }
      }
      if (i < length2) {
        const specifiers = node2.specifiers.slice(i).map((specifier) => {
          const name2 = handle(specifier.imported, state)[0];
          const as = handle(specifier.local, state)[0];
          if (name2.content === as.content) {
            return [as];
          }
          return [name2, c(" as "), as];
        });
        const width = get_length(chunks) + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length + 6 + get_length(source);
        if (width > 80) {
          chunks.push(c(`{
	`));
          push_array(chunks, join(specifiers, c(",\n	")));
          chunks.push(c("\n}"));
        } else {
          chunks.push(c(`{ `));
          push_array(chunks, join(specifiers, c(", ")));
          chunks.push(c(" }"));
        }
      }
      chunks.push(c(" from "));
    }
    push_array(chunks, source);
    chunks.push(c(";"));
    return chunks;
  },
  ImportExpression(node2, state) {
    return [c("import("), ...handle(node2.source, state), c(")")];
  },
  ExportDefaultDeclaration(node2, state) {
    const chunks = [
      c(`export default `),
      ...handle(node2.declaration, state)
    ];
    if (node2.declaration.type !== "FunctionDeclaration") {
      chunks.push(c(";"));
    }
    return chunks;
  },
  ExportNamedDeclaration(node2, state) {
    const chunks = [c("export ")];
    if (node2.declaration) {
      push_array(chunks, handle(node2.declaration, state));
    } else {
      const specifiers = node2.specifiers.map((specifier) => {
        const name2 = handle(specifier.local, state)[0];
        const as = handle(specifier.exported, state)[0];
        if (name2.content === as.content) {
          return [name2];
        }
        return [name2, c(" as "), as];
      });
      const width = 7 + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length;
      if (width > 80) {
        chunks.push(c("{\n	"));
        push_array(chunks, join(specifiers, c(",\n	")));
        chunks.push(c("\n}"));
      } else {
        chunks.push(c("{ "));
        push_array(chunks, join(specifiers, c(", ")));
        chunks.push(c(" }"));
      }
      if (node2.source) {
        chunks.push(c(" from "));
        push_array(chunks, handle(node2.source, state));
      }
    }
    chunks.push(c(";"));
    return chunks;
  },
  ExportAllDeclaration(node2, state) {
    return [
      c(`export * from `),
      ...handle(node2.source, state),
      c(`;`)
    ];
  },
  MethodDefinition(node2, state) {
    const chunks = [];
    if (node2.static) {
      chunks.push(c("static "));
    }
    if (node2.kind === "get" || node2.kind === "set") {
      chunks.push(c(node2.kind + " "));
    }
    if (node2.value.async) {
      chunks.push(c("async "));
    }
    if (node2.value.generator) {
      chunks.push(c("*"));
    }
    if (node2.computed) {
      chunks.push(c("["));
      push_array(chunks, handle(node2.key, state));
      chunks.push(c("]"));
    } else {
      push_array(chunks, handle(node2.key, state));
    }
    chunks.push(c("("));
    const { params } = node2.value;
    for (let i = 0; i < params.length; i += 1) {
      push_array(chunks, handle(params[i], state));
      if (i < params.length - 1)
        chunks.push(c(", "));
    }
    chunks.push(c(") "));
    push_array(chunks, handle(node2.value.body, state));
    return chunks;
  },
  ArrowFunctionExpression: scoped((node2, state) => {
    const chunks = [];
    if (node2.async)
      chunks.push(c("async "));
    if (node2.params.length === 1 && node2.params[0].type === "Identifier") {
      push_array(chunks, handle(node2.params[0], state));
    } else {
      const params = node2.params.map((param) => handle(param, {
        ...state,
        indent: state.indent + "	"
      }));
      chunks.push(c("("));
      push_array(chunks, join(params, c(", ")));
      chunks.push(c(")"));
    }
    chunks.push(c(" => "));
    if (node2.body.type === "ObjectExpression" || node2.body.type === "AssignmentExpression" && node2.body.left.type === "ObjectPattern") {
      chunks.push(c("("));
      push_array(chunks, handle(node2.body, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node2.body, state));
    }
    return chunks;
  }),
  ThisExpression(node2, state) {
    return [c("this", node2)];
  },
  Super(node2, state) {
    return [c("super", node2)];
  },
  RestElement(node2, state) {
    return [c("..."), ...handle(node2.argument, state)];
  },
  YieldExpression(node2, state) {
    if (node2.argument) {
      return [c(node2.delegate ? `yield* ` : `yield `), ...handle(node2.argument, state)];
    }
    return [c(node2.delegate ? `yield*` : `yield`)];
  },
  AwaitExpression(node2, state) {
    if (node2.argument) {
      const precedence = EXPRESSIONS_PRECEDENCE[node2.argument.type];
      if (precedence && precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression) {
        return [c("await ("), ...handle(node2.argument, state), c(")")];
      } else {
        return [c("await "), ...handle(node2.argument, state)];
      }
    }
    return [c("await")];
  },
  TemplateLiteral(node2, state) {
    const chunks = [c("`")];
    const { quasis, expressions: expressions2 } = node2;
    for (let i = 0; i < expressions2.length; i++) {
      chunks.push(
        c(quasis[i].value.raw),
        c("${")
      );
      push_array(chunks, handle(expressions2[i], state));
      chunks.push(c("}"));
    }
    chunks.push(
      c(quasis[quasis.length - 1].value.raw),
      c("`")
    );
    return chunks;
  },
  TaggedTemplateExpression(node2, state) {
    return handle(node2.tag, state).concat(handle(node2.quasi, state));
  },
  ArrayExpression(node2, state) {
    const chunks = [c("[")];
    const elements = [];
    let sparse_commas = [];
    for (let i = 0; i < node2.elements.length; i += 1) {
      const element2 = node2.elements[i];
      if (element2) {
        elements.push([...sparse_commas, ...handle(element2, {
          ...state,
          indent: state.indent + "	"
        })]);
        sparse_commas = [];
      } else {
        sparse_commas.push(c(","));
      }
    }
    const multiple_lines = elements.some(has_newline) || elements.map(get_length).reduce(sum, 0) + (state.indent.length + elements.length - 1) * 2 > 80;
    if (multiple_lines) {
      chunks.push(c(`
${state.indent}	`));
      push_array(chunks, join(elements, c(`,
${state.indent}	`)));
      chunks.push(c(`
${state.indent}`));
      push_array(chunks, sparse_commas);
    } else {
      push_array(chunks, join(elements, c(", ")));
      push_array(chunks, sparse_commas);
    }
    chunks.push(c("]"));
    return chunks;
  },
  ObjectExpression(node2, state) {
    if (node2.properties.length === 0) {
      return [c("{}")];
    }
    let has_inline_comment = false;
    const chunks = [];
    const separator = c(", ");
    node2.properties.forEach((p2, i) => {
      push_array(chunks, handle(p2, {
        ...state,
        indent: state.indent + "	"
      }));
      if (state.comments.length) {
        chunks.push(c(", "));
        while (state.comments.length) {
          const comment2 = state.comments.shift();
          chunks.push(c(comment2.type === "Block" ? `/*${comment2.value}*/
${state.indent}	` : `//${comment2.value}
${state.indent}	`));
          if (comment2.type === "Line") {
            has_inline_comment = true;
          }
        }
      } else {
        if (i < node2.properties.length - 1) {
          chunks.push(separator);
        }
      }
    });
    const multiple_lines = has_inline_comment || has_newline(chunks) || get_length(chunks) > 40;
    if (multiple_lines) {
      separator.content = `,
${state.indent}	`;
    }
    return [
      c(multiple_lines ? `{
${state.indent}	` : `{ `),
      ...chunks,
      c(multiple_lines ? `
${state.indent}}` : ` }`)
    ];
  },
  Property(node2, state) {
    const value2 = handle(node2.value, state);
    if (node2.key === node2.value) {
      return value2;
    }
    if (!node2.computed && node2.value.type === "AssignmentPattern" && node2.value.left.type === "Identifier" && node2.value.left.name === node2.key.name) {
      return value2;
    }
    if (!node2.computed && node2.value.type === "Identifier" && (node2.key.type === "Identifier" && node2.key.name === value2[0].content || node2.key.type === "Literal" && node2.key.value === value2[0].content)) {
      return value2;
    }
    const key = handle(node2.key, state);
    if (node2.value.type === "FunctionExpression" && !node2.value.id) {
      state = {
        ...state,
        scope: state.scope_map.get(node2.value)
      };
      const chunks = node2.kind !== "init" ? [c(`${node2.kind} `)] : [];
      if (node2.value.async) {
        chunks.push(c("async "));
      }
      if (node2.value.generator) {
        chunks.push(c("*"));
      }
      push_array(chunks, node2.computed ? [c("["), ...key, c("]")] : key);
      chunks.push(c("("));
      push_array(chunks, join(node2.value.params.map((param) => handle(param, state)), c(", ")));
      chunks.push(c(") "));
      push_array(chunks, handle(node2.value.body, state));
      return chunks;
    }
    if (node2.computed) {
      return [
        c("["),
        ...key,
        c("]: "),
        ...value2
      ];
    }
    return [
      ...key,
      c(": "),
      ...value2
    ];
  },
  ObjectPattern(node2, state) {
    const chunks = [c("{ ")];
    for (let i = 0; i < node2.properties.length; i += 1) {
      push_array(chunks, handle(node2.properties[i], state));
      if (i < node2.properties.length - 1)
        chunks.push(c(", "));
    }
    chunks.push(c(" }"));
    return chunks;
  },
  SequenceExpression(node2, state) {
    const expressions2 = node2.expressions.map((e) => handle(e, state));
    return [
      c("("),
      ...join(expressions2, c(", ")),
      c(")")
    ];
  },
  UnaryExpression(node2, state) {
    const chunks = [c(node2.operator)];
    if (node2.operator.length > 1) {
      chunks.push(c(" "));
    }
    if (EXPRESSIONS_PRECEDENCE[node2.argument.type] < EXPRESSIONS_PRECEDENCE.UnaryExpression) {
      chunks.push(c("("));
      push_array(chunks, handle(node2.argument, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node2.argument, state));
    }
    return chunks;
  },
  UpdateExpression(node2, state) {
    return node2.prefix ? [c(node2.operator), ...handle(node2.argument, state)] : [...handle(node2.argument, state), c(node2.operator)];
  },
  AssignmentExpression(node2, state) {
    return [
      ...handle(node2.left, state),
      c(` ${node2.operator || "="} `),
      ...handle(node2.right, state)
    ];
  },
  BinaryExpression(node2, state) {
    const chunks = [];
    if (needs_parens(node2.left, node2, false)) {
      chunks.push(c("("));
      push_array(chunks, handle(node2.left, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node2.left, state));
    }
    chunks.push(c(` ${node2.operator} `));
    if (needs_parens(node2.right, node2, true)) {
      chunks.push(c("("));
      push_array(chunks, handle(node2.right, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node2.right, state));
    }
    return chunks;
  },
  ConditionalExpression(node2, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node2.test.type] > EXPRESSIONS_PRECEDENCE.ConditionalExpression) {
      push_array(chunks, handle(node2.test, state));
    } else {
      chunks.push(c("("));
      push_array(chunks, handle(node2.test, state));
      chunks.push(c(")"));
    }
    const child_state = { ...state, indent: state.indent + "	" };
    const consequent = handle(node2.consequent, child_state);
    const alternate = handle(node2.alternate, child_state);
    const multiple_lines = has_newline(consequent) || has_newline(alternate) || get_length(chunks) + get_length(consequent) + get_length(alternate) > 50;
    if (multiple_lines) {
      chunks.push(c(`
${state.indent}? `));
      push_array(chunks, consequent);
      chunks.push(c(`
${state.indent}: `));
      push_array(chunks, alternate);
    } else {
      chunks.push(c(` ? `));
      push_array(chunks, consequent);
      chunks.push(c(` : `));
      push_array(chunks, alternate);
    }
    return chunks;
  },
  NewExpression(node2, state) {
    const chunks = [c("new ")];
    if (EXPRESSIONS_PRECEDENCE[node2.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression || has_call_expression(node2.callee)) {
      chunks.push(c("("));
      push_array(chunks, handle(node2.callee, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node2.callee, state));
    }
    const args = node2.arguments.map((arg) => handle(arg, {
      ...state,
      indent: state.indent + "	"
    }));
    const separator = args.some(has_newline) ? c(",\n" + state.indent) : c(", ");
    chunks.push(c("("));
    push_array(chunks, join(args, separator));
    chunks.push(c(")"));
    return chunks;
  },
  ChainExpression(node2, state) {
    return handle(node2.expression, state);
  },
  CallExpression(node2, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node2.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression) {
      chunks.push(c("("));
      push_array(chunks, handle(node2.callee, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node2.callee, state));
    }
    if (node2.optional) {
      chunks.push(c("?."));
    }
    const args = node2.arguments.map((arg) => handle(arg, state));
    const multiple_lines = args.slice(0, -1).some(has_newline);
    if (multiple_lines) {
      const args2 = node2.arguments.map((arg) => handle(arg, {
        ...state,
        indent: `${state.indent}	`
      }));
      chunks.push(c(`(
${state.indent}	`));
      push_array(chunks, join(args2, c(`,
${state.indent}	`)));
      chunks.push(c(`
${state.indent})`));
    } else {
      chunks.push(c("("));
      push_array(chunks, join(args, c(", ")));
      chunks.push(c(")"));
    }
    return chunks;
  },
  MemberExpression(node2, state) {
    const chunks = [];
    if (EXPRESSIONS_PRECEDENCE[node2.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {
      chunks.push(c("("));
      push_array(chunks, handle(node2.object, state));
      chunks.push(c(")"));
    } else {
      push_array(chunks, handle(node2.object, state));
    }
    if (node2.computed) {
      if (node2.optional) {
        chunks.push(c("?."));
      }
      chunks.push(c("["));
      push_array(chunks, handle(node2.property, state));
      chunks.push(c("]"));
    } else {
      chunks.push(c(node2.optional ? "?." : "."));
      push_array(chunks, handle(node2.property, state));
    }
    return chunks;
  },
  MetaProperty(node2, state) {
    return [...handle(node2.meta, state), c("."), ...handle(node2.property, state)];
  },
  Identifier(node2, state) {
    let name2 = node2.name;
    if (name2[0] === "@") {
      name2 = state.getName(name2.slice(1));
    } else if (node2.name[0] === "#") {
      const owner = state.scope.find_owner(node2.name);
      if (!owner) {
        throw new Error(`Could not find owner for node`);
      }
      if (!state.deconflicted.has(owner)) {
        state.deconflicted.set(owner, /* @__PURE__ */ new Map());
      }
      const deconflict_map = state.deconflicted.get(owner);
      if (!deconflict_map.has(node2.name)) {
        deconflict_map.set(node2.name, deconflict(node2.name.slice(1), owner.references));
      }
      name2 = deconflict_map.get(node2.name);
    }
    return [c(name2, node2)];
  },
  Literal(node2, state) {
    if (typeof node2.value === "string") {
      return [
        c((node2.raw || JSON.stringify(node2.value)).replace(re, (_m, _i, at2, hash, name2) => {
          if (at2)
            return "@" + name2;
          if (hash)
            return "#" + name2;
          throw new Error(`this shouldn't happen`);
        }), node2)
      ];
    }
    return [c(node2.raw || String(node2.value), node2)];
  }
};
handlers.ForOfStatement = handlers.ForInStatement;
handlers.FunctionExpression = handlers.FunctionDeclaration;
handlers.ClassExpression = handlers.ClassDeclaration;
handlers.ClassBody = handlers.BlockStatement;
handlers.SpreadElement = handlers.RestElement;
handlers.ArrayPattern = handlers.ArrayExpression;
handlers.LogicalExpression = handlers.BinaryExpression;
handlers.AssignmentPattern = handlers.AssignmentExpression;
var charToInteger = {};
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
for (i$1 = 0; i$1 < chars.length; i$1++) {
  charToInteger[chars.charCodeAt(i$1)] = i$1;
}
var i$1;
function encode(decoded) {
  var sourceFileIndex = 0;
  var sourceCodeLine = 0;
  var sourceCodeColumn = 0;
  var nameIndex = 0;
  var mappings = "";
  for (var i = 0; i < decoded.length; i++) {
    var line2 = decoded[i];
    if (i > 0)
      mappings += ";";
    if (line2.length === 0)
      continue;
    var generatedCodeColumn = 0;
    var lineMappings = [];
    for (var _i = 0, line_1 = line2; _i < line_1.length; _i++) {
      var segment = line_1[_i];
      var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
      generatedCodeColumn = segment[0];
      if (segment.length > 1) {
        segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);
        sourceFileIndex = segment[1];
        sourceCodeLine = segment[2];
        sourceCodeColumn = segment[3];
      }
      if (segment.length === 5) {
        segmentMappings += encodeInteger(segment[4] - nameIndex);
        nameIndex = segment[4];
      }
      lineMappings.push(segmentMappings);
    }
    mappings += lineMappings.join(",");
  }
  return mappings;
}
function encodeInteger(num2) {
  var result = "";
  num2 = num2 < 0 ? -num2 << 1 | 1 : num2 << 1;
  do {
    var clamped = num2 & 31;
    num2 >>>= 5;
    if (num2 > 0) {
      clamped |= 32;
    }
    result += chars[clamped];
  } while (num2 > 0);
  return result;
}
var btoa$1 = () => {
  throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
};
if (typeof window !== "undefined" && typeof window.btoa === "function") {
  btoa$1 = (str2) => window.btoa(unescape(encodeURIComponent(str2)));
} else if (typeof Buffer === "function") {
  btoa$1 = (str2) => Buffer.from(str2, "utf-8").toString("base64");
}
var sigils = {
  "@": "AT",
  "#": "HASH"
};
var join$1 = (strings) => {
  let str2 = strings[0];
  for (let i = 1; i < strings.length; i += 1) {
    str2 += `_${id}_${i - 1}_${strings[i]}`;
  }
  return str2.replace(
    /([@#])(\w+)/g,
    (_m, sigil, name2) => `_${id}_${sigils[sigil]}_${name2}`
  );
};
var flatten_body = (array, target2) => {
  for (let i = 0; i < array.length; i += 1) {
    const statement = array[i];
    if (Array.isArray(statement)) {
      flatten_body(statement, target2);
      continue;
    }
    if (statement.type === "ExpressionStatement") {
      if (statement.expression === EMPTY)
        continue;
      if (Array.isArray(statement.expression)) {
        let node2 = statement.expression[0];
        while (Array.isArray(node2))
          node2 = node2[0];
        if (node2)
          node2.leadingComments = statement.leadingComments;
        flatten_body(statement.expression, target2);
        continue;
      }
      if (/(Expression|Literal)$/.test(statement.expression.type)) {
        target2.push(statement);
        continue;
      }
      if (statement.leadingComments)
        statement.expression.leadingComments = statement.leadingComments;
      if (statement.trailingComments)
        statement.expression.trailingComments = statement.trailingComments;
      target2.push(statement.expression);
      continue;
    }
    target2.push(statement);
  }
  return target2;
};
var flatten_properties = (array, target2) => {
  for (let i = 0; i < array.length; i += 1) {
    const property = array[i];
    if (property.value === EMPTY)
      continue;
    if (property.key === property.value && Array.isArray(property.key)) {
      flatten_properties(property.key, target2);
      continue;
    }
    target2.push(property);
  }
  return target2;
};
var flatten$1 = (nodes, target2) => {
  for (let i = 0; i < nodes.length; i += 1) {
    const node2 = nodes[i];
    if (node2 === EMPTY)
      continue;
    if (Array.isArray(node2)) {
      flatten$1(node2, target2);
      continue;
    }
    target2.push(node2);
  }
  return target2;
};
var EMPTY = { type: "Empty" };
var acorn_opts = (comments, raw2) => {
  const { onComment } = get_comment_handlers(comments, raw2);
  return {
    ecmaVersion: 2020,
    sourceType: "module",
    allowAwaitOutsideFunction: true,
    allowImportExportEverywhere: true,
    allowReturnOutsideFunction: true,
    onComment
  };
};
var inject = (raw2, node2, values2, comments) => {
  comments.forEach((comment2) => {
    comment2.value = comment2.value.replace(
      re,
      (m, i) => +i in values2 ? values2[+i] : m
    );
  });
  const { enter, leave } = get_comment_handlers(comments, raw2);
  return walk(node2, {
    enter,
    leave(node3) {
      if (node3.type === "Identifier") {
        re.lastIndex = 0;
        const match = re.exec(node3.name);
        if (match) {
          if (match[1]) {
            if (+match[1] in values2) {
              let value2 = values2[+match[1]];
              if (typeof value2 === "string") {
                value2 = {
                  type: "Identifier",
                  name: value2,
                  leadingComments: node3.leadingComments,
                  trailingComments: node3.trailingComments
                };
              } else if (typeof value2 === "number") {
                value2 = {
                  type: "Literal",
                  value: value2,
                  leadingComments: node3.leadingComments,
                  trailingComments: node3.trailingComments
                };
              }
              this.replace(value2 || EMPTY);
            }
          } else {
            node3.name = `${match[2] ? `@` : `#`}${match[4]}`;
          }
        }
      }
      if (node3.type === "Literal") {
        if (typeof node3.value === "string") {
          re.lastIndex = 0;
          const new_value = node3.value.replace(
            re,
            (m, i) => +i in values2 ? values2[+i] : m
          );
          const has_changed = new_value !== node3.value;
          node3.value = new_value;
          if (has_changed && node3.raw) {
            node3.raw = `${node3.raw[0]}${JSON.stringify(node3.value).slice(
              1,
              -1
            )}${node3.raw[node3.raw.length - 1]}`;
          }
        }
      }
      if (node3.type === "TemplateElement") {
        re.lastIndex = 0;
        node3.value.raw = node3.value.raw.replace(
          re,
          (m, i) => +i in values2 ? values2[+i] : m
        );
      }
      if (node3.type === "Program" || node3.type === "BlockStatement") {
        node3.body = flatten_body(node3.body, []);
      }
      if (node3.type === "ObjectExpression" || node3.type === "ObjectPattern") {
        node3.properties = flatten_properties(node3.properties, []);
      }
      if (node3.type === "ArrayExpression" || node3.type === "ArrayPattern") {
        node3.elements = flatten$1(node3.elements, []);
      }
      if (node3.type === "FunctionExpression" || node3.type === "FunctionDeclaration" || node3.type === "ArrowFunctionExpression") {
        node3.params = flatten$1(node3.params, []);
      }
      if (node3.type === "CallExpression" || node3.type === "NewExpression") {
        node3.arguments = flatten$1(node3.arguments, []);
      }
      if (node3.type === "ImportDeclaration" || node3.type === "ExportNamedDeclaration") {
        node3.specifiers = flatten$1(node3.specifiers, []);
      }
      if (node3.type === "ForStatement") {
        node3.init = node3.init === EMPTY ? null : node3.init;
        node3.test = node3.test === EMPTY ? null : node3.test;
        node3.update = node3.update === EMPTY ? null : node3.update;
      }
      leave(node3);
    }
  });
};
function x(strings, ...values2) {
  const str2 = join$1(strings);
  const comments = [];
  try {
    let expression2 = parseExpressionAt2(str2, 0, acorn_opts(comments, str2));
    const match = /\S+/.exec(str2.slice(expression2.end));
    if (match) {
      throw new Error(`Unexpected token '${match[0]}'`);
    }
    expression2 = inject(str2, expression2, values2, comments);
    return expression2;
  } catch (err) {
    handle_error(str2, err);
  }
}
function handle_error(str2, err) {
  re.lastIndex = 0;
  str2 = str2.replace(re, (m, i, at2, hash, name2) => {
    if (at2)
      return `@${name2}`;
    if (hash)
      return `#${name2}`;
    return "${...}";
  });
  console.log(`failed to parse:
${str2}`);
  throw err;
}
var parse$1 = (source, opts) => {
  const comments = [];
  const { onComment, enter, leave } = get_comment_handlers(comments, source);
  const ast2 = parse3(source, { onComment, ...opts });
  walk(ast2, { enter, leave });
  return ast2;
};
var parseExpressionAt$1 = (source, index2, opts) => {
  const comments = [];
  const { onComment, enter, leave } = get_comment_handlers(comments, source);
  const ast2 = parseExpressionAt2(source, index2, { onComment, ...opts });
  walk(ast2, { enter, leave });
  return ast2;
};
var parse$2 = (source) => parse$1(source, {
  sourceType: "module",
  ecmaVersion: 12,
  locations: true
});
var parse_expression_at = (source, index2) => parseExpressionAt$1(source, index2, {
  sourceType: "module",
  ecmaVersion: 12,
  locations: true
});
function read_expression(parser3) {
  try {
    const node2 = parse_expression_at(parser3.template, parser3.index);
    let num_parens = 0;
    for (let i = parser3.index; i < node2.start; i += 1) {
      if (parser3.template[i] === "(")
        num_parens += 1;
    }
    let index2 = node2.end;
    while (num_parens > 0) {
      const char = parser3.template[index2];
      if (char === ")") {
        num_parens -= 1;
      } else if (!regex_whitespace.test(char)) {
        parser3.error(parser_errors.unexpected_token(")"), index2);
      }
      index2 += 1;
    }
    parser3.index = index2;
    return node2;
  } catch (err) {
    parser3.acorn_error(err);
  }
}
var regex_closing_script_tag = /<\/script\s*>/;
function get_context(parser3, attributes2, start2) {
  const context2 = attributes2.find((attribute2) => attribute2.name === "context");
  if (!context2)
    return "default";
  if (context2.value.length !== 1 || context2.value[0].type !== "Text") {
    parser3.error(parser_errors.invalid_script_context_attribute, start2);
  }
  const value2 = context2.value[0].data;
  if (value2 !== "module") {
    parser3.error(parser_errors.invalid_script_context_value, context2.start);
  }
  return value2;
}
function read_script(parser3, start2, attributes2) {
  const script_start = parser3.index;
  const data3 = parser3.read_until(regex_closing_script_tag, parser_errors.unclosed_script);
  if (parser3.index >= parser3.template.length) {
    parser3.error(parser_errors.unclosed_script);
  }
  const source = parser3.template.slice(0, script_start).replace(regex_not_newline_characters, " ") + data3;
  parser3.read(regex_closing_script_tag);
  let ast2;
  try {
    ast2 = parse$2(source);
  } catch (err) {
    parser3.acorn_error(err);
  }
  ast2.start = script_start;
  return {
    type: "Script",
    start: start2,
    end: parser3.index,
    context: get_context(parser3, attributes2, start2),
    content: ast2
  };
}
var MIN_SIZE = 16 * 1024;
var SafeUint32Array = typeof Uint32Array !== "undefined" ? Uint32Array : Array;
var adoptBuffer = function adoptBuffer2(buffer, size) {
  if (buffer === null || buffer.length < size) {
    return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
  }
  return buffer;
};
var TYPE = {
  EOF: 0,
  Ident: 1,
  Function: 2,
  AtKeyword: 3,
  Hash: 4,
  String: 5,
  BadString: 6,
  Url: 7,
  BadUrl: 8,
  Delim: 9,
  Number: 10,
  Percentage: 11,
  Dimension: 12,
  WhiteSpace: 13,
  CDO: 14,
  CDC: 15,
  Colon: 16,
  Semicolon: 17,
  Comma: 18,
  LeftSquareBracket: 19,
  RightSquareBracket: 20,
  LeftParenthesis: 21,
  RightParenthesis: 22,
  LeftCurlyBracket: 23,
  RightCurlyBracket: 24,
  Comment: 25
};
var NAME = Object.keys(TYPE).reduce(function(result, key) {
  result[TYPE[key]] = key;
  return result;
}, {});
var _const = {
  TYPE,
  NAME
};
var EOF = 0;
function isDigit(code2) {
  return code2 >= 48 && code2 <= 57;
}
function isHexDigit$1(code2) {
  return isDigit(code2) || code2 >= 65 && code2 <= 70 || code2 >= 97 && code2 <= 102;
}
function isUppercaseLetter(code2) {
  return code2 >= 65 && code2 <= 90;
}
function isLowercaseLetter(code2) {
  return code2 >= 97 && code2 <= 122;
}
function isLetter(code2) {
  return isUppercaseLetter(code2) || isLowercaseLetter(code2);
}
function isNonAscii(code2) {
  return code2 >= 128;
}
function isNameStart(code2) {
  return isLetter(code2) || isNonAscii(code2) || code2 === 95;
}
function isName(code2) {
  return isNameStart(code2) || isDigit(code2) || code2 === 45;
}
function isNonPrintable(code2) {
  return code2 >= 0 && code2 <= 8 || code2 === 11 || code2 >= 14 && code2 <= 31 || code2 === 127;
}
function isNewline(code2) {
  return code2 === 10 || code2 === 13 || code2 === 12;
}
function isWhiteSpace(code2) {
  return isNewline(code2) || code2 === 32 || code2 === 9;
}
function isValidEscape(first2, second) {
  if (first2 !== 92) {
    return false;
  }
  if (isNewline(second) || second === EOF) {
    return false;
  }
  return true;
}
function isIdentifierStart$1(first2, second, third) {
  if (first2 === 45) {
    return isNameStart(second) || second === 45 || isValidEscape(second, third);
  }
  if (isNameStart(first2)) {
    return true;
  }
  if (first2 === 92) {
    return isValidEscape(first2, second);
  }
  return false;
}
function isNumberStart(first2, second, third) {
  if (first2 === 43 || first2 === 45) {
    if (isDigit(second)) {
      return 2;
    }
    return second === 46 && isDigit(third) ? 3 : 0;
  }
  if (first2 === 46) {
    return isDigit(second) ? 2 : 0;
  }
  if (isDigit(first2)) {
    return 1;
  }
  return 0;
}
function isBOM(code2) {
  if (code2 === 65279) {
    return 1;
  }
  if (code2 === 65534) {
    return 1;
  }
  return 0;
}
var CATEGORY = new Array(128);
charCodeCategory.Eof = 128;
charCodeCategory.WhiteSpace = 130;
charCodeCategory.Digit = 131;
charCodeCategory.NameStart = 132;
charCodeCategory.NonPrintable = 133;
for (i$2 = 0; i$2 < CATEGORY.length; i$2++) {
  switch (true) {
    case isWhiteSpace(i$2):
      CATEGORY[i$2] = charCodeCategory.WhiteSpace;
      break;
    case isDigit(i$2):
      CATEGORY[i$2] = charCodeCategory.Digit;
      break;
    case isNameStart(i$2):
      CATEGORY[i$2] = charCodeCategory.NameStart;
      break;
    case isNonPrintable(i$2):
      CATEGORY[i$2] = charCodeCategory.NonPrintable;
      break;
    default:
      CATEGORY[i$2] = i$2 || charCodeCategory.Eof;
  }
}
var i$2;
function charCodeCategory(code2) {
  return code2 < 128 ? CATEGORY[code2] : charCodeCategory.NameStart;
}
var charCodeDefinitions = {
  isDigit,
  isHexDigit: isHexDigit$1,
  isUppercaseLetter,
  isLowercaseLetter,
  isLetter,
  isNonAscii,
  isNameStart,
  isName,
  isNonPrintable,
  isNewline,
  isWhiteSpace,
  isValidEscape,
  isIdentifierStart: isIdentifierStart$1,
  isNumberStart,
  isBOM,
  charCodeCategory
};
var isDigit$1 = charCodeDefinitions.isDigit;
var isHexDigit$2 = charCodeDefinitions.isHexDigit;
var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
var isName$1 = charCodeDefinitions.isName;
var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
var isValidEscape$1 = charCodeDefinitions.isValidEscape;
function getCharCode(source, offset2) {
  return offset2 < source.length ? source.charCodeAt(offset2) : 0;
}
function getNewlineLength(source, offset2, code2) {
  if (code2 === 13 && getCharCode(source, offset2 + 1) === 10) {
    return 2;
  }
  return 1;
}
function cmpChar(testStr, offset2, referenceCode) {
  var code2 = testStr.charCodeAt(offset2);
  if (isUppercaseLetter$1(code2)) {
    code2 = code2 | 32;
  }
  return code2 === referenceCode;
}
function cmpStr(testStr, start2, end2, referenceStr) {
  if (end2 - start2 !== referenceStr.length) {
    return false;
  }
  if (start2 < 0 || end2 > testStr.length) {
    return false;
  }
  for (var i = start2; i < end2; i++) {
    var testCode = testStr.charCodeAt(i);
    var referenceCode = referenceStr.charCodeAt(i - start2);
    if (isUppercaseLetter$1(testCode)) {
      testCode = testCode | 32;
    }
    if (testCode !== referenceCode) {
      return false;
    }
  }
  return true;
}
function findWhiteSpaceStart(source, offset2) {
  for (; offset2 >= 0; offset2--) {
    if (!isWhiteSpace$1(source.charCodeAt(offset2))) {
      break;
    }
  }
  return offset2 + 1;
}
function findWhiteSpaceEnd(source, offset2) {
  for (; offset2 < source.length; offset2++) {
    if (!isWhiteSpace$1(source.charCodeAt(offset2))) {
      break;
    }
  }
  return offset2;
}
function findDecimalNumberEnd(source, offset2) {
  for (; offset2 < source.length; offset2++) {
    if (!isDigit$1(source.charCodeAt(offset2))) {
      break;
    }
  }
  return offset2;
}
function consumeEscaped(source, offset2) {
  offset2 += 2;
  if (isHexDigit$2(getCharCode(source, offset2 - 1))) {
    for (var maxOffset = Math.min(source.length, offset2 + 5); offset2 < maxOffset; offset2++) {
      if (!isHexDigit$2(getCharCode(source, offset2))) {
        break;
      }
    }
    var code2 = getCharCode(source, offset2);
    if (isWhiteSpace$1(code2)) {
      offset2 += getNewlineLength(source, offset2, code2);
    }
  }
  return offset2;
}
function consumeName(source, offset2) {
  for (; offset2 < source.length; offset2++) {
    var code2 = source.charCodeAt(offset2);
    if (isName$1(code2)) {
      continue;
    }
    if (isValidEscape$1(code2, getCharCode(source, offset2 + 1))) {
      offset2 = consumeEscaped(source, offset2) - 1;
      continue;
    }
    break;
  }
  return offset2;
}
function consumeNumber(source, offset2) {
  var code2 = source.charCodeAt(offset2);
  if (code2 === 43 || code2 === 45) {
    code2 = source.charCodeAt(offset2 += 1);
  }
  if (isDigit$1(code2)) {
    offset2 = findDecimalNumberEnd(source, offset2 + 1);
    code2 = source.charCodeAt(offset2);
  }
  if (code2 === 46 && isDigit$1(source.charCodeAt(offset2 + 1))) {
    code2 = source.charCodeAt(offset2 += 2);
    offset2 = findDecimalNumberEnd(source, offset2);
  }
  if (cmpChar(source, offset2, 101)) {
    var sign = 0;
    code2 = source.charCodeAt(offset2 + 1);
    if (code2 === 45 || code2 === 43) {
      sign = 1;
      code2 = source.charCodeAt(offset2 + 2);
    }
    if (isDigit$1(code2)) {
      offset2 = findDecimalNumberEnd(source, offset2 + 1 + sign + 1);
    }
  }
  return offset2;
}
function consumeBadUrlRemnants(source, offset2) {
  for (; offset2 < source.length; offset2++) {
    var code2 = source.charCodeAt(offset2);
    if (code2 === 41) {
      offset2++;
      break;
    }
    if (isValidEscape$1(code2, getCharCode(source, offset2 + 1))) {
      offset2 = consumeEscaped(source, offset2);
    }
  }
  return offset2;
}
var utils = {
  consumeEscaped,
  consumeName,
  consumeNumber,
  consumeBadUrlRemnants,
  cmpChar,
  cmpStr,
  getNewlineLength,
  findWhiteSpaceStart,
  findWhiteSpaceEnd
};
var TYPE$1 = _const.TYPE;
var NAME$1 = _const.NAME;
var cmpStr$1 = utils.cmpStr;
var EOF$1 = TYPE$1.EOF;
var WHITESPACE = TYPE$1.WhiteSpace;
var COMMENT = TYPE$1.Comment;
var OFFSET_MASK = 16777215;
var TYPE_SHIFT = 24;
var TokenStream = function() {
  this.offsetAndType = null;
  this.balance = null;
  this.reset();
};
TokenStream.prototype = {
  reset: function() {
    this.eof = false;
    this.tokenIndex = -1;
    this.tokenType = 0;
    this.tokenStart = this.firstCharOffset;
    this.tokenEnd = this.firstCharOffset;
  },
  lookupType: function(offset2) {
    offset2 += this.tokenIndex;
    if (offset2 < this.tokenCount) {
      return this.offsetAndType[offset2] >> TYPE_SHIFT;
    }
    return EOF$1;
  },
  lookupOffset: function(offset2) {
    offset2 += this.tokenIndex;
    if (offset2 < this.tokenCount) {
      return this.offsetAndType[offset2 - 1] & OFFSET_MASK;
    }
    return this.source.length;
  },
  lookupValue: function(offset2, referenceStr) {
    offset2 += this.tokenIndex;
    if (offset2 < this.tokenCount) {
      return cmpStr$1(
        this.source,
        this.offsetAndType[offset2 - 1] & OFFSET_MASK,
        this.offsetAndType[offset2] & OFFSET_MASK,
        referenceStr
      );
    }
    return false;
  },
  getTokenStart: function(tokenIndex) {
    if (tokenIndex === this.tokenIndex) {
      return this.tokenStart;
    }
    if (tokenIndex > 0) {
      return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
    }
    return this.firstCharOffset;
  },
  getRawLength: function(startToken, mode) {
    var cursor = startToken;
    var balanceEnd2;
    var offset2 = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
    var type2;
    loop:
      for (; cursor < this.tokenCount; cursor++) {
        balanceEnd2 = this.balance[cursor];
        if (balanceEnd2 < startToken) {
          break loop;
        }
        type2 = this.offsetAndType[cursor] >> TYPE_SHIFT;
        switch (mode(type2, this.source, offset2)) {
          case 1:
            break loop;
          case 2:
            cursor++;
            break loop;
          default:
            offset2 = this.offsetAndType[cursor] & OFFSET_MASK;
            if (this.balance[balanceEnd2] === cursor) {
              cursor = balanceEnd2;
            }
        }
      }
    return cursor - this.tokenIndex;
  },
  isBalanceEdge: function(pos) {
    return this.balance[this.tokenIndex] < pos;
  },
  isDelim: function(code2, offset2) {
    if (offset2) {
      return this.lookupType(offset2) === TYPE$1.Delim && this.source.charCodeAt(this.lookupOffset(offset2)) === code2;
    }
    return this.tokenType === TYPE$1.Delim && this.source.charCodeAt(this.tokenStart) === code2;
  },
  getTokenValue: function() {
    return this.source.substring(this.tokenStart, this.tokenEnd);
  },
  getTokenLength: function() {
    return this.tokenEnd - this.tokenStart;
  },
  substrToCursor: function(start2) {
    return this.source.substring(start2, this.tokenStart);
  },
  skipWS: function() {
    for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
      if (this.offsetAndType[i] >> TYPE_SHIFT !== WHITESPACE) {
        break;
      }
    }
    if (skipTokenCount > 0) {
      this.skip(skipTokenCount);
    }
  },
  skipSC: function() {
    while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
      this.next();
    }
  },
  skip: function(tokenCount) {
    var next = this.tokenIndex + tokenCount;
    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT;
      this.tokenEnd = next & OFFSET_MASK;
    } else {
      this.tokenIndex = this.tokenCount;
      this.next();
    }
  },
  next: function() {
    var next = this.tokenIndex + 1;
    if (next < this.tokenCount) {
      this.tokenIndex = next;
      this.tokenStart = this.tokenEnd;
      next = this.offsetAndType[next];
      this.tokenType = next >> TYPE_SHIFT;
      this.tokenEnd = next & OFFSET_MASK;
    } else {
      this.tokenIndex = this.tokenCount;
      this.eof = true;
      this.tokenType = EOF$1;
      this.tokenStart = this.tokenEnd = this.source.length;
    }
  },
  forEachToken(fn) {
    for (var i = 0, offset2 = this.firstCharOffset; i < this.tokenCount; i++) {
      var start2 = offset2;
      var item = this.offsetAndType[i];
      var end2 = item & OFFSET_MASK;
      var type2 = item >> TYPE_SHIFT;
      offset2 = end2;
      fn(type2, start2, end2, i);
    }
  },
  dump() {
    var tokens = new Array(this.tokenCount);
    this.forEachToken((type2, start2, end2, index2) => {
      tokens[index2] = {
        idx: index2,
        type: NAME$1[type2],
        chunk: this.source.substring(start2, end2),
        balance: this.balance[index2]
      };
    });
    return tokens;
  }
};
var TokenStream_1 = TokenStream;
var TYPE$2 = _const.TYPE;
var isNewline$1 = charCodeDefinitions.isNewline;
var isName$2 = charCodeDefinitions.isName;
var isValidEscape$2 = charCodeDefinitions.isValidEscape;
var isNumberStart$1 = charCodeDefinitions.isNumberStart;
var isIdentifierStart$2 = charCodeDefinitions.isIdentifierStart;
var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
var isBOM$1 = charCodeDefinitions.isBOM;
var cmpStr$2 = utils.cmpStr;
var getNewlineLength$1 = utils.getNewlineLength;
var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
var consumeEscaped$1 = utils.consumeEscaped;
var consumeName$1 = utils.consumeName;
var consumeNumber$1 = utils.consumeNumber;
var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;
var OFFSET_MASK$1 = 16777215;
var TYPE_SHIFT$1 = 24;
function tokenize(source, stream) {
  function getCharCode2(offset3) {
    return offset3 < sourceLength ? source.charCodeAt(offset3) : 0;
  }
  function consumeNumericToken() {
    offset2 = consumeNumber$1(source, offset2);
    if (isIdentifierStart$2(getCharCode2(offset2), getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
      type2 = TYPE$2.Dimension;
      offset2 = consumeName$1(source, offset2);
      return;
    }
    if (getCharCode2(offset2) === 37) {
      type2 = TYPE$2.Percentage;
      offset2++;
      return;
    }
    type2 = TYPE$2.Number;
  }
  function consumeIdentLikeToken() {
    const nameStartOffset = offset2;
    offset2 = consumeName$1(source, offset2);
    if (cmpStr$2(source, nameStartOffset, offset2, "url") && getCharCode2(offset2) === 40) {
      offset2 = findWhiteSpaceEnd$1(source, offset2 + 1);
      if (getCharCode2(offset2) === 34 || getCharCode2(offset2) === 39) {
        type2 = TYPE$2.Function;
        offset2 = nameStartOffset + 4;
        return;
      }
      consumeUrlToken();
      return;
    }
    if (getCharCode2(offset2) === 40) {
      type2 = TYPE$2.Function;
      offset2++;
      return;
    }
    type2 = TYPE$2.Ident;
  }
  function consumeStringToken(endingCodePoint) {
    if (!endingCodePoint) {
      endingCodePoint = getCharCode2(offset2++);
    }
    type2 = TYPE$2.String;
    for (; offset2 < source.length; offset2++) {
      var code3 = source.charCodeAt(offset2);
      switch (charCodeCategory$1(code3)) {
        case endingCodePoint:
          offset2++;
          return;
        case charCodeCategory$1.Eof:
          return;
        case charCodeCategory$1.WhiteSpace:
          if (isNewline$1(code3)) {
            offset2 += getNewlineLength$1(source, offset2, code3);
            type2 = TYPE$2.BadString;
            return;
          }
          break;
        case 92:
          if (offset2 === source.length - 1) {
            break;
          }
          var nextCode = getCharCode2(offset2 + 1);
          if (isNewline$1(nextCode)) {
            offset2 += getNewlineLength$1(source, offset2 + 1, nextCode);
          } else if (isValidEscape$2(code3, nextCode)) {
            offset2 = consumeEscaped$1(source, offset2) - 1;
          }
          break;
      }
    }
  }
  function consumeUrlToken() {
    type2 = TYPE$2.Url;
    offset2 = findWhiteSpaceEnd$1(source, offset2);
    for (; offset2 < source.length; offset2++) {
      var code3 = source.charCodeAt(offset2);
      switch (charCodeCategory$1(code3)) {
        case 41:
          offset2++;
          return;
        case charCodeCategory$1.Eof:
          return;
        case charCodeCategory$1.WhiteSpace:
          offset2 = findWhiteSpaceEnd$1(source, offset2);
          if (getCharCode2(offset2) === 41 || offset2 >= source.length) {
            if (offset2 < source.length) {
              offset2++;
            }
            return;
          }
          offset2 = consumeBadUrlRemnants$1(source, offset2);
          type2 = TYPE$2.BadUrl;
          return;
        case 34:
        case 39:
        case 40:
        case charCodeCategory$1.NonPrintable:
          offset2 = consumeBadUrlRemnants$1(source, offset2);
          type2 = TYPE$2.BadUrl;
          return;
        case 92:
          if (isValidEscape$2(code3, getCharCode2(offset2 + 1))) {
            offset2 = consumeEscaped$1(source, offset2) - 1;
            break;
          }
          offset2 = consumeBadUrlRemnants$1(source, offset2);
          type2 = TYPE$2.BadUrl;
          return;
      }
    }
  }
  if (!stream) {
    stream = new TokenStream_1();
  }
  source = String(source || "");
  var sourceLength = source.length;
  var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1);
  var balance = adoptBuffer(stream.balance, sourceLength + 1);
  var tokenCount = 0;
  var start2 = isBOM$1(getCharCode2(0));
  var offset2 = start2;
  var balanceCloseType = 0;
  var balanceStart = 0;
  var balancePrev = 0;
  while (offset2 < sourceLength) {
    var code2 = source.charCodeAt(offset2);
    var type2 = 0;
    balance[tokenCount] = sourceLength;
    switch (charCodeCategory$1(code2)) {
      case charCodeCategory$1.WhiteSpace:
        type2 = TYPE$2.WhiteSpace;
        offset2 = findWhiteSpaceEnd$1(source, offset2 + 1);
        break;
      case 34:
        consumeStringToken();
        break;
      case 35:
        if (isName$2(getCharCode2(offset2 + 1)) || isValidEscape$2(getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
          type2 = TYPE$2.Hash;
          offset2 = consumeName$1(source, offset2 + 1);
        } else {
          type2 = TYPE$2.Delim;
          offset2++;
        }
        break;
      case 39:
        consumeStringToken();
        break;
      case 40:
        type2 = TYPE$2.LeftParenthesis;
        offset2++;
        break;
      case 41:
        type2 = TYPE$2.RightParenthesis;
        offset2++;
        break;
      case 43:
        if (isNumberStart$1(code2, getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
          consumeNumericToken();
        } else {
          type2 = TYPE$2.Delim;
          offset2++;
        }
        break;
      case 44:
        type2 = TYPE$2.Comma;
        offset2++;
        break;
      case 45:
        if (isNumberStart$1(code2, getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
          consumeNumericToken();
        } else {
          if (getCharCode2(offset2 + 1) === 45 && getCharCode2(offset2 + 2) === 62) {
            type2 = TYPE$2.CDC;
            offset2 = offset2 + 3;
          } else {
            if (isIdentifierStart$2(code2, getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
              consumeIdentLikeToken();
            } else {
              type2 = TYPE$2.Delim;
              offset2++;
            }
          }
        }
        break;
      case 46:
        if (isNumberStart$1(code2, getCharCode2(offset2 + 1), getCharCode2(offset2 + 2))) {
          consumeNumericToken();
        } else {
          type2 = TYPE$2.Delim;
          offset2++;
        }
        break;
      case 47:
        if (getCharCode2(offset2 + 1) === 42) {
          type2 = TYPE$2.Comment;
          offset2 = source.indexOf("*/", offset2 + 2) + 2;
          if (offset2 === 1) {
            offset2 = source.length;
          }
        } else {
          type2 = TYPE$2.Delim;
          offset2++;
        }
        break;
      case 58:
        type2 = TYPE$2.Colon;
        offset2++;
        break;
      case 59:
        type2 = TYPE$2.Semicolon;
        offset2++;
        break;
      case 60:
        if (getCharCode2(offset2 + 1) === 33 && getCharCode2(offset2 + 2) === 45 && getCharCode2(offset2 + 3) === 45) {
          type2 = TYPE$2.CDO;
          offset2 = offset2 + 4;
        } else {
          type2 = TYPE$2.Delim;
          offset2++;
        }
        break;
      case 64:
        if (isIdentifierStart$2(getCharCode2(offset2 + 1), getCharCode2(offset2 + 2), getCharCode2(offset2 + 3))) {
          type2 = TYPE$2.AtKeyword;
          offset2 = consumeName$1(source, offset2 + 1);
        } else {
          type2 = TYPE$2.Delim;
          offset2++;
        }
        break;
      case 91:
        type2 = TYPE$2.LeftSquareBracket;
        offset2++;
        break;
      case 92:
        if (isValidEscape$2(code2, getCharCode2(offset2 + 1))) {
          consumeIdentLikeToken();
        } else {
          type2 = TYPE$2.Delim;
          offset2++;
        }
        break;
      case 93:
        type2 = TYPE$2.RightSquareBracket;
        offset2++;
        break;
      case 123:
        type2 = TYPE$2.LeftCurlyBracket;
        offset2++;
        break;
      case 125:
        type2 = TYPE$2.RightCurlyBracket;
        offset2++;
        break;
      case charCodeCategory$1.Digit:
        consumeNumericToken();
        break;
      case charCodeCategory$1.NameStart:
        consumeIdentLikeToken();
        break;
      case charCodeCategory$1.Eof:
        break;
      default:
        type2 = TYPE$2.Delim;
        offset2++;
    }
    switch (type2) {
      case balanceCloseType:
        balancePrev = balanceStart & OFFSET_MASK$1;
        balanceStart = balance[balancePrev];
        balanceCloseType = balanceStart >> TYPE_SHIFT$1;
        balance[tokenCount] = balancePrev;
        balance[balancePrev++] = tokenCount;
        for (; balancePrev < tokenCount; balancePrev++) {
          if (balance[balancePrev] === sourceLength) {
            balance[balancePrev] = tokenCount;
          }
        }
        break;
      case TYPE$2.LeftParenthesis:
      case TYPE$2.Function:
        balance[tokenCount] = balanceStart;
        balanceCloseType = TYPE$2.RightParenthesis;
        balanceStart = balanceCloseType << TYPE_SHIFT$1 | tokenCount;
        break;
      case TYPE$2.LeftSquareBracket:
        balance[tokenCount] = balanceStart;
        balanceCloseType = TYPE$2.RightSquareBracket;
        balanceStart = balanceCloseType << TYPE_SHIFT$1 | tokenCount;
        break;
      case TYPE$2.LeftCurlyBracket:
        balance[tokenCount] = balanceStart;
        balanceCloseType = TYPE$2.RightCurlyBracket;
        balanceStart = balanceCloseType << TYPE_SHIFT$1 | tokenCount;
        break;
    }
    offsetAndType[tokenCount++] = type2 << TYPE_SHIFT$1 | offset2;
  }
  offsetAndType[tokenCount] = TYPE$2.EOF << TYPE_SHIFT$1 | offset2;
  balance[tokenCount] = sourceLength;
  balance[sourceLength] = sourceLength;
  while (balanceStart !== 0) {
    balancePrev = balanceStart & OFFSET_MASK$1;
    balanceStart = balance[balancePrev];
    balance[balancePrev] = sourceLength;
  }
  stream.source = source;
  stream.firstCharOffset = start2;
  stream.offsetAndType = offsetAndType;
  stream.tokenCount = tokenCount;
  stream.balance = balance;
  stream.reset();
  stream.next();
  return stream;
}
Object.keys(_const).forEach(function(key) {
  tokenize[key] = _const[key];
});
Object.keys(charCodeDefinitions).forEach(function(key) {
  tokenize[key] = charCodeDefinitions[key];
});
Object.keys(utils).forEach(function(key) {
  tokenize[key] = utils[key];
});
var tokenizer2 = tokenize;
var isBOM$2 = tokenizer2.isBOM;
var N = 10;
var F = 12;
var R = 13;
function computeLinesAndColumns(host, source) {
  var sourceLength = source.length;
  var lines = adoptBuffer(host.lines, sourceLength);
  var line2 = host.startLine;
  var columns = adoptBuffer(host.columns, sourceLength);
  var column = host.startColumn;
  var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;
  for (var i = startOffset; i < sourceLength; i++) {
    var code2 = source.charCodeAt(i);
    lines[i] = line2;
    columns[i] = column++;
    if (code2 === N || code2 === R || code2 === F) {
      if (code2 === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
        i++;
        lines[i] = line2;
        columns[i] = column;
      }
      line2++;
      column = 1;
    }
  }
  lines[i] = line2;
  columns[i] = column;
  host.lines = lines;
  host.columns = columns;
}
var OffsetToLocation = function() {
  this.lines = null;
  this.columns = null;
  this.linesAndColumnsComputed = false;
};
OffsetToLocation.prototype = {
  setSource: function(source, startOffset, startLine, startColumn) {
    this.source = source;
    this.startOffset = typeof startOffset === "undefined" ? 0 : startOffset;
    this.startLine = typeof startLine === "undefined" ? 1 : startLine;
    this.startColumn = typeof startColumn === "undefined" ? 1 : startColumn;
    this.linesAndColumnsComputed = false;
  },
  ensureLinesAndColumnsComputed: function() {
    if (!this.linesAndColumnsComputed) {
      computeLinesAndColumns(this, this.source);
      this.linesAndColumnsComputed = true;
    }
  },
  getLocation: function(offset2, filename) {
    this.ensureLinesAndColumnsComputed();
    return {
      source: filename,
      offset: this.startOffset + offset2,
      line: this.lines[offset2],
      column: this.columns[offset2]
    };
  },
  getLocationRange: function(start2, end2, filename) {
    this.ensureLinesAndColumnsComputed();
    return {
      source: filename,
      start: {
        offset: this.startOffset + start2,
        line: this.lines[start2],
        column: this.columns[start2]
      },
      end: {
        offset: this.startOffset + end2,
        line: this.lines[end2],
        column: this.columns[end2]
      }
    };
  }
};
var OffsetToLocation_1 = OffsetToLocation;
var createCustomError = function createCustomError2(name2, message2) {
  var error2 = Object.create(SyntaxError.prototype);
  var errorStack = new Error();
  error2.name = name2;
  error2.message = message2;
  Object.defineProperty(error2, "stack", {
    get: function() {
      return (errorStack.stack || "").replace(/^(.+\n){1,3}/, name2 + ": " + message2 + "\n");
    }
  });
  return error2;
};
var MAX_LINE_LENGTH = 100;
var OFFSET_CORRECTION = 60;
var TAB_REPLACEMENT = "    ";
function sourceFragment(error2, extraLines) {
  function processLines(start2, end2) {
    return lines.slice(start2, end2).map(function(line3, idx) {
      var num2 = String(start2 + idx + 1);
      while (num2.length < maxNumLength) {
        num2 = " " + num2;
      }
      return num2 + " |" + line3;
    }).join("\n");
  }
  var lines = error2.source.split(/\r\n?|\n|\f/);
  var line2 = error2.line;
  var column = error2.column;
  var startLine = Math.max(1, line2 - extraLines) - 1;
  var endLine = Math.min(line2 + extraLines, lines.length + 1);
  var maxNumLength = Math.max(4, String(endLine).length) + 1;
  var cutLeft = 0;
  column += (TAB_REPLACEMENT.length - 1) * (lines[line2 - 1].substr(0, column - 1).match(/\t/g) || []).length;
  if (column > MAX_LINE_LENGTH) {
    cutLeft = column - OFFSET_CORRECTION + 3;
    column = OFFSET_CORRECTION - 2;
  }
  for (var i = startLine; i <= endLine; i++) {
    if (i >= 0 && i < lines.length) {
      lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
      lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? "\u2026" : "") + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "\u2026" : "");
    }
  }
  return [
    processLines(startLine, line2),
    new Array(column + maxNumLength + 2).join("-") + "^",
    processLines(line2, endLine)
  ].filter(Boolean).join("\n");
}
var SyntaxError$1 = function(message2, source, offset2, line2, column) {
  var error2 = createCustomError("SyntaxError", message2);
  error2.source = source;
  error2.offset = offset2;
  error2.line = line2;
  error2.column = column;
  error2.sourceFragment = function(extraLines) {
    return sourceFragment(error2, isNaN(extraLines) ? 0 : extraLines);
  };
  Object.defineProperty(error2, "formattedMessage", {
    get: function() {
      return "Parse error: " + error2.message + "\n" + sourceFragment(error2, 2);
    }
  });
  error2.parseError = {
    offset: offset2,
    line: line2,
    column
  };
  return error2;
};
var _SyntaxError = SyntaxError$1;
function createItem(data3) {
  return {
    prev: null,
    next: null,
    data: data3
  };
}
function allocateCursor(node2, prev, next) {
  var cursor;
  if (cursors !== null) {
    cursor = cursors;
    cursors = cursors.cursor;
    cursor.prev = prev;
    cursor.next = next;
    cursor.cursor = node2.cursor;
  } else {
    cursor = {
      prev,
      next,
      cursor: node2.cursor
    };
  }
  node2.cursor = cursor;
  return cursor;
}
function releaseCursor(node2) {
  var cursor = node2.cursor;
  node2.cursor = cursor.cursor;
  cursor.prev = null;
  cursor.next = null;
  cursor.cursor = cursors;
  cursors = cursor;
}
var cursors = null;
var List = function() {
  this.cursor = null;
  this.head = null;
  this.tail = null;
};
List.createItem = createItem;
List.prototype.createItem = createItem;
List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
  var cursor = this.cursor;
  while (cursor !== null) {
    if (cursor.prev === prevOld) {
      cursor.prev = prevNew;
    }
    if (cursor.next === nextOld) {
      cursor.next = nextNew;
    }
    cursor = cursor.cursor;
  }
};
List.prototype.getSize = function() {
  var size = 0;
  var cursor = this.head;
  while (cursor) {
    size++;
    cursor = cursor.next;
  }
  return size;
};
List.prototype.fromArray = function(array) {
  var cursor = null;
  this.head = null;
  for (var i = 0; i < array.length; i++) {
    var item = createItem(array[i]);
    if (cursor !== null) {
      cursor.next = item;
    } else {
      this.head = item;
    }
    item.prev = cursor;
    cursor = item;
  }
  this.tail = cursor;
  return this;
};
List.prototype.toArray = function() {
  var cursor = this.head;
  var result = [];
  while (cursor) {
    result.push(cursor.data);
    cursor = cursor.next;
  }
  return result;
};
List.prototype.toJSON = List.prototype.toArray;
List.prototype.isEmpty = function() {
  return this.head === null;
};
List.prototype.first = function() {
  return this.head && this.head.data;
};
List.prototype.last = function() {
  return this.tail && this.tail.data;
};
List.prototype.each = function(fn, context2) {
  var item;
  if (context2 === void 0) {
    context2 = this;
  }
  var cursor = allocateCursor(this, null, this.head);
  while (cursor.next !== null) {
    item = cursor.next;
    cursor.next = item.next;
    fn.call(context2, item.data, item, this);
  }
  releaseCursor(this);
};
List.prototype.forEach = List.prototype.each;
List.prototype.eachRight = function(fn, context2) {
  var item;
  if (context2 === void 0) {
    context2 = this;
  }
  var cursor = allocateCursor(this, this.tail, null);
  while (cursor.prev !== null) {
    item = cursor.prev;
    cursor.prev = item.prev;
    fn.call(context2, item.data, item, this);
  }
  releaseCursor(this);
};
List.prototype.forEachRight = List.prototype.eachRight;
List.prototype.reduce = function(fn, initialValue, context2) {
  var item;
  if (context2 === void 0) {
    context2 = this;
  }
  var cursor = allocateCursor(this, null, this.head);
  var acc = initialValue;
  while (cursor.next !== null) {
    item = cursor.next;
    cursor.next = item.next;
    acc = fn.call(context2, acc, item.data, item, this);
  }
  releaseCursor(this);
  return acc;
};
List.prototype.reduceRight = function(fn, initialValue, context2) {
  var item;
  if (context2 === void 0) {
    context2 = this;
  }
  var cursor = allocateCursor(this, this.tail, null);
  var acc = initialValue;
  while (cursor.prev !== null) {
    item = cursor.prev;
    cursor.prev = item.prev;
    acc = fn.call(context2, acc, item.data, item, this);
  }
  releaseCursor(this);
  return acc;
};
List.prototype.nextUntil = function(start2, fn, context2) {
  if (start2 === null) {
    return;
  }
  var item;
  if (context2 === void 0) {
    context2 = this;
  }
  var cursor = allocateCursor(this, null, start2);
  while (cursor.next !== null) {
    item = cursor.next;
    cursor.next = item.next;
    if (fn.call(context2, item.data, item, this)) {
      break;
    }
  }
  releaseCursor(this);
};
List.prototype.prevUntil = function(start2, fn, context2) {
  if (start2 === null) {
    return;
  }
  var item;
  if (context2 === void 0) {
    context2 = this;
  }
  var cursor = allocateCursor(this, start2, null);
  while (cursor.prev !== null) {
    item = cursor.prev;
    cursor.prev = item.prev;
    if (fn.call(context2, item.data, item, this)) {
      break;
    }
  }
  releaseCursor(this);
};
List.prototype.some = function(fn, context2) {
  var cursor = this.head;
  if (context2 === void 0) {
    context2 = this;
  }
  while (cursor !== null) {
    if (fn.call(context2, cursor.data, cursor, this)) {
      return true;
    }
    cursor = cursor.next;
  }
  return false;
};
List.prototype.map = function(fn, context2) {
  var result = new List();
  var cursor = this.head;
  if (context2 === void 0) {
    context2 = this;
  }
  while (cursor !== null) {
    result.appendData(fn.call(context2, cursor.data, cursor, this));
    cursor = cursor.next;
  }
  return result;
};
List.prototype.filter = function(fn, context2) {
  var result = new List();
  var cursor = this.head;
  if (context2 === void 0) {
    context2 = this;
  }
  while (cursor !== null) {
    if (fn.call(context2, cursor.data, cursor, this)) {
      result.appendData(cursor.data);
    }
    cursor = cursor.next;
  }
  return result;
};
List.prototype.clear = function() {
  this.head = null;
  this.tail = null;
};
List.prototype.copy = function() {
  var result = new List();
  var cursor = this.head;
  while (cursor !== null) {
    result.insert(createItem(cursor.data));
    cursor = cursor.next;
  }
  return result;
};
List.prototype.prepend = function(item) {
  this.updateCursors(null, item, this.head, item);
  if (this.head !== null) {
    this.head.prev = item;
    item.next = this.head;
  } else {
    this.tail = item;
  }
  this.head = item;
  return this;
};
List.prototype.prependData = function(data3) {
  return this.prepend(createItem(data3));
};
List.prototype.append = function(item) {
  return this.insert(item);
};
List.prototype.appendData = function(data3) {
  return this.insert(createItem(data3));
};
List.prototype.insert = function(item, before2) {
  if (before2 !== void 0 && before2 !== null) {
    this.updateCursors(before2.prev, item, before2, item);
    if (before2.prev === null) {
      if (this.head !== before2) {
        throw new Error("before doesn't belong to list");
      }
      this.head = item;
      before2.prev = item;
      item.next = before2;
      this.updateCursors(null, item);
    } else {
      before2.prev.next = item;
      item.prev = before2.prev;
      before2.prev = item;
      item.next = before2;
    }
  } else {
    this.updateCursors(this.tail, item, null, item);
    if (this.tail !== null) {
      this.tail.next = item;
      item.prev = this.tail;
    } else {
      this.head = item;
    }
    this.tail = item;
  }
  return this;
};
List.prototype.insertData = function(data3, before2) {
  return this.insert(createItem(data3), before2);
};
List.prototype.remove = function(item) {
  this.updateCursors(item, item.prev, item, item.next);
  if (item.prev !== null) {
    item.prev.next = item.next;
  } else {
    if (this.head !== item) {
      throw new Error("item doesn't belong to list");
    }
    this.head = item.next;
  }
  if (item.next !== null) {
    item.next.prev = item.prev;
  } else {
    if (this.tail !== item) {
      throw new Error("item doesn't belong to list");
    }
    this.tail = item.prev;
  }
  item.prev = null;
  item.next = null;
  return item;
};
List.prototype.push = function(data3) {
  this.insert(createItem(data3));
};
List.prototype.pop = function() {
  if (this.tail !== null) {
    return this.remove(this.tail);
  }
};
List.prototype.unshift = function(data3) {
  this.prepend(createItem(data3));
};
List.prototype.shift = function() {
  if (this.head !== null) {
    return this.remove(this.head);
  }
};
List.prototype.prependList = function(list2) {
  return this.insertList(list2, this.head);
};
List.prototype.appendList = function(list2) {
  return this.insertList(list2);
};
List.prototype.insertList = function(list2, before2) {
  if (list2.head === null) {
    return this;
  }
  if (before2 !== void 0 && before2 !== null) {
    this.updateCursors(before2.prev, list2.tail, before2, list2.head);
    if (before2.prev !== null) {
      before2.prev.next = list2.head;
      list2.head.prev = before2.prev;
    } else {
      this.head = list2.head;
    }
    before2.prev = list2.tail;
    list2.tail.next = before2;
  } else {
    this.updateCursors(this.tail, list2.tail, null, list2.head);
    if (this.tail !== null) {
      this.tail.next = list2.head;
      list2.head.prev = this.tail;
    } else {
      this.head = list2.head;
    }
    this.tail = list2.tail;
  }
  list2.head = null;
  list2.tail = null;
  return this;
};
List.prototype.replace = function(oldItem, newItemOrList) {
  if ("head" in newItemOrList) {
    this.insertList(newItemOrList, oldItem);
  } else {
    this.insert(newItemOrList, oldItem);
  }
  this.remove(oldItem);
};
var List_1 = List;
var TYPE$3 = tokenizer2.TYPE;
var WHITESPACE$1 = TYPE$3.WhiteSpace;
var COMMENT$1 = TYPE$3.Comment;
var sequence = function readSequence(recognizer) {
  var children = this.createList();
  var child = null;
  var context2 = {
    recognizer,
    space: null,
    ignoreWS: false,
    ignoreWSAfter: false
  };
  this.scanner.skipSC();
  while (!this.scanner.eof) {
    switch (this.scanner.tokenType) {
      case COMMENT$1:
        this.scanner.next();
        continue;
      case WHITESPACE$1:
        if (context2.ignoreWS) {
          this.scanner.next();
        } else {
          context2.space = this.WhiteSpace();
        }
        continue;
    }
    child = recognizer.getNode.call(this, context2);
    if (child === void 0) {
      break;
    }
    if (context2.space !== null) {
      children.push(context2.space);
      context2.space = null;
    }
    children.push(child);
    if (context2.ignoreWSAfter) {
      context2.ignoreWSAfter = false;
      context2.ignoreWS = true;
    } else {
      context2.ignoreWS = false;
    }
  }
  return children;
};
var { findWhiteSpaceStart: findWhiteSpaceStart$1, cmpStr: cmpStr$3 } = utils;
var noop = function() {
};
var TYPE$4 = _const.TYPE;
var NAME$2 = _const.NAME;
var WHITESPACE$2 = TYPE$4.WhiteSpace;
var COMMENT$2 = TYPE$4.Comment;
var IDENT = TYPE$4.Ident;
var FUNCTION = TYPE$4.Function;
var URL$1 = TYPE$4.Url;
var HASH = TYPE$4.Hash;
var PERCENTAGE = TYPE$4.Percentage;
var NUMBER = TYPE$4.Number;
var NUMBERSIGN = 35;
var NULL = 0;
function createParseContext(name2) {
  return function() {
    return this[name2]();
  };
}
function processConfig(config) {
  var parserConfig = {
    context: {},
    scope: {},
    atrule: {},
    pseudo: {}
  };
  if (config.parseContext) {
    for (var name2 in config.parseContext) {
      switch (typeof config.parseContext[name2]) {
        case "function":
          parserConfig.context[name2] = config.parseContext[name2];
          break;
        case "string":
          parserConfig.context[name2] = createParseContext(config.parseContext[name2]);
          break;
      }
    }
  }
  if (config.scope) {
    for (var name2 in config.scope) {
      parserConfig.scope[name2] = config.scope[name2];
    }
  }
  if (config.atrule) {
    for (var name2 in config.atrule) {
      var atrule2 = config.atrule[name2];
      if (atrule2.parse) {
        parserConfig.atrule[name2] = atrule2.parse;
      }
    }
  }
  if (config.pseudo) {
    for (var name2 in config.pseudo) {
      var pseudo2 = config.pseudo[name2];
      if (pseudo2.parse) {
        parserConfig.pseudo[name2] = pseudo2.parse;
      }
    }
  }
  if (config.node) {
    for (var name2 in config.node) {
      parserConfig[name2] = config.node[name2].parse;
    }
  }
  return parserConfig;
}
var create = function createParser(config) {
  var parser3 = {
    scanner: new TokenStream_1(),
    locationMap: new OffsetToLocation_1(),
    filename: "<unknown>",
    needPositions: false,
    onParseError: noop,
    onParseErrorThrow: false,
    parseAtrulePrelude: true,
    parseRulePrelude: true,
    parseValue: true,
    parseCustomProperty: false,
    readSequence: sequence,
    createList: function() {
      return new List_1();
    },
    createSingleNodeList: function(node2) {
      return new List_1().appendData(node2);
    },
    getFirstListNode: function(list2) {
      return list2 && list2.first();
    },
    getLastListNode: function(list2) {
      return list2.last();
    },
    parseWithFallback: function(consumer, fallback) {
      var startToken = this.scanner.tokenIndex;
      try {
        return consumer.call(this);
      } catch (e) {
        if (this.onParseErrorThrow) {
          throw e;
        }
        var fallbackNode = fallback.call(this, startToken);
        this.onParseErrorThrow = true;
        this.onParseError(e, fallbackNode);
        this.onParseErrorThrow = false;
        return fallbackNode;
      }
    },
    lookupNonWSType: function(offset2) {
      do {
        var type2 = this.scanner.lookupType(offset2++);
        if (type2 !== WHITESPACE$2) {
          return type2;
        }
      } while (type2 !== NULL);
      return NULL;
    },
    eat: function(tokenType) {
      if (this.scanner.tokenType !== tokenType) {
        var offset2 = this.scanner.tokenStart;
        var message2 = NAME$2[tokenType] + " is expected";
        switch (tokenType) {
          case IDENT:
            if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
              offset2 = this.scanner.tokenEnd - 1;
              message2 = "Identifier is expected but function found";
            } else {
              message2 = "Identifier is expected";
            }
            break;
          case HASH:
            if (this.scanner.isDelim(NUMBERSIGN)) {
              this.scanner.next();
              offset2++;
              message2 = "Name is expected";
            }
            break;
          case PERCENTAGE:
            if (this.scanner.tokenType === NUMBER) {
              offset2 = this.scanner.tokenEnd;
              message2 = "Percent sign is expected";
            }
            break;
          default:
            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
              offset2 = offset2 + 1;
            }
        }
        this.error(message2, offset2);
      }
      this.scanner.next();
    },
    consume: function(tokenType) {
      var value2 = this.scanner.getTokenValue();
      this.eat(tokenType);
      return value2;
    },
    consumeFunctionName: function() {
      var name2 = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);
      this.eat(FUNCTION);
      return name2;
    },
    getLocation: function(start2, end2) {
      if (this.needPositions) {
        return this.locationMap.getLocationRange(
          start2,
          end2,
          this.filename
        );
      }
      return null;
    },
    getLocationFromList: function(list2) {
      if (this.needPositions) {
        var head2 = this.getFirstListNode(list2);
        var tail = this.getLastListNode(list2);
        return this.locationMap.getLocationRange(
          head2 !== null ? head2.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
          tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
          this.filename
        );
      }
      return null;
    },
    error: function(message2, offset2) {
      var location = typeof offset2 !== "undefined" && offset2 < this.scanner.source.length ? this.locationMap.getLocation(offset2) : this.scanner.eof ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1)) : this.locationMap.getLocation(this.scanner.tokenStart);
      throw new _SyntaxError(
        message2 || "Unexpected input",
        this.scanner.source,
        location.offset,
        location.line,
        location.column
      );
    }
  };
  config = processConfig(config || {});
  for (var key in config) {
    parser3[key] = config[key];
  }
  return function(source, options2) {
    options2 = options2 || {};
    var context2 = options2.context || "default";
    var onComment = options2.onComment;
    var ast2;
    tokenizer2(source, parser3.scanner);
    parser3.locationMap.setSource(
      source,
      options2.offset,
      options2.line,
      options2.column
    );
    parser3.filename = options2.filename || "<unknown>";
    parser3.needPositions = Boolean(options2.positions);
    parser3.onParseError = typeof options2.onParseError === "function" ? options2.onParseError : noop;
    parser3.onParseErrorThrow = false;
    parser3.parseAtrulePrelude = "parseAtrulePrelude" in options2 ? Boolean(options2.parseAtrulePrelude) : true;
    parser3.parseRulePrelude = "parseRulePrelude" in options2 ? Boolean(options2.parseRulePrelude) : true;
    parser3.parseValue = "parseValue" in options2 ? Boolean(options2.parseValue) : true;
    parser3.parseCustomProperty = "parseCustomProperty" in options2 ? Boolean(options2.parseCustomProperty) : false;
    if (!parser3.context.hasOwnProperty(context2)) {
      throw new Error("Unknown context `" + context2 + "`");
    }
    if (typeof onComment === "function") {
      parser3.scanner.forEachToken((type2, start2, end2) => {
        if (type2 === COMMENT$2) {
          const loc = parser3.getLocation(start2, end2);
          const value2 = cmpStr$3(source, end2 - 2, end2, "*/") ? source.slice(start2 + 2, end2 - 2) : source.slice(start2 + 2, end2);
          onComment(value2, loc);
        }
      });
    }
    ast2 = parser3.context[context2].call(parser3, options2);
    if (!parser3.scanner.eof) {
      parser3.error();
    }
    return ast2;
  };
};
var cmpChar$1 = tokenizer2.cmpChar;
var cmpStr$4 = tokenizer2.cmpStr;
var TYPE$5 = tokenizer2.TYPE;
var IDENT$1 = TYPE$5.Ident;
var STRING = TYPE$5.String;
var NUMBER$1 = TYPE$5.Number;
var FUNCTION$1 = TYPE$5.Function;
var URL$2 = TYPE$5.Url;
var HASH$1 = TYPE$5.Hash;
var DIMENSION = TYPE$5.Dimension;
var PERCENTAGE$1 = TYPE$5.Percentage;
var LEFTPARENTHESIS = TYPE$5.LeftParenthesis;
var LEFTSQUAREBRACKET = TYPE$5.LeftSquareBracket;
var COMMA = TYPE$5.Comma;
var DELIM = TYPE$5.Delim;
var NUMBERSIGN$1 = 35;
var ASTERISK = 42;
var PLUSSIGN = 43;
var HYPHENMINUS = 45;
var SOLIDUS = 47;
var U = 117;
var _default = function defaultRecognizer(context2) {
  switch (this.scanner.tokenType) {
    case HASH$1:
      return this.Hash();
    case COMMA:
      context2.space = null;
      context2.ignoreWSAfter = true;
      return this.Operator();
    case LEFTPARENTHESIS:
      return this.Parentheses(this.readSequence, context2.recognizer);
    case LEFTSQUAREBRACKET:
      return this.Brackets(this.readSequence, context2.recognizer);
    case STRING:
      return this.String();
    case DIMENSION:
      return this.Dimension();
    case PERCENTAGE$1:
      return this.Percentage();
    case NUMBER$1:
      return this.Number();
    case FUNCTION$1:
      return cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context2.recognizer);
    case URL$2:
      return this.Url();
    case IDENT$1:
      if (cmpChar$1(this.scanner.source, this.scanner.tokenStart, U) && cmpChar$1(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN)) {
        return this.UnicodeRange();
      } else {
        return this.Identifier();
      }
    case DELIM:
      var code2 = this.scanner.source.charCodeAt(this.scanner.tokenStart);
      if (code2 === SOLIDUS || code2 === ASTERISK || code2 === PLUSSIGN || code2 === HYPHENMINUS) {
        return this.Operator();
      }
      if (code2 === NUMBERSIGN$1) {
        this.error("Hex or identifier is expected", this.scanner.tokenStart + 1);
      }
      break;
  }
};
var atrulePrelude = {
  getNode: _default
};
var TYPE$6 = tokenizer2.TYPE;
var DELIM$1 = TYPE$6.Delim;
var IDENT$2 = TYPE$6.Ident;
var DIMENSION$1 = TYPE$6.Dimension;
var PERCENTAGE$2 = TYPE$6.Percentage;
var NUMBER$2 = TYPE$6.Number;
var HASH$2 = TYPE$6.Hash;
var COLON = TYPE$6.Colon;
var LEFTSQUAREBRACKET$1 = TYPE$6.LeftSquareBracket;
var NUMBERSIGN$2 = 35;
var ASTERISK$1 = 42;
var PLUSSIGN$1 = 43;
var SOLIDUS$1 = 47;
var FULLSTOP = 46;
var GREATERTHANSIGN = 62;
var VERTICALLINE = 124;
var TILDE = 126;
function getNode(context2) {
  switch (this.scanner.tokenType) {
    case LEFTSQUAREBRACKET$1:
      return this.AttributeSelector();
    case HASH$2:
      return this.IdSelector();
    case COLON:
      if (this.scanner.lookupType(1) === COLON) {
        return this.PseudoElementSelector();
      } else {
        return this.PseudoClassSelector();
      }
    case IDENT$2:
      return this.TypeSelector();
    case NUMBER$2:
    case PERCENTAGE$2:
      return this.Percentage();
    case DIMENSION$1:
      if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP) {
        this.error("Identifier is expected", this.scanner.tokenStart + 1);
      }
      break;
    case DELIM$1:
      var code2 = this.scanner.source.charCodeAt(this.scanner.tokenStart);
      switch (code2) {
        case PLUSSIGN$1:
        case GREATERTHANSIGN:
        case TILDE:
          context2.space = null;
          context2.ignoreWSAfter = true;
          return this.Combinator();
        case SOLIDUS$1:
          return this.Combinator();
        case FULLSTOP:
          return this.ClassSelector();
        case ASTERISK$1:
        case VERTICALLINE:
          return this.TypeSelector();
        case NUMBERSIGN$2:
          return this.IdSelector();
      }
      break;
  }
}
var selector = {
  getNode
};
var expression = function() {
  return this.createSingleNodeList(
    this.Raw(this.scanner.tokenIndex, null, false)
  );
};
var TYPE$7 = tokenizer2.TYPE;
var WhiteSpace = TYPE$7.WhiteSpace;
var Semicolon = TYPE$7.Semicolon;
var LeftCurlyBracket = TYPE$7.LeftCurlyBracket;
var Delim = TYPE$7.Delim;
var EXCLAMATIONMARK = 33;
function getOffsetExcludeWS() {
  if (this.scanner.tokenIndex > 0) {
    if (this.scanner.lookupType(-1) === WhiteSpace) {
      return this.scanner.tokenIndex > 1 ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1) : this.scanner.firstCharOffset;
    }
  }
  return this.scanner.tokenStart;
}
function balanceEnd() {
  return 0;
}
function leftCurlyBracket(tokenType) {
  return tokenType === LeftCurlyBracket ? 1 : 0;
}
function leftCurlyBracketOrSemicolon(tokenType) {
  return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
}
function exclamationMarkOrSemicolon(tokenType, source, offset2) {
  if (tokenType === Delim && source.charCodeAt(offset2) === EXCLAMATIONMARK) {
    return 1;
  }
  return tokenType === Semicolon ? 1 : 0;
}
function semicolonIncluded(tokenType) {
  return tokenType === Semicolon ? 2 : 0;
}
var Raw = {
  name: "Raw",
  structure: {
    value: String
  },
  parse: function(startToken, mode, excludeWhiteSpace) {
    var startOffset = this.scanner.getTokenStart(startToken);
    var endOffset;
    this.scanner.skip(
      this.scanner.getRawLength(startToken, mode || balanceEnd)
    );
    if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
      endOffset = getOffsetExcludeWS.call(this);
    } else {
      endOffset = this.scanner.tokenStart;
    }
    return {
      type: "Raw",
      loc: this.getLocation(startOffset, endOffset),
      value: this.scanner.source.substring(startOffset, endOffset)
    };
  },
  generate: function(node2) {
    this.chunk(node2.value);
  },
  mode: {
    default: balanceEnd,
    leftCurlyBracket,
    leftCurlyBracketOrSemicolon,
    exclamationMarkOrSemicolon,
    semicolonIncluded
  }
};
var TYPE$8 = tokenizer2.TYPE;
var rawMode = Raw.mode;
var COMMA$1 = TYPE$8.Comma;
var WHITESPACE$3 = TYPE$8.WhiteSpace;
var _var = function() {
  var children = this.createList();
  this.scanner.skipSC();
  children.push(this.Identifier());
  this.scanner.skipSC();
  if (this.scanner.tokenType === COMMA$1) {
    children.push(this.Operator());
    const startIndex = this.scanner.tokenIndex;
    const value2 = this.parseCustomProperty ? this.Value(null) : this.Raw(this.scanner.tokenIndex, rawMode.exclamationMarkOrSemicolon, false);
    if (value2.type === "Value" && value2.children.isEmpty()) {
      for (let offset2 = startIndex - this.scanner.tokenIndex; offset2 <= 0; offset2++) {
        if (this.scanner.lookupType(offset2) === WHITESPACE$3) {
          value2.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " "
          });
          break;
        }
      }
    }
    children.push(value2);
  }
  return children;
};
var value = {
  getNode: _default,
  "expression": expression,
  "var": _var
};
var scope = {
  AtrulePrelude: atrulePrelude,
  Selector: selector,
  Value: value
};
var fontFace = {
  parse: {
    prelude: null,
    block: function() {
      return this.Block(true);
    }
  }
};
var TYPE$9 = tokenizer2.TYPE;
var STRING$1 = TYPE$9.String;
var IDENT$3 = TYPE$9.Ident;
var URL$3 = TYPE$9.Url;
var FUNCTION$2 = TYPE$9.Function;
var LEFTPARENTHESIS$1 = TYPE$9.LeftParenthesis;
var _import = {
  parse: {
    prelude: function() {
      var children = this.createList();
      this.scanner.skipSC();
      switch (this.scanner.tokenType) {
        case STRING$1:
          children.push(this.String());
          break;
        case URL$3:
        case FUNCTION$2:
          children.push(this.Url());
          break;
        default:
          this.error("String or url() is expected");
      }
      if (this.lookupNonWSType(0) === IDENT$3 || this.lookupNonWSType(0) === LEFTPARENTHESIS$1) {
        children.push(this.WhiteSpace());
        children.push(this.MediaQueryList());
      }
      return children;
    },
    block: null
  }
};
var media = {
  parse: {
    prelude: function() {
      return this.createSingleNodeList(
        this.MediaQueryList()
      );
    },
    block: function() {
      return this.Block(false);
    }
  }
};
var page = {
  parse: {
    prelude: function() {
      return this.createSingleNodeList(
        this.SelectorList()
      );
    },
    block: function() {
      return this.Block(true);
    }
  }
};
var TYPE$a = tokenizer2.TYPE;
var WHITESPACE$4 = TYPE$a.WhiteSpace;
var COMMENT$3 = TYPE$a.Comment;
var IDENT$4 = TYPE$a.Ident;
var FUNCTION$3 = TYPE$a.Function;
var COLON$1 = TYPE$a.Colon;
var LEFTPARENTHESIS$2 = TYPE$a.LeftParenthesis;
function consumeRaw() {
  return this.createSingleNodeList(
    this.Raw(this.scanner.tokenIndex, null, false)
  );
}
function parentheses() {
  this.scanner.skipSC();
  if (this.scanner.tokenType === IDENT$4 && this.lookupNonWSType(1) === COLON$1) {
    return this.createSingleNodeList(
      this.Declaration()
    );
  }
  return readSequence2.call(this);
}
function readSequence2() {
  var children = this.createList();
  var space2 = null;
  var child;
  this.scanner.skipSC();
  scan:
    while (!this.scanner.eof) {
      switch (this.scanner.tokenType) {
        case WHITESPACE$4:
          space2 = this.WhiteSpace();
          continue;
        case COMMENT$3:
          this.scanner.next();
          continue;
        case FUNCTION$3:
          child = this.Function(consumeRaw, this.scope.AtrulePrelude);
          break;
        case IDENT$4:
          child = this.Identifier();
          break;
        case LEFTPARENTHESIS$2:
          child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
          break;
        default:
          break scan;
      }
      if (space2 !== null) {
        children.push(space2);
        space2 = null;
      }
      children.push(child);
    }
  return children;
}
var supports = {
  parse: {
    prelude: function() {
      var children = readSequence2.call(this);
      if (this.getFirstListNode(children) === null) {
        this.error("Condition is expected");
      }
      return children;
    },
    block: function() {
      return this.Block(false);
    }
  }
};
var atrule = {
  "font-face": fontFace,
  "import": _import,
  "media": media,
  "page": page,
  "supports": supports
};
var dir = {
  parse: function() {
    return this.createSingleNodeList(
      this.Identifier()
    );
  }
};
var has = {
  parse: function() {
    return this.createSingleNodeList(
      this.SelectorList()
    );
  }
};
var lang = {
  parse: function() {
    return this.createSingleNodeList(
      this.Identifier()
    );
  }
};
var selectorList = {
  parse: function selectorList2() {
    return this.createSingleNodeList(
      this.SelectorList()
    );
  }
};
var matches = selectorList;
var not = selectorList;
var ALLOW_OF_CLAUSE = true;
var nthWithOfClause = {
  parse: function nthWithOfClause2() {
    return this.createSingleNodeList(
      this.Nth(ALLOW_OF_CLAUSE)
    );
  }
};
var nthChild = nthWithOfClause;
var nthLastChild = nthWithOfClause;
var DISALLOW_OF_CLAUSE = false;
var nth = {
  parse: function nth2() {
    return this.createSingleNodeList(
      this.Nth(DISALLOW_OF_CLAUSE)
    );
  }
};
var nthLastOfType = nth;
var nthOfType = nth;
var slotted = {
  parse: function compoundSelector() {
    return this.createSingleNodeList(
      this.Selector()
    );
  }
};
var pseudo = {
  "dir": dir,
  "has": has,
  "lang": lang,
  "matches": matches,
  "not": not,
  "nth-child": nthChild,
  "nth-last-child": nthLastChild,
  "nth-last-of-type": nthLastOfType,
  "nth-of-type": nthOfType,
  "slotted": slotted
};
var cmpChar$2 = tokenizer2.cmpChar;
var isDigit$2 = tokenizer2.isDigit;
var TYPE$b = tokenizer2.TYPE;
var WHITESPACE$5 = TYPE$b.WhiteSpace;
var COMMENT$4 = TYPE$b.Comment;
var IDENT$5 = TYPE$b.Ident;
var NUMBER$3 = TYPE$b.Number;
var DIMENSION$2 = TYPE$b.Dimension;
var PLUSSIGN$2 = 43;
var HYPHENMINUS$1 = 45;
var N$1 = 110;
var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;
function checkInteger(offset2, disallowSign) {
  var pos = this.scanner.tokenStart + offset2;
  var code2 = this.scanner.source.charCodeAt(pos);
  if (code2 === PLUSSIGN$2 || code2 === HYPHENMINUS$1) {
    if (disallowSign) {
      this.error("Number sign is not allowed");
    }
    pos++;
  }
  for (; pos < this.scanner.tokenEnd; pos++) {
    if (!isDigit$2(this.scanner.source.charCodeAt(pos))) {
      this.error("Integer is expected", pos);
    }
  }
}
function checkTokenIsInteger(disallowSign) {
  return checkInteger.call(this, 0, disallowSign);
}
function expectCharCode(offset2, code2) {
  if (!cmpChar$2(this.scanner.source, this.scanner.tokenStart + offset2, code2)) {
    var msg = "";
    switch (code2) {
      case N$1:
        msg = "N is expected";
        break;
      case HYPHENMINUS$1:
        msg = "HyphenMinus is expected";
        break;
    }
    this.error(msg, this.scanner.tokenStart + offset2);
  }
}
function consumeB() {
  var offset2 = 0;
  var sign = 0;
  var type2 = this.scanner.tokenType;
  while (type2 === WHITESPACE$5 || type2 === COMMENT$4) {
    type2 = this.scanner.lookupType(++offset2);
  }
  if (type2 !== NUMBER$3) {
    if (this.scanner.isDelim(PLUSSIGN$2, offset2) || this.scanner.isDelim(HYPHENMINUS$1, offset2)) {
      sign = this.scanner.isDelim(PLUSSIGN$2, offset2) ? PLUSSIGN$2 : HYPHENMINUS$1;
      do {
        type2 = this.scanner.lookupType(++offset2);
      } while (type2 === WHITESPACE$5 || type2 === COMMENT$4);
      if (type2 !== NUMBER$3) {
        this.scanner.skip(offset2);
        checkTokenIsInteger.call(this, DISALLOW_SIGN);
      }
    } else {
      return null;
    }
  }
  if (offset2 > 0) {
    this.scanner.skip(offset2);
  }
  if (sign === 0) {
    type2 = this.scanner.source.charCodeAt(this.scanner.tokenStart);
    if (type2 !== PLUSSIGN$2 && type2 !== HYPHENMINUS$1) {
      this.error("Number sign is expected");
    }
  }
  checkTokenIsInteger.call(this, sign !== 0);
  return sign === HYPHENMINUS$1 ? "-" + this.consume(NUMBER$3) : this.consume(NUMBER$3);
}
var AnPlusB = {
  name: "AnPlusB",
  structure: {
    a: [String, null],
    b: [String, null]
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    var a = null;
    var b = null;
    if (this.scanner.tokenType === NUMBER$3) {
      checkTokenIsInteger.call(this, ALLOW_SIGN);
      b = this.consume(NUMBER$3);
    } else if (this.scanner.tokenType === IDENT$5 && cmpChar$2(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$1)) {
      a = "-1";
      expectCharCode.call(this, 1, N$1);
      switch (this.scanner.getTokenLength()) {
        case 2:
          this.scanner.next();
          b = consumeB.call(this);
          break;
        case 3:
          expectCharCode.call(this, 2, HYPHENMINUS$1);
          this.scanner.next();
          this.scanner.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b = "-" + this.consume(NUMBER$3);
          break;
        default:
          expectCharCode.call(this, 2, HYPHENMINUS$1);
          checkInteger.call(this, 3, DISALLOW_SIGN);
          this.scanner.next();
          b = this.scanner.substrToCursor(start2 + 2);
      }
    } else if (this.scanner.tokenType === IDENT$5 || this.scanner.isDelim(PLUSSIGN$2) && this.scanner.lookupType(1) === IDENT$5) {
      var sign = 0;
      a = "1";
      if (this.scanner.isDelim(PLUSSIGN$2)) {
        sign = 1;
        this.scanner.next();
      }
      expectCharCode.call(this, 0, N$1);
      switch (this.scanner.getTokenLength()) {
        case 1:
          this.scanner.next();
          b = consumeB.call(this);
          break;
        case 2:
          expectCharCode.call(this, 1, HYPHENMINUS$1);
          this.scanner.next();
          this.scanner.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b = "-" + this.consume(NUMBER$3);
          break;
        default:
          expectCharCode.call(this, 1, HYPHENMINUS$1);
          checkInteger.call(this, 2, DISALLOW_SIGN);
          this.scanner.next();
          b = this.scanner.substrToCursor(start2 + sign + 1);
      }
    } else if (this.scanner.tokenType === DIMENSION$2) {
      var code2 = this.scanner.source.charCodeAt(this.scanner.tokenStart);
      var sign = code2 === PLUSSIGN$2 || code2 === HYPHENMINUS$1;
      for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
        if (!isDigit$2(this.scanner.source.charCodeAt(i))) {
          break;
        }
      }
      if (i === this.scanner.tokenStart + sign) {
        this.error("Integer is expected", this.scanner.tokenStart + sign);
      }
      expectCharCode.call(this, i - this.scanner.tokenStart, N$1);
      a = this.scanner.source.substring(start2, i);
      if (i + 1 === this.scanner.tokenEnd) {
        this.scanner.next();
        b = consumeB.call(this);
      } else {
        expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$1);
        if (i + 2 === this.scanner.tokenEnd) {
          this.scanner.next();
          this.scanner.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b = "-" + this.consume(NUMBER$3);
        } else {
          checkInteger.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN);
          this.scanner.next();
          b = this.scanner.substrToCursor(i + 1);
        }
      }
    } else {
      this.error();
    }
    if (a !== null && a.charCodeAt(0) === PLUSSIGN$2) {
      a = a.substr(1);
    }
    if (b !== null && b.charCodeAt(0) === PLUSSIGN$2) {
      b = b.substr(1);
    }
    return {
      type: "AnPlusB",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      a,
      b
    };
  },
  generate: function(node2) {
    var a = node2.a !== null && node2.a !== void 0;
    var b = node2.b !== null && node2.b !== void 0;
    if (a) {
      this.chunk(
        node2.a === "+1" ? "+n" : node2.a === "1" ? "n" : node2.a === "-1" ? "-n" : node2.a + "n"
      );
      if (b) {
        b = String(node2.b);
        if (b.charAt(0) === "-" || b.charAt(0) === "+") {
          this.chunk(b.charAt(0));
          this.chunk(b.substr(1));
        } else {
          this.chunk("+");
          this.chunk(b);
        }
      }
    } else {
      this.chunk(String(node2.b));
    }
  }
};
var TYPE$c = tokenizer2.TYPE;
var rawMode$1 = Raw.mode;
var ATKEYWORD = TYPE$c.AtKeyword;
var SEMICOLON = TYPE$c.Semicolon;
var LEFTCURLYBRACKET = TYPE$c.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE$c.RightCurlyBracket;
function consumeRaw$1(startToken) {
  return this.Raw(startToken, rawMode$1.leftCurlyBracketOrSemicolon, true);
}
function isDeclarationBlockAtrule() {
  for (var offset2 = 1, type2; type2 = this.scanner.lookupType(offset2); offset2++) {
    if (type2 === RIGHTCURLYBRACKET) {
      return true;
    }
    if (type2 === LEFTCURLYBRACKET || type2 === ATKEYWORD) {
      return false;
    }
  }
  return false;
}
var Atrule = {
  name: "Atrule",
  structure: {
    name: String,
    prelude: ["AtrulePrelude", "Raw", null],
    block: ["Block", null]
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    var name2;
    var nameLowerCase;
    var prelude = null;
    var block2 = null;
    this.eat(ATKEYWORD);
    name2 = this.scanner.substrToCursor(start2 + 1);
    nameLowerCase = name2.toLowerCase();
    this.scanner.skipSC();
    if (this.scanner.eof === false && this.scanner.tokenType !== LEFTCURLYBRACKET && this.scanner.tokenType !== SEMICOLON) {
      if (this.parseAtrulePrelude) {
        prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name2), consumeRaw$1);
        if (prelude.type === "AtrulePrelude" && prelude.children.head === null) {
          prelude = null;
        }
      } else {
        prelude = consumeRaw$1.call(this, this.scanner.tokenIndex);
      }
      this.scanner.skipSC();
    }
    switch (this.scanner.tokenType) {
      case SEMICOLON:
        this.scanner.next();
        break;
      case LEFTCURLYBRACKET:
        if (this.atrule.hasOwnProperty(nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
          block2 = this.atrule[nameLowerCase].block.call(this);
        } else {
          block2 = this.Block(isDeclarationBlockAtrule.call(this));
        }
        break;
    }
    return {
      type: "Atrule",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      name: name2,
      prelude,
      block: block2
    };
  },
  generate: function(node2) {
    this.chunk("@");
    this.chunk(node2.name);
    if (node2.prelude !== null) {
      this.chunk(" ");
      this.node(node2.prelude);
    }
    if (node2.block) {
      this.node(node2.block);
    } else {
      this.chunk(";");
    }
  },
  walkContext: "atrule"
};
var TYPE$d = tokenizer2.TYPE;
var SEMICOLON$1 = TYPE$d.Semicolon;
var LEFTCURLYBRACKET$1 = TYPE$d.LeftCurlyBracket;
var AtrulePrelude = {
  name: "AtrulePrelude",
  structure: {
    children: [[]]
  },
  parse: function(name2) {
    var children = null;
    if (name2 !== null) {
      name2 = name2.toLowerCase();
    }
    this.scanner.skipSC();
    if (this.atrule.hasOwnProperty(name2) && typeof this.atrule[name2].prelude === "function") {
      children = this.atrule[name2].prelude.call(this);
    } else {
      children = this.readSequence(this.scope.AtrulePrelude);
    }
    this.scanner.skipSC();
    if (this.scanner.eof !== true && this.scanner.tokenType !== LEFTCURLYBRACKET$1 && this.scanner.tokenType !== SEMICOLON$1) {
      this.error("Semicolon or block is expected");
    }
    if (children === null) {
      children = this.createList();
    }
    return {
      type: "AtrulePrelude",
      loc: this.getLocationFromList(children),
      children
    };
  },
  generate: function(node2) {
    this.children(node2);
  },
  walkContext: "atrulePrelude"
};
var TYPE$e = tokenizer2.TYPE;
var IDENT$6 = TYPE$e.Ident;
var STRING$2 = TYPE$e.String;
var COLON$2 = TYPE$e.Colon;
var LEFTSQUAREBRACKET$2 = TYPE$e.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE$e.RightSquareBracket;
var DOLLARSIGN = 36;
var ASTERISK$2 = 42;
var EQUALSSIGN = 61;
var CIRCUMFLEXACCENT = 94;
var VERTICALLINE$1 = 124;
var TILDE$1 = 126;
function getAttributeName() {
  if (this.scanner.eof) {
    this.error("Unexpected end of input");
  }
  var start2 = this.scanner.tokenStart;
  var expectIdent = false;
  var checkColon = true;
  if (this.scanner.isDelim(ASTERISK$2)) {
    expectIdent = true;
    checkColon = false;
    this.scanner.next();
  } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
    this.eat(IDENT$6);
  }
  if (this.scanner.isDelim(VERTICALLINE$1)) {
    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
      this.scanner.next();
      this.eat(IDENT$6);
    } else if (expectIdent) {
      this.error("Identifier is expected", this.scanner.tokenEnd);
    }
  } else if (expectIdent) {
    this.error("Vertical line is expected");
  }
  if (checkColon && this.scanner.tokenType === COLON$2) {
    this.scanner.next();
    this.eat(IDENT$6);
  }
  return {
    type: "Identifier",
    loc: this.getLocation(start2, this.scanner.tokenStart),
    name: this.scanner.substrToCursor(start2)
  };
}
function getOperator() {
  var start2 = this.scanner.tokenStart;
  var code2 = this.scanner.source.charCodeAt(start2);
  if (code2 !== EQUALSSIGN && code2 !== TILDE$1 && code2 !== CIRCUMFLEXACCENT && code2 !== DOLLARSIGN && code2 !== ASTERISK$2 && code2 !== VERTICALLINE$1) {
    this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
  }
  this.scanner.next();
  if (code2 !== EQUALSSIGN) {
    if (!this.scanner.isDelim(EQUALSSIGN)) {
      this.error("Equal sign is expected");
    }
    this.scanner.next();
  }
  return this.scanner.substrToCursor(start2);
}
var AttributeSelector = {
  name: "AttributeSelector",
  structure: {
    name: "Identifier",
    matcher: [String, null],
    value: ["String", "Identifier", null],
    flags: [String, null]
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    var name2;
    var matcher = null;
    var value2 = null;
    var flags = null;
    this.eat(LEFTSQUAREBRACKET$2);
    this.scanner.skipSC();
    name2 = getAttributeName.call(this);
    this.scanner.skipSC();
    if (this.scanner.tokenType !== RIGHTSQUAREBRACKET) {
      if (this.scanner.tokenType !== IDENT$6) {
        matcher = getOperator.call(this);
        this.scanner.skipSC();
        value2 = this.scanner.tokenType === STRING$2 ? this.String() : this.Identifier();
        this.scanner.skipSC();
      }
      if (this.scanner.tokenType === IDENT$6) {
        flags = this.scanner.getTokenValue();
        this.scanner.next();
        this.scanner.skipSC();
      }
    }
    this.eat(RIGHTSQUAREBRACKET);
    return {
      type: "AttributeSelector",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      name: name2,
      matcher,
      value: value2,
      flags
    };
  },
  generate: function(node2) {
    var flagsPrefix = " ";
    this.chunk("[");
    this.node(node2.name);
    if (node2.matcher !== null) {
      this.chunk(node2.matcher);
      if (node2.value !== null) {
        this.node(node2.value);
        if (node2.value.type === "String") {
          flagsPrefix = "";
        }
      }
    }
    if (node2.flags !== null) {
      this.chunk(flagsPrefix);
      this.chunk(node2.flags);
    }
    this.chunk("]");
  }
};
var TYPE$f = tokenizer2.TYPE;
var rawMode$2 = Raw.mode;
var WHITESPACE$6 = TYPE$f.WhiteSpace;
var COMMENT$5 = TYPE$f.Comment;
var SEMICOLON$2 = TYPE$f.Semicolon;
var ATKEYWORD$1 = TYPE$f.AtKeyword;
var LEFTCURLYBRACKET$2 = TYPE$f.LeftCurlyBracket;
var RIGHTCURLYBRACKET$1 = TYPE$f.RightCurlyBracket;
function consumeRaw$2(startToken) {
  return this.Raw(startToken, null, true);
}
function consumeRule() {
  return this.parseWithFallback(this.Rule, consumeRaw$2);
}
function consumeRawDeclaration(startToken) {
  return this.Raw(startToken, rawMode$2.semicolonIncluded, true);
}
function consumeDeclaration() {
  if (this.scanner.tokenType === SEMICOLON$2) {
    return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
  }
  var node2 = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
  if (this.scanner.tokenType === SEMICOLON$2) {
    this.scanner.next();
  }
  return node2;
}
var Block = {
  name: "Block",
  structure: {
    children: [[
      "Atrule",
      "Rule",
      "Declaration"
    ]]
  },
  parse: function(isDeclaration) {
    var consumer = isDeclaration ? consumeDeclaration : consumeRule;
    var start2 = this.scanner.tokenStart;
    var children = this.createList();
    this.eat(LEFTCURLYBRACKET$2);
    scan:
      while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
          case RIGHTCURLYBRACKET$1:
            break scan;
          case WHITESPACE$6:
          case COMMENT$5:
            this.scanner.next();
            break;
          case ATKEYWORD$1:
            children.push(this.parseWithFallback(this.Atrule, consumeRaw$2));
            break;
          default:
            children.push(consumer.call(this));
        }
      }
    if (!this.scanner.eof) {
      this.eat(RIGHTCURLYBRACKET$1);
    }
    return {
      type: "Block",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      children
    };
  },
  generate: function(node2) {
    this.chunk("{");
    this.children(node2, function(prev) {
      if (prev.type === "Declaration") {
        this.chunk(";");
      }
    });
    this.chunk("}");
  },
  walkContext: "block"
};
var TYPE$g = tokenizer2.TYPE;
var LEFTSQUAREBRACKET$3 = TYPE$g.LeftSquareBracket;
var RIGHTSQUAREBRACKET$1 = TYPE$g.RightSquareBracket;
var Brackets = {
  name: "Brackets",
  structure: {
    children: [[]]
  },
  parse: function(readSequence3, recognizer) {
    var start2 = this.scanner.tokenStart;
    var children = null;
    this.eat(LEFTSQUAREBRACKET$3);
    children = readSequence3.call(this, recognizer);
    if (!this.scanner.eof) {
      this.eat(RIGHTSQUAREBRACKET$1);
    }
    return {
      type: "Brackets",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      children
    };
  },
  generate: function(node2) {
    this.chunk("[");
    this.children(node2);
    this.chunk("]");
  }
};
var CDC = tokenizer2.TYPE.CDC;
var CDC_1 = {
  name: "CDC",
  structure: [],
  parse: function() {
    var start2 = this.scanner.tokenStart;
    this.eat(CDC);
    return {
      type: "CDC",
      loc: this.getLocation(start2, this.scanner.tokenStart)
    };
  },
  generate: function() {
    this.chunk("-->");
  }
};
var CDO = tokenizer2.TYPE.CDO;
var CDO_1 = {
  name: "CDO",
  structure: [],
  parse: function() {
    var start2 = this.scanner.tokenStart;
    this.eat(CDO);
    return {
      type: "CDO",
      loc: this.getLocation(start2, this.scanner.tokenStart)
    };
  },
  generate: function() {
    this.chunk("<!--");
  }
};
var TYPE$h = tokenizer2.TYPE;
var IDENT$7 = TYPE$h.Ident;
var FULLSTOP$1 = 46;
var ClassSelector = {
  name: "ClassSelector",
  structure: {
    name: String
  },
  parse: function() {
    if (!this.scanner.isDelim(FULLSTOP$1)) {
      this.error("Full stop is expected");
    }
    this.scanner.next();
    return {
      type: "ClassSelector",
      loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
      name: this.consume(IDENT$7)
    };
  },
  generate: function(node2) {
    this.chunk(".");
    this.chunk(node2.name);
  }
};
var TYPE$i = tokenizer2.TYPE;
var IDENT$8 = TYPE$i.Ident;
var PLUSSIGN$3 = 43;
var SOLIDUS$2 = 47;
var GREATERTHANSIGN$1 = 62;
var TILDE$2 = 126;
var Combinator = {
  name: "Combinator",
  structure: {
    name: String
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    var code2 = this.scanner.source.charCodeAt(this.scanner.tokenStart);
    switch (code2) {
      case GREATERTHANSIGN$1:
      case PLUSSIGN$3:
      case TILDE$2:
        this.scanner.next();
        break;
      case SOLIDUS$2:
        this.scanner.next();
        if (this.scanner.tokenType !== IDENT$8 || this.scanner.lookupValue(0, "deep") === false) {
          this.error("Identifier `deep` is expected");
        }
        this.scanner.next();
        if (!this.scanner.isDelim(SOLIDUS$2)) {
          this.error("Solidus is expected");
        }
        this.scanner.next();
        break;
      default:
        this.error("Combinator is expected");
    }
    return {
      type: "Combinator",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      name: this.scanner.substrToCursor(start2)
    };
  },
  generate: function(node2) {
    this.chunk(node2.name);
  }
};
var TYPE$j = tokenizer2.TYPE;
var COMMENT$6 = TYPE$j.Comment;
var ASTERISK$3 = 42;
var SOLIDUS$3 = 47;
var Comment = {
  name: "Comment",
  structure: {
    value: String
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    var end2 = this.scanner.tokenEnd;
    this.eat(COMMENT$6);
    if (end2 - start2 + 2 >= 2 && this.scanner.source.charCodeAt(end2 - 2) === ASTERISK$3 && this.scanner.source.charCodeAt(end2 - 1) === SOLIDUS$3) {
      end2 -= 2;
    }
    return {
      type: "Comment",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      value: this.scanner.source.substring(start2 + 2, end2)
    };
  },
  generate: function(node2) {
    this.chunk("/*");
    this.chunk(node2.value);
    this.chunk("*/");
  }
};
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var keywords$2 = /* @__PURE__ */ Object.create(null);
var properties = /* @__PURE__ */ Object.create(null);
var HYPHENMINUS$2 = 45;
function isCustomProperty(str2, offset2) {
  offset2 = offset2 || 0;
  return str2.length - offset2 >= 2 && str2.charCodeAt(offset2) === HYPHENMINUS$2 && str2.charCodeAt(offset2 + 1) === HYPHENMINUS$2;
}
function getVendorPrefix(str2, offset2) {
  offset2 = offset2 || 0;
  if (str2.length - offset2 >= 3) {
    if (str2.charCodeAt(offset2) === HYPHENMINUS$2 && str2.charCodeAt(offset2 + 1) !== HYPHENMINUS$2) {
      var secondDashIndex = str2.indexOf("-", offset2 + 2);
      if (secondDashIndex !== -1) {
        return str2.substring(offset2, secondDashIndex + 1);
      }
    }
  }
  return "";
}
function getKeywordDescriptor(keyword) {
  if (hasOwnProperty$1.call(keywords$2, keyword)) {
    return keywords$2[keyword];
  }
  var name2 = keyword.toLowerCase();
  if (hasOwnProperty$1.call(keywords$2, name2)) {
    return keywords$2[keyword] = keywords$2[name2];
  }
  var custom = isCustomProperty(name2, 0);
  var vendor = !custom ? getVendorPrefix(name2, 0) : "";
  return keywords$2[keyword] = Object.freeze({
    basename: name2.substr(vendor.length),
    name: name2,
    vendor,
    prefix: vendor,
    custom
  });
}
function getPropertyDescriptor(property) {
  if (hasOwnProperty$1.call(properties, property)) {
    return properties[property];
  }
  var name2 = property;
  var hack = property[0];
  if (hack === "/") {
    hack = property[1] === "/" ? "//" : "/";
  } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
    hack = "";
  }
  var custom = isCustomProperty(name2, hack.length);
  if (!custom) {
    name2 = name2.toLowerCase();
    if (hasOwnProperty$1.call(properties, name2)) {
      return properties[property] = properties[name2];
    }
  }
  var vendor = !custom ? getVendorPrefix(name2, hack.length) : "";
  var prefix = name2.substr(0, hack.length + vendor.length);
  return properties[property] = Object.freeze({
    basename: name2.substr(prefix.length),
    name: name2.substr(hack.length),
    hack,
    vendor,
    prefix,
    custom
  });
}
var names = {
  keyword: getKeywordDescriptor,
  property: getPropertyDescriptor,
  isCustomProperty,
  vendorPrefix: getVendorPrefix
};
var isCustomProperty$1 = names.isCustomProperty;
var TYPE$k = tokenizer2.TYPE;
var rawMode$3 = Raw.mode;
var IDENT$9 = TYPE$k.Ident;
var HASH$3 = TYPE$k.Hash;
var COLON$3 = TYPE$k.Colon;
var SEMICOLON$3 = TYPE$k.Semicolon;
var DELIM$2 = TYPE$k.Delim;
var WHITESPACE$7 = TYPE$k.WhiteSpace;
var EXCLAMATIONMARK$1 = 33;
var NUMBERSIGN$3 = 35;
var DOLLARSIGN$1 = 36;
var AMPERSAND = 38;
var ASTERISK$4 = 42;
var PLUSSIGN$4 = 43;
var SOLIDUS$4 = 47;
function consumeValueRaw(startToken) {
  return this.Raw(startToken, rawMode$3.exclamationMarkOrSemicolon, true);
}
function consumeCustomPropertyRaw(startToken) {
  return this.Raw(startToken, rawMode$3.exclamationMarkOrSemicolon, false);
}
function consumeValue() {
  var startValueToken = this.scanner.tokenIndex;
  var value2 = this.Value();
  if (value2.type !== "Raw" && this.scanner.eof === false && this.scanner.tokenType !== SEMICOLON$3 && this.scanner.isDelim(EXCLAMATIONMARK$1) === false && this.scanner.isBalanceEdge(startValueToken) === false) {
    this.error();
  }
  return value2;
}
var Declaration = {
  name: "Declaration",
  structure: {
    important: [Boolean, String],
    property: String,
    value: ["Value", "Raw"]
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    var startToken = this.scanner.tokenIndex;
    var property = readProperty.call(this);
    var customProperty = isCustomProperty$1(property);
    var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
    var consumeRaw2 = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
    var important = false;
    var value2;
    this.scanner.skipSC();
    this.eat(COLON$3);
    const valueStart = this.scanner.tokenIndex;
    if (!customProperty) {
      this.scanner.skipSC();
    }
    if (parseValue) {
      value2 = this.parseWithFallback(consumeValue, consumeRaw2);
    } else {
      value2 = consumeRaw2.call(this, this.scanner.tokenIndex);
    }
    if (customProperty && value2.type === "Value" && value2.children.isEmpty()) {
      for (let offset2 = valueStart - this.scanner.tokenIndex; offset2 <= 0; offset2++) {
        if (this.scanner.lookupType(offset2) === WHITESPACE$7) {
          value2.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " "
          });
          break;
        }
      }
    }
    if (this.scanner.isDelim(EXCLAMATIONMARK$1)) {
      important = getImportant.call(this);
      this.scanner.skipSC();
    }
    if (this.scanner.eof === false && this.scanner.tokenType !== SEMICOLON$3 && this.scanner.isBalanceEdge(startToken) === false) {
      this.error();
    }
    return {
      type: "Declaration",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      important,
      property,
      value: value2
    };
  },
  generate: function(node2) {
    this.chunk(node2.property);
    this.chunk(":");
    this.node(node2.value);
    if (node2.important) {
      this.chunk(node2.important === true ? "!important" : "!" + node2.important);
    }
  },
  walkContext: "declaration"
};
function readProperty() {
  var start2 = this.scanner.tokenStart;
  if (this.scanner.tokenType === DELIM$2) {
    switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
      case ASTERISK$4:
      case DOLLARSIGN$1:
      case PLUSSIGN$4:
      case NUMBERSIGN$3:
      case AMPERSAND:
        this.scanner.next();
        break;
      case SOLIDUS$4:
        this.scanner.next();
        if (this.scanner.isDelim(SOLIDUS$4)) {
          this.scanner.next();
        }
        break;
    }
  }
  if (this.scanner.tokenType === HASH$3) {
    this.eat(HASH$3);
  } else {
    this.eat(IDENT$9);
  }
  return this.scanner.substrToCursor(start2);
}
function getImportant() {
  this.eat(DELIM$2);
  this.scanner.skipSC();
  var important = this.consume(IDENT$9);
  return important === "important" ? true : important;
}
var TYPE$l = tokenizer2.TYPE;
var rawMode$4 = Raw.mode;
var WHITESPACE$8 = TYPE$l.WhiteSpace;
var COMMENT$7 = TYPE$l.Comment;
var SEMICOLON$4 = TYPE$l.Semicolon;
function consumeRaw$3(startToken) {
  return this.Raw(startToken, rawMode$4.semicolonIncluded, true);
}
var DeclarationList = {
  name: "DeclarationList",
  structure: {
    children: [[
      "Declaration"
    ]]
  },
  parse: function() {
    var children = this.createList();
    while (!this.scanner.eof) {
      switch (this.scanner.tokenType) {
        case WHITESPACE$8:
        case COMMENT$7:
        case SEMICOLON$4:
          this.scanner.next();
          break;
        default:
          children.push(this.parseWithFallback(this.Declaration, consumeRaw$3));
      }
    }
    return {
      type: "DeclarationList",
      loc: this.getLocationFromList(children),
      children
    };
  },
  generate: function(node2) {
    this.children(node2, function(prev) {
      if (prev.type === "Declaration") {
        this.chunk(";");
      }
    });
  }
};
var consumeNumber$2 = utils.consumeNumber;
var TYPE$m = tokenizer2.TYPE;
var DIMENSION$3 = TYPE$m.Dimension;
var Dimension = {
  name: "Dimension",
  structure: {
    value: String,
    unit: String
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    var numberEnd = consumeNumber$2(this.scanner.source, start2);
    this.eat(DIMENSION$3);
    return {
      type: "Dimension",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      value: this.scanner.source.substring(start2, numberEnd),
      unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
    };
  },
  generate: function(node2) {
    this.chunk(node2.value);
    this.chunk(node2.unit);
  }
};
var TYPE$n = tokenizer2.TYPE;
var RIGHTPARENTHESIS = TYPE$n.RightParenthesis;
var _Function = {
  name: "Function",
  structure: {
    name: String,
    children: [[]]
  },
  parse: function(readSequence3, recognizer) {
    var start2 = this.scanner.tokenStart;
    var name2 = this.consumeFunctionName();
    var nameLowerCase = name2.toLowerCase();
    var children;
    children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence3.call(this, recognizer);
    if (!this.scanner.eof) {
      this.eat(RIGHTPARENTHESIS);
    }
    return {
      type: "Function",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      name: name2,
      children
    };
  },
  generate: function(node2) {
    this.chunk(node2.name);
    this.chunk("(");
    this.children(node2);
    this.chunk(")");
  },
  walkContext: "function"
};
var TYPE$o = tokenizer2.TYPE;
var HASH$4 = TYPE$o.Hash;
var Hash = {
  name: "Hash",
  structure: {
    value: String
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    this.eat(HASH$4);
    return {
      type: "Hash",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      value: this.scanner.substrToCursor(start2 + 1)
    };
  },
  generate: function(node2) {
    this.chunk("#");
    this.chunk(node2.value);
  }
};
var TYPE$p = tokenizer2.TYPE;
var IDENT$a = TYPE$p.Ident;
var Identifier = {
  name: "Identifier",
  structure: {
    name: String
  },
  parse: function() {
    return {
      type: "Identifier",
      loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
      name: this.consume(IDENT$a)
    };
  },
  generate: function(node2) {
    this.chunk(node2.name);
  }
};
var TYPE$q = tokenizer2.TYPE;
var HASH$5 = TYPE$q.Hash;
var IdSelector = {
  name: "IdSelector",
  structure: {
    name: String
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    this.eat(HASH$5);
    return {
      type: "IdSelector",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      name: this.scanner.substrToCursor(start2 + 1)
    };
  },
  generate: function(node2) {
    this.chunk("#");
    this.chunk(node2.name);
  }
};
var TYPE$r = tokenizer2.TYPE;
var IDENT$b = TYPE$r.Ident;
var NUMBER$4 = TYPE$r.Number;
var DIMENSION$4 = TYPE$r.Dimension;
var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;
var RIGHTPARENTHESIS$1 = TYPE$r.RightParenthesis;
var COLON$4 = TYPE$r.Colon;
var DELIM$3 = TYPE$r.Delim;
var MediaFeature = {
  name: "MediaFeature",
  structure: {
    name: String,
    value: ["Identifier", "Number", "Dimension", "Ratio", null]
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    var name2;
    var value2 = null;
    this.eat(LEFTPARENTHESIS$3);
    this.scanner.skipSC();
    name2 = this.consume(IDENT$b);
    this.scanner.skipSC();
    if (this.scanner.tokenType !== RIGHTPARENTHESIS$1) {
      this.eat(COLON$4);
      this.scanner.skipSC();
      switch (this.scanner.tokenType) {
        case NUMBER$4:
          if (this.lookupNonWSType(1) === DELIM$3) {
            value2 = this.Ratio();
          } else {
            value2 = this.Number();
          }
          break;
        case DIMENSION$4:
          value2 = this.Dimension();
          break;
        case IDENT$b:
          value2 = this.Identifier();
          break;
        default:
          this.error("Number, dimension, ratio or identifier is expected");
      }
      this.scanner.skipSC();
    }
    this.eat(RIGHTPARENTHESIS$1);
    return {
      type: "MediaFeature",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      name: name2,
      value: value2
    };
  },
  generate: function(node2) {
    this.chunk("(");
    this.chunk(node2.name);
    if (node2.value !== null) {
      this.chunk(":");
      this.node(node2.value);
    }
    this.chunk(")");
  }
};
var TYPE$s = tokenizer2.TYPE;
var WHITESPACE$9 = TYPE$s.WhiteSpace;
var COMMENT$8 = TYPE$s.Comment;
var IDENT$c = TYPE$s.Ident;
var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
var MediaQuery = {
  name: "MediaQuery",
  structure: {
    children: [[
      "Identifier",
      "MediaFeature",
      "WhiteSpace"
    ]]
  },
  parse: function() {
    this.scanner.skipSC();
    var children = this.createList();
    var child = null;
    var space2 = null;
    scan:
      while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
          case COMMENT$8:
            this.scanner.next();
            continue;
          case WHITESPACE$9:
            space2 = this.WhiteSpace();
            continue;
          case IDENT$c:
            child = this.Identifier();
            break;
          case LEFTPARENTHESIS$4:
            child = this.MediaFeature();
            break;
          default:
            break scan;
        }
        if (space2 !== null) {
          children.push(space2);
          space2 = null;
        }
        children.push(child);
      }
    if (child === null) {
      this.error("Identifier or parenthesis is expected");
    }
    return {
      type: "MediaQuery",
      loc: this.getLocationFromList(children),
      children
    };
  },
  generate: function(node2) {
    this.children(node2);
  }
};
var COMMA$2 = tokenizer2.TYPE.Comma;
var MediaQueryList = {
  name: "MediaQueryList",
  structure: {
    children: [[
      "MediaQuery"
    ]]
  },
  parse: function(relative) {
    var children = this.createList();
    this.scanner.skipSC();
    while (!this.scanner.eof) {
      children.push(this.MediaQuery(relative));
      if (this.scanner.tokenType !== COMMA$2) {
        break;
      }
      this.scanner.next();
    }
    return {
      type: "MediaQueryList",
      loc: this.getLocationFromList(children),
      children
    };
  },
  generate: function(node2) {
    this.children(node2, function() {
      this.chunk(",");
    });
  }
};
var Nth = {
  name: "Nth",
  structure: {
    nth: ["AnPlusB", "Identifier"],
    selector: ["SelectorList", null]
  },
  parse: function(allowOfClause) {
    this.scanner.skipSC();
    var start2 = this.scanner.tokenStart;
    var end2 = start2;
    var selector2 = null;
    var query;
    if (this.scanner.lookupValue(0, "odd") || this.scanner.lookupValue(0, "even")) {
      query = this.Identifier();
    } else {
      query = this.AnPlusB();
    }
    this.scanner.skipSC();
    if (allowOfClause && this.scanner.lookupValue(0, "of")) {
      this.scanner.next();
      selector2 = this.SelectorList();
      if (this.needPositions) {
        end2 = this.getLastListNode(selector2.children).loc.end.offset;
      }
    } else {
      if (this.needPositions) {
        end2 = query.loc.end.offset;
      }
    }
    return {
      type: "Nth",
      loc: this.getLocation(start2, end2),
      nth: query,
      selector: selector2
    };
  },
  generate: function(node2) {
    this.node(node2.nth);
    if (node2.selector !== null) {
      this.chunk(" of ");
      this.node(node2.selector);
    }
  }
};
var NUMBER$5 = tokenizer2.TYPE.Number;
var _Number = {
  name: "Number",
  structure: {
    value: String
  },
  parse: function() {
    return {
      type: "Number",
      loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
      value: this.consume(NUMBER$5)
    };
  },
  generate: function(node2) {
    this.chunk(node2.value);
  }
};
var Operator = {
  name: "Operator",
  structure: {
    value: String
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    this.scanner.next();
    return {
      type: "Operator",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      value: this.scanner.substrToCursor(start2)
    };
  },
  generate: function(node2) {
    this.chunk(node2.value);
  }
};
var TYPE$t = tokenizer2.TYPE;
var LEFTPARENTHESIS$5 = TYPE$t.LeftParenthesis;
var RIGHTPARENTHESIS$2 = TYPE$t.RightParenthesis;
var Parentheses = {
  name: "Parentheses",
  structure: {
    children: [[]]
  },
  parse: function(readSequence3, recognizer) {
    var start2 = this.scanner.tokenStart;
    var children = null;
    this.eat(LEFTPARENTHESIS$5);
    children = readSequence3.call(this, recognizer);
    if (!this.scanner.eof) {
      this.eat(RIGHTPARENTHESIS$2);
    }
    return {
      type: "Parentheses",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      children
    };
  },
  generate: function(node2) {
    this.chunk("(");
    this.children(node2);
    this.chunk(")");
  }
};
var consumeNumber$3 = utils.consumeNumber;
var TYPE$u = tokenizer2.TYPE;
var PERCENTAGE$3 = TYPE$u.Percentage;
var Percentage = {
  name: "Percentage",
  structure: {
    value: String
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    var numberEnd = consumeNumber$3(this.scanner.source, start2);
    this.eat(PERCENTAGE$3);
    return {
      type: "Percentage",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      value: this.scanner.source.substring(start2, numberEnd)
    };
  },
  generate: function(node2) {
    this.chunk(node2.value);
    this.chunk("%");
  }
};
var TYPE$v = tokenizer2.TYPE;
var IDENT$d = TYPE$v.Ident;
var FUNCTION$4 = TYPE$v.Function;
var COLON$5 = TYPE$v.Colon;
var RIGHTPARENTHESIS$3 = TYPE$v.RightParenthesis;
var PseudoClassSelector = {
  name: "PseudoClassSelector",
  structure: {
    name: String,
    children: [["Raw"], null]
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    var children = null;
    var name2;
    var nameLowerCase;
    this.eat(COLON$5);
    if (this.scanner.tokenType === FUNCTION$4) {
      name2 = this.consumeFunctionName();
      nameLowerCase = name2.toLowerCase();
      if (this.pseudo.hasOwnProperty(nameLowerCase)) {
        this.scanner.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.scanner.skipSC();
      } else {
        children = this.createList();
        children.push(
          this.Raw(this.scanner.tokenIndex, null, false)
        );
      }
      this.eat(RIGHTPARENTHESIS$3);
    } else {
      name2 = this.consume(IDENT$d);
    }
    return {
      type: "PseudoClassSelector",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      name: name2,
      children
    };
  },
  generate: function(node2) {
    this.chunk(":");
    this.chunk(node2.name);
    if (node2.children !== null) {
      this.chunk("(");
      this.children(node2);
      this.chunk(")");
    }
  },
  walkContext: "function"
};
var TYPE$w = tokenizer2.TYPE;
var IDENT$e = TYPE$w.Ident;
var FUNCTION$5 = TYPE$w.Function;
var COLON$6 = TYPE$w.Colon;
var RIGHTPARENTHESIS$4 = TYPE$w.RightParenthesis;
var PseudoElementSelector = {
  name: "PseudoElementSelector",
  structure: {
    name: String,
    children: [["Raw"], null]
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    var children = null;
    var name2;
    var nameLowerCase;
    this.eat(COLON$6);
    this.eat(COLON$6);
    if (this.scanner.tokenType === FUNCTION$5) {
      name2 = this.consumeFunctionName();
      nameLowerCase = name2.toLowerCase();
      if (this.pseudo.hasOwnProperty(nameLowerCase)) {
        this.scanner.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.scanner.skipSC();
      } else {
        children = this.createList();
        children.push(
          this.Raw(this.scanner.tokenIndex, null, false)
        );
      }
      this.eat(RIGHTPARENTHESIS$4);
    } else {
      name2 = this.consume(IDENT$e);
    }
    return {
      type: "PseudoElementSelector",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      name: name2,
      children
    };
  },
  generate: function(node2) {
    this.chunk("::");
    this.chunk(node2.name);
    if (node2.children !== null) {
      this.chunk("(");
      this.children(node2);
      this.chunk(")");
    }
  },
  walkContext: "function"
};
var isDigit$3 = tokenizer2.isDigit;
var TYPE$x = tokenizer2.TYPE;
var NUMBER$6 = TYPE$x.Number;
var DELIM$4 = TYPE$x.Delim;
var SOLIDUS$5 = 47;
var FULLSTOP$2 = 46;
function consumeNumber$4() {
  this.scanner.skipWS();
  var value2 = this.consume(NUMBER$6);
  for (var i = 0; i < value2.length; i++) {
    var code2 = value2.charCodeAt(i);
    if (!isDigit$3(code2) && code2 !== FULLSTOP$2) {
      this.error("Unsigned number is expected", this.scanner.tokenStart - value2.length + i);
    }
  }
  if (Number(value2) === 0) {
    this.error("Zero number is not allowed", this.scanner.tokenStart - value2.length);
  }
  return value2;
}
var Ratio = {
  name: "Ratio",
  structure: {
    left: String,
    right: String
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    var left2 = consumeNumber$4.call(this);
    var right2;
    this.scanner.skipWS();
    if (!this.scanner.isDelim(SOLIDUS$5)) {
      this.error("Solidus is expected");
    }
    this.eat(DELIM$4);
    right2 = consumeNumber$4.call(this);
    return {
      type: "Ratio",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      left: left2,
      right: right2
    };
  },
  generate: function(node2) {
    this.chunk(node2.left);
    this.chunk("/");
    this.chunk(node2.right);
  }
};
var TYPE$y = tokenizer2.TYPE;
var rawMode$5 = Raw.mode;
var LEFTCURLYBRACKET$3 = TYPE$y.LeftCurlyBracket;
function consumeRaw$4(startToken) {
  return this.Raw(startToken, rawMode$5.leftCurlyBracket, true);
}
function consumePrelude() {
  var prelude = this.SelectorList();
  if (prelude.type !== "Raw" && this.scanner.eof === false && this.scanner.tokenType !== LEFTCURLYBRACKET$3) {
    this.error();
  }
  return prelude;
}
var Rule = {
  name: "Rule",
  structure: {
    prelude: ["SelectorList", "Raw"],
    block: ["Block"]
  },
  parse: function() {
    var startToken = this.scanner.tokenIndex;
    var startOffset = this.scanner.tokenStart;
    var prelude;
    var block2;
    if (this.parseRulePrelude) {
      prelude = this.parseWithFallback(consumePrelude, consumeRaw$4);
    } else {
      prelude = consumeRaw$4.call(this, startToken);
    }
    block2 = this.Block(true);
    return {
      type: "Rule",
      loc: this.getLocation(startOffset, this.scanner.tokenStart),
      prelude,
      block: block2
    };
  },
  generate: function(node2) {
    this.node(node2.prelude);
    this.node(node2.block);
  },
  walkContext: "rule"
};
var Selector = {
  name: "Selector",
  structure: {
    children: [[
      "TypeSelector",
      "IdSelector",
      "ClassSelector",
      "AttributeSelector",
      "PseudoClassSelector",
      "PseudoElementSelector",
      "Combinator",
      "WhiteSpace"
    ]]
  },
  parse: function() {
    var children = this.readSequence(this.scope.Selector);
    if (this.getFirstListNode(children) === null) {
      this.error("Selector is expected");
    }
    return {
      type: "Selector",
      loc: this.getLocationFromList(children),
      children
    };
  },
  generate: function(node2) {
    this.children(node2);
  }
};
var TYPE$z = tokenizer2.TYPE;
var COMMA$3 = TYPE$z.Comma;
var SelectorList = {
  name: "SelectorList",
  structure: {
    children: [[
      "Selector",
      "Raw"
    ]]
  },
  parse: function() {
    var children = this.createList();
    while (!this.scanner.eof) {
      children.push(this.Selector());
      if (this.scanner.tokenType === COMMA$3) {
        this.scanner.next();
        continue;
      }
      break;
    }
    return {
      type: "SelectorList",
      loc: this.getLocationFromList(children),
      children
    };
  },
  generate: function(node2) {
    this.children(node2, function() {
      this.chunk(",");
    });
  },
  walkContext: "selector"
};
var STRING$3 = tokenizer2.TYPE.String;
var _String = {
  name: "String",
  structure: {
    value: String
  },
  parse: function() {
    return {
      type: "String",
      loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
      value: this.consume(STRING$3)
    };
  },
  generate: function(node2) {
    this.chunk(node2.value);
  }
};
var TYPE$A = tokenizer2.TYPE;
var WHITESPACE$a = TYPE$A.WhiteSpace;
var COMMENT$9 = TYPE$A.Comment;
var ATKEYWORD$2 = TYPE$A.AtKeyword;
var CDO$1 = TYPE$A.CDO;
var CDC$1 = TYPE$A.CDC;
var EXCLAMATIONMARK$2 = 33;
function consumeRaw$5(startToken) {
  return this.Raw(startToken, null, false);
}
var StyleSheet = {
  name: "StyleSheet",
  structure: {
    children: [[
      "Comment",
      "CDO",
      "CDC",
      "Atrule",
      "Rule",
      "Raw"
    ]]
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    var children = this.createList();
    var child;
    while (!this.scanner.eof) {
      switch (this.scanner.tokenType) {
        case WHITESPACE$a:
          this.scanner.next();
          continue;
        case COMMENT$9:
          if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$2) {
            this.scanner.next();
            continue;
          }
          child = this.Comment();
          break;
        case CDO$1:
          child = this.CDO();
          break;
        case CDC$1:
          child = this.CDC();
          break;
        case ATKEYWORD$2:
          child = this.parseWithFallback(this.Atrule, consumeRaw$5);
          break;
        default:
          child = this.parseWithFallback(this.Rule, consumeRaw$5);
      }
      children.push(child);
    }
    return {
      type: "StyleSheet",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      children
    };
  },
  generate: function(node2) {
    this.children(node2);
  },
  walkContext: "stylesheet"
};
var TYPE$B = tokenizer2.TYPE;
var IDENT$f = TYPE$B.Ident;
var ASTERISK$5 = 42;
var VERTICALLINE$2 = 124;
function eatIdentifierOrAsterisk() {
  if (this.scanner.tokenType !== IDENT$f && this.scanner.isDelim(ASTERISK$5) === false) {
    this.error("Identifier or asterisk is expected");
  }
  this.scanner.next();
}
var TypeSelector = {
  name: "TypeSelector",
  structure: {
    name: String
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    if (this.scanner.isDelim(VERTICALLINE$2)) {
      this.scanner.next();
      eatIdentifierOrAsterisk.call(this);
    } else {
      eatIdentifierOrAsterisk.call(this);
      if (this.scanner.isDelim(VERTICALLINE$2)) {
        this.scanner.next();
        eatIdentifierOrAsterisk.call(this);
      }
    }
    return {
      type: "TypeSelector",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      name: this.scanner.substrToCursor(start2)
    };
  },
  generate: function(node2) {
    this.chunk(node2.name);
  }
};
var isHexDigit$3 = tokenizer2.isHexDigit;
var cmpChar$3 = tokenizer2.cmpChar;
var TYPE$C = tokenizer2.TYPE;
var NAME$3 = tokenizer2.NAME;
var IDENT$g = TYPE$C.Ident;
var NUMBER$7 = TYPE$C.Number;
var DIMENSION$5 = TYPE$C.Dimension;
var PLUSSIGN$5 = 43;
var HYPHENMINUS$3 = 45;
var QUESTIONMARK = 63;
var U$1 = 117;
function eatHexSequence(offset2, allowDash) {
  for (var pos = this.scanner.tokenStart + offset2, len = 0; pos < this.scanner.tokenEnd; pos++) {
    var code2 = this.scanner.source.charCodeAt(pos);
    if (code2 === HYPHENMINUS$3 && allowDash && len !== 0) {
      if (eatHexSequence.call(this, offset2 + len + 1, false) === 0) {
        this.error();
      }
      return -1;
    }
    if (!isHexDigit$3(code2)) {
      this.error(
        allowDash && len !== 0 ? "HyphenMinus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input",
        pos
      );
    }
    if (++len > 6) {
      this.error("Too many hex digits", pos);
    }
  }
  this.scanner.next();
  return len;
}
function eatQuestionMarkSequence(max) {
  var count = 0;
  while (this.scanner.isDelim(QUESTIONMARK)) {
    if (++count > max) {
      this.error("Too many question marks");
    }
    this.scanner.next();
  }
}
function startsWith(code2) {
  if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code2) {
    this.error(NAME$3[code2] + " is expected");
  }
}
function scanUnicodeRange() {
  var hexLength = 0;
  if (this.scanner.isDelim(PLUSSIGN$5)) {
    this.scanner.next();
    if (this.scanner.tokenType === IDENT$g) {
      hexLength = eatHexSequence.call(this, 0, true);
      if (hexLength > 0) {
        eatQuestionMarkSequence.call(this, 6 - hexLength);
      }
      return;
    }
    if (this.scanner.isDelim(QUESTIONMARK)) {
      this.scanner.next();
      eatQuestionMarkSequence.call(this, 5);
      return;
    }
    this.error("Hex digit or question mark is expected");
    return;
  }
  if (this.scanner.tokenType === NUMBER$7) {
    startsWith.call(this, PLUSSIGN$5);
    hexLength = eatHexSequence.call(this, 1, true);
    if (this.scanner.isDelim(QUESTIONMARK)) {
      eatQuestionMarkSequence.call(this, 6 - hexLength);
      return;
    }
    if (this.scanner.tokenType === DIMENSION$5 || this.scanner.tokenType === NUMBER$7) {
      startsWith.call(this, HYPHENMINUS$3);
      eatHexSequence.call(this, 1, false);
      return;
    }
    return;
  }
  if (this.scanner.tokenType === DIMENSION$5) {
    startsWith.call(this, PLUSSIGN$5);
    hexLength = eatHexSequence.call(this, 1, true);
    if (hexLength > 0) {
      eatQuestionMarkSequence.call(this, 6 - hexLength);
    }
    return;
  }
  this.error();
}
var UnicodeRange = {
  name: "UnicodeRange",
  structure: {
    value: String
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    if (!cmpChar$3(this.scanner.source, start2, U$1)) {
      this.error("U is expected");
    }
    if (!cmpChar$3(this.scanner.source, start2 + 1, PLUSSIGN$5)) {
      this.error("Plus sign is expected");
    }
    this.scanner.next();
    scanUnicodeRange.call(this);
    return {
      type: "UnicodeRange",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      value: this.scanner.substrToCursor(start2)
    };
  },
  generate: function(node2) {
    this.chunk(node2.value);
  }
};
var isWhiteSpace$2 = tokenizer2.isWhiteSpace;
var cmpStr$5 = tokenizer2.cmpStr;
var TYPE$D = tokenizer2.TYPE;
var FUNCTION$6 = TYPE$D.Function;
var URL$4 = TYPE$D.Url;
var RIGHTPARENTHESIS$5 = TYPE$D.RightParenthesis;
var Url = {
  name: "Url",
  structure: {
    value: ["String", "Raw"]
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    var value2;
    switch (this.scanner.tokenType) {
      case URL$4:
        var rawStart = start2 + 4;
        var rawEnd = this.scanner.tokenEnd - 1;
        while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
          rawStart++;
        }
        while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
          rawEnd--;
        }
        value2 = {
          type: "Raw",
          loc: this.getLocation(rawStart, rawEnd),
          value: this.scanner.source.substring(rawStart, rawEnd)
        };
        this.eat(URL$4);
        break;
      case FUNCTION$6:
        if (!cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, "url(")) {
          this.error("Function name must be `url`");
        }
        this.eat(FUNCTION$6);
        this.scanner.skipSC();
        value2 = this.String();
        this.scanner.skipSC();
        this.eat(RIGHTPARENTHESIS$5);
        break;
      default:
        this.error("Url or Function is expected");
    }
    return {
      type: "Url",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      value: value2
    };
  },
  generate: function(node2) {
    this.chunk("url");
    this.chunk("(");
    this.node(node2.value);
    this.chunk(")");
  }
};
var Value = {
  name: "Value",
  structure: {
    children: [[]]
  },
  parse: function() {
    var start2 = this.scanner.tokenStart;
    var children = this.readSequence(this.scope.Value);
    return {
      type: "Value",
      loc: this.getLocation(start2, this.scanner.tokenStart),
      children
    };
  },
  generate: function(node2) {
    this.children(node2);
  }
};
var WHITESPACE$b = tokenizer2.TYPE.WhiteSpace;
var SPACE = Object.freeze({
  type: "WhiteSpace",
  loc: null,
  value: " "
});
var WhiteSpace$1 = {
  name: "WhiteSpace",
  structure: {
    value: String
  },
  parse: function() {
    this.eat(WHITESPACE$b);
    return SPACE;
  },
  generate: function(node2) {
    this.chunk(node2.value);
  }
};
var node = {
  AnPlusB,
  Atrule,
  AtrulePrelude,
  AttributeSelector,
  Block,
  Brackets,
  CDC: CDC_1,
  CDO: CDO_1,
  ClassSelector,
  Combinator,
  Comment,
  Declaration,
  DeclarationList,
  Dimension,
  Function: _Function,
  Hash,
  Identifier,
  IdSelector,
  MediaFeature,
  MediaQuery,
  MediaQueryList,
  Nth,
  Number: _Number,
  Operator,
  Parentheses,
  Percentage,
  PseudoClassSelector,
  PseudoElementSelector,
  Ratio,
  Raw,
  Rule,
  Selector,
  SelectorList,
  String: _String,
  StyleSheet,
  TypeSelector,
  UnicodeRange,
  Url,
  Value,
  WhiteSpace: WhiteSpace$1
};
var parser = {
  parseContext: {
    default: "StyleSheet",
    stylesheet: "StyleSheet",
    atrule: "Atrule",
    atrulePrelude: function(options2) {
      return this.AtrulePrelude(options2.atrule ? String(options2.atrule) : null);
    },
    mediaQueryList: "MediaQueryList",
    mediaQuery: "MediaQuery",
    rule: "Rule",
    selectorList: "SelectorList",
    selector: "Selector",
    block: function() {
      return this.Block(true);
    },
    declarationList: "DeclarationList",
    declaration: "Declaration",
    value: "Value"
  },
  scope,
  atrule,
  pseudo,
  node
};
var parser$1 = create(parser);
var regex_closing_style_tag = /<\/style\s*>/;
function read_style(parser3, start2, attributes2) {
  const content_start = parser3.index;
  const styles = parser3.read_until(regex_closing_style_tag, parser_errors.unclosed_style);
  if (parser3.index >= parser3.template.length) {
    parser3.error(parser_errors.unclosed_style);
  }
  const content_end = parser3.index;
  let ast2;
  try {
    ast2 = parser$1(styles, {
      positions: true,
      offset: content_start,
      onParseError(error2) {
        throw error2;
      }
    });
  } catch (err) {
    if (err.name === "SyntaxError") {
      parser3.error(parser_errors.css_syntax_error(err.message), err.offset);
    } else {
      throw err;
    }
  }
  ast2 = JSON.parse(JSON.stringify(ast2));
  walk(ast2, {
    enter: (node2) => {
      if (node2.type === "Selector") {
        for (let i = 0; i < node2.children.length; i += 1) {
          const a = node2.children[i];
          const b = node2.children[i + 1];
          if (is_ref_selector(a, b)) {
            parser3.error(parser_errors.invalid_ref_selector, a.loc.start.offset);
          }
        }
      }
      if (node2.type === "Declaration" && node2.value.type === "Value" && node2.value.children.length === 0) {
        parser3.error(parser_errors.invalid_declaration, node2.start);
      }
      if (node2.type === "PseudoClassSelector" && node2.name === "global" && node2.children === null) {
        parser3.error(parser_errors.empty_global_selector, node2.loc.start.offset);
      }
      if (node2.loc) {
        node2.start = node2.loc.start.offset;
        node2.end = node2.loc.end.offset;
        delete node2.loc;
      }
    }
  });
  parser3.read(regex_closing_style_tag);
  const end2 = parser3.index;
  return {
    type: "Style",
    start: start2,
    end: end2,
    attributes: attributes2,
    children: ast2.children,
    content: {
      start: content_start,
      end: content_end,
      styles
    }
  };
}
function is_ref_selector(a, b) {
  if (!b)
    return false;
  return a.type === "TypeSelector" && a.name === "ref" && b.type === "PseudoClassSelector";
}
var entities = {
  CounterClockwiseContourIntegral: 8755,
  ClockwiseContourIntegral: 8754,
  DoubleLongLeftRightArrow: 10234,
  DiacriticalDoubleAcute: 733,
  NotSquareSupersetEqual: 8931,
  CloseCurlyDoubleQuote: 8221,
  DoubleContourIntegral: 8751,
  FilledVerySmallSquare: 9642,
  NegativeVeryThinSpace: 8203,
  NotPrecedesSlantEqual: 8928,
  NotRightTriangleEqual: 8941,
  NotSucceedsSlantEqual: 8929,
  CapitalDifferentialD: 8517,
  DoubleLeftRightArrow: 8660,
  DoubleLongRightArrow: 10233,
  EmptyVerySmallSquare: 9643,
  NestedGreaterGreater: 8811,
  NotDoubleVerticalBar: 8742,
  NotLeftTriangleEqual: 8940,
  NotSquareSubsetEqual: 8930,
  OpenCurlyDoubleQuote: 8220,
  ReverseUpEquilibrium: 10607,
  DoubleLongLeftArrow: 10232,
  DownLeftRightVector: 10576,
  LeftArrowRightArrow: 8646,
  NegativeMediumSpace: 8203,
  RightArrowLeftArrow: 8644,
  SquareSupersetEqual: 8850,
  leftrightsquigarrow: 8621,
  DownRightTeeVector: 10591,
  DownRightVectorBar: 10583,
  LongLeftRightArrow: 10231,
  Longleftrightarrow: 10234,
  NegativeThickSpace: 8203,
  PrecedesSlantEqual: 8828,
  ReverseEquilibrium: 8651,
  RightDoubleBracket: 10215,
  RightDownTeeVector: 10589,
  RightDownVectorBar: 10581,
  RightTriangleEqual: 8885,
  SquareIntersection: 8851,
  SucceedsSlantEqual: 8829,
  blacktriangleright: 9656,
  longleftrightarrow: 10231,
  DoubleUpDownArrow: 8661,
  DoubleVerticalBar: 8741,
  DownLeftTeeVector: 10590,
  DownLeftVectorBar: 10582,
  FilledSmallSquare: 9724,
  GreaterSlantEqual: 10878,
  LeftDoubleBracket: 10214,
  LeftDownTeeVector: 10593,
  LeftDownVectorBar: 10585,
  LeftTriangleEqual: 8884,
  NegativeThinSpace: 8203,
  NotReverseElement: 8716,
  NotTildeFullEqual: 8775,
  RightAngleBracket: 10217,
  RightUpDownVector: 10575,
  SquareSubsetEqual: 8849,
  VerticalSeparator: 10072,
  blacktriangledown: 9662,
  blacktriangleleft: 9666,
  leftrightharpoons: 8651,
  rightleftharpoons: 8652,
  twoheadrightarrow: 8608,
  DiacriticalAcute: 180,
  DiacriticalGrave: 96,
  DiacriticalTilde: 732,
  DoubleRightArrow: 8658,
  DownArrowUpArrow: 8693,
  EmptySmallSquare: 9723,
  GreaterEqualLess: 8923,
  GreaterFullEqual: 8807,
  LeftAngleBracket: 10216,
  LeftUpDownVector: 10577,
  LessEqualGreater: 8922,
  NonBreakingSpace: 160,
  NotRightTriangle: 8939,
  NotSupersetEqual: 8841,
  RightTriangleBar: 10704,
  RightUpTeeVector: 10588,
  RightUpVectorBar: 10580,
  UnderParenthesis: 9181,
  UpArrowDownArrow: 8645,
  circlearrowright: 8635,
  downharpoonright: 8642,
  ntrianglerighteq: 8941,
  rightharpoondown: 8641,
  rightrightarrows: 8649,
  twoheadleftarrow: 8606,
  vartriangleright: 8883,
  CloseCurlyQuote: 8217,
  ContourIntegral: 8750,
  DoubleDownArrow: 8659,
  DoubleLeftArrow: 8656,
  DownRightVector: 8641,
  LeftRightVector: 10574,
  LeftTriangleBar: 10703,
  LeftUpTeeVector: 10592,
  LeftUpVectorBar: 10584,
  LowerRightArrow: 8600,
  NotGreaterEqual: 8817,
  NotGreaterTilde: 8821,
  NotLeftTriangle: 8938,
  OverParenthesis: 9180,
  RightDownVector: 8642,
  ShortRightArrow: 8594,
  UpperRightArrow: 8599,
  bigtriangledown: 9661,
  circlearrowleft: 8634,
  curvearrowright: 8631,
  downharpoonleft: 8643,
  leftharpoondown: 8637,
  leftrightarrows: 8646,
  nLeftrightarrow: 8654,
  nleftrightarrow: 8622,
  ntrianglelefteq: 8940,
  rightleftarrows: 8644,
  rightsquigarrow: 8605,
  rightthreetimes: 8908,
  straightepsilon: 1013,
  trianglerighteq: 8885,
  vartriangleleft: 8882,
  DiacriticalDot: 729,
  DoubleRightTee: 8872,
  DownLeftVector: 8637,
  GreaterGreater: 10914,
  HorizontalLine: 9472,
  InvisibleComma: 8291,
  InvisibleTimes: 8290,
  LeftDownVector: 8643,
  LeftRightArrow: 8596,
  Leftrightarrow: 8660,
  LessSlantEqual: 10877,
  LongRightArrow: 10230,
  Longrightarrow: 10233,
  LowerLeftArrow: 8601,
  NestedLessLess: 8810,
  NotGreaterLess: 8825,
  NotLessGreater: 8824,
  NotSubsetEqual: 8840,
  NotVerticalBar: 8740,
  OpenCurlyQuote: 8216,
  ReverseElement: 8715,
  RightTeeVector: 10587,
  RightVectorBar: 10579,
  ShortDownArrow: 8595,
  ShortLeftArrow: 8592,
  SquareSuperset: 8848,
  TildeFullEqual: 8773,
  UpperLeftArrow: 8598,
  ZeroWidthSpace: 8203,
  curvearrowleft: 8630,
  doublebarwedge: 8966,
  downdownarrows: 8650,
  hookrightarrow: 8618,
  leftleftarrows: 8647,
  leftrightarrow: 8596,
  leftthreetimes: 8907,
  longrightarrow: 10230,
  looparrowright: 8620,
  nshortparallel: 8742,
  ntriangleright: 8939,
  rightarrowtail: 8611,
  rightharpoonup: 8640,
  trianglelefteq: 8884,
  upharpoonright: 8638,
  ApplyFunction: 8289,
  DifferentialD: 8518,
  DoubleLeftTee: 10980,
  DoubleUpArrow: 8657,
  LeftTeeVector: 10586,
  LeftVectorBar: 10578,
  LessFullEqual: 8806,
  LongLeftArrow: 10229,
  Longleftarrow: 10232,
  NotTildeEqual: 8772,
  NotTildeTilde: 8777,
  Poincareplane: 8460,
  PrecedesEqual: 10927,
  PrecedesTilde: 8830,
  RightArrowBar: 8677,
  RightTeeArrow: 8614,
  RightTriangle: 8883,
  RightUpVector: 8638,
  SucceedsEqual: 10928,
  SucceedsTilde: 8831,
  SupersetEqual: 8839,
  UpEquilibrium: 10606,
  VerticalTilde: 8768,
  VeryThinSpace: 8202,
  bigtriangleup: 9651,
  blacktriangle: 9652,
  divideontimes: 8903,
  fallingdotseq: 8786,
  hookleftarrow: 8617,
  leftarrowtail: 8610,
  leftharpoonup: 8636,
  longleftarrow: 10229,
  looparrowleft: 8619,
  measuredangle: 8737,
  ntriangleleft: 8938,
  shortparallel: 8741,
  smallsetminus: 8726,
  triangleright: 9657,
  upharpoonleft: 8639,
  DownArrowBar: 10515,
  DownTeeArrow: 8615,
  ExponentialE: 8519,
  GreaterEqual: 8805,
  GreaterTilde: 8819,
  HilbertSpace: 8459,
  HumpDownHump: 8782,
  Intersection: 8898,
  LeftArrowBar: 8676,
  LeftTeeArrow: 8612,
  LeftTriangle: 8882,
  LeftUpVector: 8639,
  NotCongruent: 8802,
  NotLessEqual: 8816,
  NotLessTilde: 8820,
  Proportional: 8733,
  RightCeiling: 8969,
  RoundImplies: 10608,
  ShortUpArrow: 8593,
  SquareSubset: 8847,
  UnderBracket: 9141,
  VerticalLine: 124,
  blacklozenge: 10731,
  exponentiale: 8519,
  risingdotseq: 8787,
  triangledown: 9663,
  triangleleft: 9667,
  CircleMinus: 8854,
  CircleTimes: 8855,
  Equilibrium: 8652,
  GreaterLess: 8823,
  LeftCeiling: 8968,
  LessGreater: 8822,
  MediumSpace: 8287,
  NotPrecedes: 8832,
  NotSucceeds: 8833,
  OverBracket: 9140,
  RightVector: 8640,
  Rrightarrow: 8667,
  RuleDelayed: 10740,
  SmallCircle: 8728,
  SquareUnion: 8852,
  SubsetEqual: 8838,
  UpDownArrow: 8597,
  Updownarrow: 8661,
  VerticalBar: 8739,
  backepsilon: 1014,
  blacksquare: 9642,
  circledcirc: 8858,
  circleddash: 8861,
  curlyeqprec: 8926,
  curlyeqsucc: 8927,
  diamondsuit: 9830,
  eqslantless: 10901,
  expectation: 8496,
  nRightarrow: 8655,
  nrightarrow: 8603,
  preccurlyeq: 8828,
  precnapprox: 10937,
  quaternions: 8461,
  straightphi: 981,
  succcurlyeq: 8829,
  succnapprox: 10938,
  thickapprox: 8776,
  updownarrow: 8597,
  Bernoullis: 8492,
  CirclePlus: 8853,
  EqualTilde: 8770,
  Fouriertrf: 8497,
  ImaginaryI: 8520,
  Laplacetrf: 8466,
  LeftVector: 8636,
  Lleftarrow: 8666,
  NotElement: 8713,
  NotGreater: 8815,
  Proportion: 8759,
  RightArrow: 8594,
  RightFloor: 8971,
  Rightarrow: 8658,
  TildeEqual: 8771,
  TildeTilde: 8776,
  UnderBrace: 9183,
  UpArrowBar: 10514,
  UpTeeArrow: 8613,
  circledast: 8859,
  complement: 8705,
  curlywedge: 8911,
  eqslantgtr: 10902,
  gtreqqless: 10892,
  lessapprox: 10885,
  lesseqqgtr: 10891,
  lmoustache: 9136,
  longmapsto: 10236,
  mapstodown: 8615,
  mapstoleft: 8612,
  nLeftarrow: 8653,
  nleftarrow: 8602,
  precapprox: 10935,
  rightarrow: 8594,
  rmoustache: 9137,
  sqsubseteq: 8849,
  sqsupseteq: 8850,
  subsetneqq: 10955,
  succapprox: 10936,
  supsetneqq: 10956,
  upuparrows: 8648,
  varepsilon: 949,
  varnothing: 8709,
  Backslash: 8726,
  CenterDot: 183,
  CircleDot: 8857,
  Congruent: 8801,
  Coproduct: 8720,
  DoubleDot: 168,
  DownArrow: 8595,
  DownBreve: 785,
  Downarrow: 8659,
  HumpEqual: 8783,
  LeftArrow: 8592,
  LeftFloor: 8970,
  Leftarrow: 8656,
  LessTilde: 8818,
  Mellintrf: 8499,
  MinusPlus: 8723,
  NotCupCap: 8813,
  NotExists: 8708,
  OverBrace: 9182,
  PlusMinus: 177,
  Therefore: 8756,
  ThinSpace: 8201,
  TripleDot: 8411,
  UnionPlus: 8846,
  backprime: 8245,
  backsimeq: 8909,
  bigotimes: 10754,
  centerdot: 183,
  checkmark: 10003,
  complexes: 8450,
  dotsquare: 8865,
  downarrow: 8595,
  gtrapprox: 10886,
  gtreqless: 8923,
  heartsuit: 9829,
  leftarrow: 8592,
  lesseqgtr: 8922,
  nparallel: 8742,
  nshortmid: 8740,
  nsubseteq: 8840,
  nsupseteq: 8841,
  pitchfork: 8916,
  rationals: 8474,
  spadesuit: 9824,
  subseteqq: 10949,
  subsetneq: 8842,
  supseteqq: 10950,
  supsetneq: 8843,
  therefore: 8756,
  triangleq: 8796,
  varpropto: 8733,
  DDotrahd: 10513,
  DotEqual: 8784,
  Integral: 8747,
  LessLess: 10913,
  NotEqual: 8800,
  NotTilde: 8769,
  PartialD: 8706,
  Precedes: 8826,
  RightTee: 8866,
  Succeeds: 8827,
  SuchThat: 8715,
  Superset: 8835,
  Uarrocir: 10569,
  UnderBar: 818,
  andslope: 10840,
  angmsdaa: 10664,
  angmsdab: 10665,
  angmsdac: 10666,
  angmsdad: 10667,
  angmsdae: 10668,
  angmsdaf: 10669,
  angmsdag: 10670,
  angmsdah: 10671,
  angrtvbd: 10653,
  approxeq: 8778,
  awconint: 8755,
  backcong: 8780,
  barwedge: 8965,
  bbrktbrk: 9142,
  bigoplus: 10753,
  bigsqcup: 10758,
  biguplus: 10756,
  bigwedge: 8896,
  boxminus: 8863,
  boxtimes: 8864,
  capbrcup: 10825,
  circledR: 174,
  circledS: 9416,
  cirfnint: 10768,
  clubsuit: 9827,
  cupbrcap: 10824,
  curlyvee: 8910,
  cwconint: 8754,
  doteqdot: 8785,
  dotminus: 8760,
  drbkarow: 10512,
  dzigrarr: 10239,
  elinters: 9191,
  emptyset: 8709,
  eqvparsl: 10725,
  fpartint: 10765,
  geqslant: 10878,
  gesdotol: 10884,
  gnapprox: 10890,
  hksearow: 10533,
  hkswarow: 10534,
  imagline: 8464,
  imagpart: 8465,
  infintie: 10717,
  integers: 8484,
  intercal: 8890,
  intlarhk: 10775,
  laemptyv: 10676,
  ldrushar: 10571,
  leqslant: 10877,
  lesdotor: 10883,
  llcorner: 8990,
  lnapprox: 10889,
  lrcorner: 8991,
  lurdshar: 10570,
  mapstoup: 8613,
  multimap: 8888,
  naturals: 8469,
  otimesas: 10806,
  parallel: 8741,
  plusacir: 10787,
  pointint: 10773,
  precneqq: 10933,
  precnsim: 8936,
  profalar: 9006,
  profline: 8978,
  profsurf: 8979,
  raemptyv: 10675,
  realpart: 8476,
  rppolint: 10770,
  rtriltri: 10702,
  scpolint: 10771,
  setminus: 8726,
  shortmid: 8739,
  smeparsl: 10724,
  sqsubset: 8847,
  sqsupset: 8848,
  subseteq: 8838,
  succneqq: 10934,
  succnsim: 8937,
  supseteq: 8839,
  thetasym: 977,
  thicksim: 8764,
  timesbar: 10801,
  triangle: 9653,
  triminus: 10810,
  trpezium: 9186,
  ulcorner: 8988,
  urcorner: 8989,
  varkappa: 1008,
  varsigma: 962,
  vartheta: 977,
  Because: 8757,
  Cayleys: 8493,
  Cconint: 8752,
  Cedilla: 184,
  Diamond: 8900,
  DownTee: 8868,
  Element: 8712,
  Epsilon: 917,
  Implies: 8658,
  LeftTee: 8867,
  NewLine: 10,
  NoBreak: 8288,
  NotLess: 8814,
  Omicron: 927,
  OverBar: 175,
  Product: 8719,
  UpArrow: 8593,
  Uparrow: 8657,
  Upsilon: 933,
  alefsym: 8501,
  angrtvb: 8894,
  angzarr: 9084,
  asympeq: 8781,
  backsim: 8765,
  because: 8757,
  bemptyv: 10672,
  between: 8812,
  bigcirc: 9711,
  bigodot: 10752,
  bigstar: 9733,
  boxplus: 8862,
  ccupssm: 10832,
  cemptyv: 10674,
  cirscir: 10690,
  coloneq: 8788,
  congdot: 10861,
  cudarrl: 10552,
  cudarrr: 10549,
  cularrp: 10557,
  curarrm: 10556,
  dbkarow: 10511,
  ddagger: 8225,
  ddotseq: 10871,
  demptyv: 10673,
  diamond: 8900,
  digamma: 989,
  dotplus: 8724,
  dwangle: 10662,
  epsilon: 949,
  eqcolon: 8789,
  equivDD: 10872,
  gesdoto: 10882,
  gtquest: 10876,
  gtrless: 8823,
  harrcir: 10568,
  intprod: 10812,
  isindot: 8949,
  larrbfs: 10527,
  larrsim: 10611,
  lbrksld: 10639,
  lbrkslu: 10637,
  ldrdhar: 10599,
  lesdoto: 10881,
  lessdot: 8918,
  lessgtr: 8822,
  lesssim: 8818,
  lotimes: 10804,
  lozenge: 9674,
  ltquest: 10875,
  luruhar: 10598,
  maltese: 10016,
  minusdu: 10794,
  napprox: 8777,
  natural: 9838,
  nearrow: 8599,
  nexists: 8708,
  notinva: 8713,
  notinvb: 8951,
  notinvc: 8950,
  notniva: 8716,
  notnivb: 8958,
  notnivc: 8957,
  npolint: 10772,
  nsqsube: 8930,
  nsqsupe: 8931,
  nvinfin: 10718,
  nwarrow: 8598,
  olcross: 10683,
  omicron: 959,
  orderof: 8500,
  orslope: 10839,
  pertenk: 8241,
  planckh: 8462,
  pluscir: 10786,
  plussim: 10790,
  plustwo: 10791,
  precsim: 8830,
  quatint: 10774,
  questeq: 8799,
  rarrbfs: 10528,
  rarrsim: 10612,
  rbrksld: 10638,
  rbrkslu: 10640,
  rdldhar: 10601,
  realine: 8475,
  rotimes: 10805,
  ruluhar: 10600,
  searrow: 8600,
  simplus: 10788,
  simrarr: 10610,
  subedot: 10947,
  submult: 10945,
  subplus: 10943,
  subrarr: 10617,
  succsim: 8831,
  supdsub: 10968,
  supedot: 10948,
  suphsub: 10967,
  suplarr: 10619,
  supmult: 10946,
  supplus: 10944,
  swarrow: 8601,
  topfork: 10970,
  triplus: 10809,
  tritime: 10811,
  uparrow: 8593,
  upsilon: 965,
  uwangle: 10663,
  vzigzag: 10650,
  zigrarr: 8669,
  Aacute: 193,
  Abreve: 258,
  Agrave: 192,
  Assign: 8788,
  Atilde: 195,
  Barwed: 8966,
  Bumpeq: 8782,
  Cacute: 262,
  Ccaron: 268,
  Ccedil: 199,
  Colone: 10868,
  Conint: 8751,
  CupCap: 8781,
  Dagger: 8225,
  Dcaron: 270,
  DotDot: 8412,
  Dstrok: 272,
  Eacute: 201,
  Ecaron: 282,
  Egrave: 200,
  Exists: 8707,
  ForAll: 8704,
  Gammad: 988,
  Gbreve: 286,
  Gcedil: 290,
  HARDcy: 1066,
  Hstrok: 294,
  Iacute: 205,
  Igrave: 204,
  Itilde: 296,
  Jsercy: 1032,
  Kcedil: 310,
  Lacute: 313,
  Lambda: 923,
  Lcaron: 317,
  Lcedil: 315,
  Lmidot: 319,
  Lstrok: 321,
  Nacute: 323,
  Ncaron: 327,
  Ncedil: 325,
  Ntilde: 209,
  Oacute: 211,
  Odblac: 336,
  Ograve: 210,
  Oslash: 216,
  Otilde: 213,
  Otimes: 10807,
  Racute: 340,
  Rarrtl: 10518,
  Rcaron: 344,
  Rcedil: 342,
  SHCHcy: 1065,
  SOFTcy: 1068,
  Sacute: 346,
  Scaron: 352,
  Scedil: 350,
  Square: 9633,
  Subset: 8912,
  Supset: 8913,
  Tcaron: 356,
  Tcedil: 354,
  Tstrok: 358,
  Uacute: 218,
  Ubreve: 364,
  Udblac: 368,
  Ugrave: 217,
  Utilde: 360,
  Vdashl: 10982,
  Verbar: 8214,
  Vvdash: 8874,
  Yacute: 221,
  Zacute: 377,
  Zcaron: 381,
  aacute: 225,
  abreve: 259,
  agrave: 224,
  andand: 10837,
  angmsd: 8737,
  angsph: 8738,
  apacir: 10863,
  approx: 8776,
  atilde: 227,
  barvee: 8893,
  barwed: 8965,
  becaus: 8757,
  bernou: 8492,
  bigcap: 8898,
  bigcup: 8899,
  bigvee: 8897,
  bkarow: 10509,
  bottom: 8869,
  bowtie: 8904,
  boxbox: 10697,
  bprime: 8245,
  brvbar: 166,
  bullet: 8226,
  bumpeq: 8783,
  cacute: 263,
  capand: 10820,
  capcap: 10827,
  capcup: 10823,
  capdot: 10816,
  ccaron: 269,
  ccedil: 231,
  circeq: 8791,
  cirmid: 10991,
  colone: 8788,
  commat: 64,
  compfn: 8728,
  conint: 8750,
  coprod: 8720,
  copysr: 8471,
  cularr: 8630,
  cupcap: 10822,
  cupcup: 10826,
  cupdot: 8845,
  curarr: 8631,
  curren: 164,
  cylcty: 9005,
  dagger: 8224,
  daleth: 8504,
  dcaron: 271,
  dfisht: 10623,
  divide: 247,
  divonx: 8903,
  dlcorn: 8990,
  dlcrop: 8973,
  dollar: 36,
  drcorn: 8991,
  drcrop: 8972,
  dstrok: 273,
  eacute: 233,
  easter: 10862,
  ecaron: 283,
  ecolon: 8789,
  egrave: 232,
  egsdot: 10904,
  elsdot: 10903,
  emptyv: 8709,
  emsp13: 8196,
  emsp14: 8197,
  eparsl: 10723,
  eqcirc: 8790,
  equals: 61,
  equest: 8799,
  female: 9792,
  ffilig: 64259,
  ffllig: 64260,
  forall: 8704,
  frac12: 189,
  frac13: 8531,
  frac14: 188,
  frac15: 8533,
  frac16: 8537,
  frac18: 8539,
  frac23: 8532,
  frac25: 8534,
  frac34: 190,
  frac35: 8535,
  frac38: 8540,
  frac45: 8536,
  frac56: 8538,
  frac58: 8541,
  frac78: 8542,
  gacute: 501,
  gammad: 989,
  gbreve: 287,
  gesdot: 10880,
  gesles: 10900,
  gtlPar: 10645,
  gtrarr: 10616,
  gtrdot: 8919,
  gtrsim: 8819,
  hairsp: 8202,
  hamilt: 8459,
  hardcy: 1098,
  hearts: 9829,
  hellip: 8230,
  hercon: 8889,
  homtht: 8763,
  horbar: 8213,
  hslash: 8463,
  hstrok: 295,
  hybull: 8259,
  hyphen: 8208,
  iacute: 237,
  igrave: 236,
  iiiint: 10764,
  iinfin: 10716,
  incare: 8453,
  inodot: 305,
  intcal: 8890,
  iquest: 191,
  isinsv: 8947,
  itilde: 297,
  jsercy: 1112,
  kappav: 1008,
  kcedil: 311,
  kgreen: 312,
  lAtail: 10523,
  lacute: 314,
  lagran: 8466,
  lambda: 955,
  langle: 10216,
  larrfs: 10525,
  larrhk: 8617,
  larrlp: 8619,
  larrpl: 10553,
  larrtl: 8610,
  latail: 10521,
  lbrace: 123,
  lbrack: 91,
  lcaron: 318,
  lcedil: 316,
  ldquor: 8222,
  lesdot: 10879,
  lesges: 10899,
  lfisht: 10620,
  lfloor: 8970,
  lharul: 10602,
  llhard: 10603,
  lmidot: 320,
  lmoust: 9136,
  loplus: 10797,
  lowast: 8727,
  lowbar: 95,
  lparlt: 10643,
  lrhard: 10605,
  lsaquo: 8249,
  lsquor: 8218,
  lstrok: 322,
  lthree: 8907,
  ltimes: 8905,
  ltlarr: 10614,
  ltrPar: 10646,
  mapsto: 8614,
  marker: 9646,
  mcomma: 10793,
  midast: 42,
  midcir: 10992,
  middot: 183,
  minusb: 8863,
  minusd: 8760,
  mnplus: 8723,
  models: 8871,
  mstpos: 8766,
  nVDash: 8879,
  nVdash: 8878,
  nacute: 324,
  ncaron: 328,
  ncedil: 326,
  nearhk: 10532,
  nequiv: 8802,
  nesear: 10536,
  nexist: 8708,
  nltrie: 8940,
  nprcue: 8928,
  nrtrie: 8941,
  nsccue: 8929,
  nsimeq: 8772,
  ntilde: 241,
  numero: 8470,
  nvDash: 8877,
  nvHarr: 10500,
  nvdash: 8876,
  nvlArr: 10498,
  nvrArr: 10499,
  nwarhk: 10531,
  nwnear: 10535,
  oacute: 243,
  odblac: 337,
  odsold: 10684,
  ograve: 242,
  ominus: 8854,
  origof: 8886,
  oslash: 248,
  otilde: 245,
  otimes: 8855,
  parsim: 10995,
  percnt: 37,
  period: 46,
  permil: 8240,
  phmmat: 8499,
  planck: 8463,
  plankv: 8463,
  plusdo: 8724,
  plusdu: 10789,
  plusmn: 177,
  preceq: 10927,
  primes: 8473,
  prnsim: 8936,
  propto: 8733,
  prurel: 8880,
  puncsp: 8200,
  qprime: 8279,
  rAtail: 10524,
  racute: 341,
  rangle: 10217,
  rarrap: 10613,
  rarrfs: 10526,
  rarrhk: 8618,
  rarrlp: 8620,
  rarrpl: 10565,
  rarrtl: 8611,
  ratail: 10522,
  rbrace: 125,
  rbrack: 93,
  rcaron: 345,
  rcedil: 343,
  rdquor: 8221,
  rfisht: 10621,
  rfloor: 8971,
  rharul: 10604,
  rmoust: 9137,
  roplus: 10798,
  rpargt: 10644,
  rsaquo: 8250,
  rsquor: 8217,
  rthree: 8908,
  rtimes: 8906,
  sacute: 347,
  scaron: 353,
  scedil: 351,
  scnsim: 8937,
  searhk: 10533,
  seswar: 10537,
  sfrown: 8994,
  shchcy: 1097,
  sigmaf: 962,
  sigmav: 962,
  simdot: 10858,
  smashp: 10803,
  softcy: 1100,
  solbar: 9023,
  spades: 9824,
  sqsube: 8849,
  sqsupe: 8850,
  square: 9633,
  squarf: 9642,
  ssetmn: 8726,
  ssmile: 8995,
  sstarf: 8902,
  subdot: 10941,
  subset: 8834,
  subsim: 10951,
  subsub: 10965,
  subsup: 10963,
  succeq: 10928,
  supdot: 10942,
  supset: 8835,
  supsim: 10952,
  supsub: 10964,
  supsup: 10966,
  swarhk: 10534,
  swnwar: 10538,
  target: 8982,
  tcaron: 357,
  tcedil: 355,
  telrec: 8981,
  there4: 8756,
  thetav: 977,
  thinsp: 8201,
  thksim: 8764,
  timesb: 8864,
  timesd: 10800,
  topbot: 9014,
  topcir: 10993,
  tprime: 8244,
  tridot: 9708,
  tstrok: 359,
  uacute: 250,
  ubreve: 365,
  udblac: 369,
  ufisht: 10622,
  ugrave: 249,
  ulcorn: 8988,
  ulcrop: 8975,
  urcorn: 8989,
  urcrop: 8974,
  utilde: 361,
  vangrt: 10652,
  varphi: 966,
  varrho: 1009,
  veebar: 8891,
  vellip: 8942,
  verbar: 124,
  wedbar: 10847,
  wedgeq: 8793,
  weierp: 8472,
  wreath: 8768,
  xoplus: 10753,
  xotime: 10754,
  xsqcup: 10758,
  xuplus: 10756,
  xwedge: 8896,
  yacute: 253,
  zacute: 378,
  zcaron: 382,
  zeetrf: 8488,
  AElig: 198,
  Acirc: 194,
  Alpha: 913,
  Amacr: 256,
  Aogon: 260,
  Aring: 197,
  Breve: 728,
  Ccirc: 264,
  Colon: 8759,
  Cross: 10799,
  Dashv: 10980,
  Delta: 916,
  Ecirc: 202,
  Emacr: 274,
  Eogon: 280,
  Equal: 10869,
  Gamma: 915,
  Gcirc: 284,
  Hacek: 711,
  Hcirc: 292,
  IJlig: 306,
  Icirc: 206,
  Imacr: 298,
  Iogon: 302,
  Iukcy: 1030,
  Jcirc: 308,
  Jukcy: 1028,
  Kappa: 922,
  OElig: 338,
  Ocirc: 212,
  Omacr: 332,
  Omega: 937,
  Prime: 8243,
  RBarr: 10512,
  Scirc: 348,
  Sigma: 931,
  THORN: 222,
  TRADE: 8482,
  TSHcy: 1035,
  Theta: 920,
  Tilde: 8764,
  Ubrcy: 1038,
  Ucirc: 219,
  Umacr: 362,
  Union: 8899,
  Uogon: 370,
  UpTee: 8869,
  Uring: 366,
  VDash: 8875,
  Vdash: 8873,
  Wcirc: 372,
  Wedge: 8896,
  Ycirc: 374,
  acirc: 226,
  acute: 180,
  aelig: 230,
  aleph: 8501,
  alpha: 945,
  amacr: 257,
  amalg: 10815,
  angle: 8736,
  angrt: 8735,
  angst: 8491,
  aogon: 261,
  aring: 229,
  asymp: 8776,
  awint: 10769,
  bcong: 8780,
  bdquo: 8222,
  bepsi: 1014,
  blank: 9251,
  blk12: 9618,
  blk14: 9617,
  blk34: 9619,
  block: 9608,
  boxDL: 9559,
  boxDR: 9556,
  boxDl: 9558,
  boxDr: 9555,
  boxHD: 9574,
  boxHU: 9577,
  boxHd: 9572,
  boxHu: 9575,
  boxUL: 9565,
  boxUR: 9562,
  boxUl: 9564,
  boxUr: 9561,
  boxVH: 9580,
  boxVL: 9571,
  boxVR: 9568,
  boxVh: 9579,
  boxVl: 9570,
  boxVr: 9567,
  boxdL: 9557,
  boxdR: 9554,
  boxdl: 9488,
  boxdr: 9484,
  boxhD: 9573,
  boxhU: 9576,
  boxhd: 9516,
  boxhu: 9524,
  boxuL: 9563,
  boxuR: 9560,
  boxul: 9496,
  boxur: 9492,
  boxvH: 9578,
  boxvL: 9569,
  boxvR: 9566,
  boxvh: 9532,
  boxvl: 9508,
  boxvr: 9500,
  breve: 728,
  bsemi: 8271,
  bsime: 8909,
  bsolb: 10693,
  bumpE: 10926,
  bumpe: 8783,
  caret: 8257,
  caron: 711,
  ccaps: 10829,
  ccirc: 265,
  ccups: 10828,
  cedil: 184,
  check: 10003,
  clubs: 9827,
  colon: 58,
  comma: 44,
  crarr: 8629,
  cross: 10007,
  csube: 10961,
  csupe: 10962,
  ctdot: 8943,
  cuepr: 8926,
  cuesc: 8927,
  cupor: 10821,
  cuvee: 8910,
  cuwed: 8911,
  cwint: 8753,
  dashv: 8867,
  dblac: 733,
  ddarr: 8650,
  delta: 948,
  dharl: 8643,
  dharr: 8642,
  diams: 9830,
  disin: 8946,
  doteq: 8784,
  dtdot: 8945,
  dtrif: 9662,
  duarr: 8693,
  duhar: 10607,
  eDDot: 10871,
  ecirc: 234,
  efDot: 8786,
  emacr: 275,
  empty: 8709,
  eogon: 281,
  eplus: 10865,
  epsiv: 949,
  eqsim: 8770,
  equiv: 8801,
  erDot: 8787,
  erarr: 10609,
  esdot: 8784,
  exist: 8707,
  fflig: 64256,
  filig: 64257,
  fllig: 64258,
  fltns: 9649,
  forkv: 10969,
  frasl: 8260,
  frown: 8994,
  gamma: 947,
  gcirc: 285,
  gescc: 10921,
  gimel: 8503,
  gneqq: 8809,
  gnsim: 8935,
  grave: 96,
  gsime: 10894,
  gsiml: 10896,
  gtcir: 10874,
  gtdot: 8919,
  harrw: 8621,
  hcirc: 293,
  hoarr: 8703,
  icirc: 238,
  iexcl: 161,
  iiint: 8749,
  iiota: 8489,
  ijlig: 307,
  imacr: 299,
  image: 8465,
  imath: 305,
  imped: 437,
  infin: 8734,
  iogon: 303,
  iprod: 10812,
  isinE: 8953,
  isins: 8948,
  isinv: 8712,
  iukcy: 1110,
  jcirc: 309,
  jmath: 567,
  jukcy: 1108,
  kappa: 954,
  lAarr: 8666,
  lBarr: 10510,
  langd: 10641,
  laquo: 171,
  larrb: 8676,
  lbarr: 10508,
  lbbrk: 10098,
  lbrke: 10635,
  lceil: 8968,
  ldquo: 8220,
  lescc: 10920,
  lhard: 8637,
  lharu: 8636,
  lhblk: 9604,
  llarr: 8647,
  lltri: 9722,
  lneqq: 8808,
  lnsim: 8934,
  loang: 10220,
  loarr: 8701,
  lobrk: 10214,
  lopar: 10629,
  lrarr: 8646,
  lrhar: 8651,
  lrtri: 8895,
  lsime: 10893,
  lsimg: 10895,
  lsquo: 8216,
  ltcir: 10873,
  ltdot: 8918,
  ltrie: 8884,
  ltrif: 9666,
  mDDot: 8762,
  mdash: 8212,
  micro: 181,
  minus: 8722,
  mumap: 8888,
  nabla: 8711,
  napos: 329,
  natur: 9838,
  ncong: 8775,
  ndash: 8211,
  neArr: 8663,
  nearr: 8599,
  ngsim: 8821,
  nhArr: 8654,
  nharr: 8622,
  nhpar: 10994,
  nlArr: 8653,
  nlarr: 8602,
  nless: 8814,
  nlsim: 8820,
  nltri: 8938,
  notin: 8713,
  notni: 8716,
  nprec: 8832,
  nrArr: 8655,
  nrarr: 8603,
  nrtri: 8939,
  nsime: 8772,
  nsmid: 8740,
  nspar: 8742,
  nsube: 8840,
  nsucc: 8833,
  nsupe: 8841,
  numsp: 8199,
  nwArr: 8662,
  nwarr: 8598,
  ocirc: 244,
  odash: 8861,
  oelig: 339,
  ofcir: 10687,
  ohbar: 10677,
  olarr: 8634,
  olcir: 10686,
  oline: 8254,
  omacr: 333,
  omega: 969,
  operp: 10681,
  oplus: 8853,
  orarr: 8635,
  order: 8500,
  ovbar: 9021,
  parsl: 11005,
  phone: 9742,
  plusb: 8862,
  pluse: 10866,
  pound: 163,
  prcue: 8828,
  prime: 8242,
  prnap: 10937,
  prsim: 8830,
  quest: 63,
  rAarr: 8667,
  rBarr: 10511,
  radic: 8730,
  rangd: 10642,
  range: 10661,
  raquo: 187,
  rarrb: 8677,
  rarrc: 10547,
  rarrw: 8605,
  ratio: 8758,
  rbarr: 10509,
  rbbrk: 10099,
  rbrke: 10636,
  rceil: 8969,
  rdquo: 8221,
  reals: 8477,
  rhard: 8641,
  rharu: 8640,
  rlarr: 8644,
  rlhar: 8652,
  rnmid: 10990,
  roang: 10221,
  roarr: 8702,
  robrk: 10215,
  ropar: 10630,
  rrarr: 8649,
  rsquo: 8217,
  rtrie: 8885,
  rtrif: 9656,
  sbquo: 8218,
  sccue: 8829,
  scirc: 349,
  scnap: 10938,
  scsim: 8831,
  sdotb: 8865,
  sdote: 10854,
  seArr: 8664,
  searr: 8600,
  setmn: 8726,
  sharp: 9839,
  sigma: 963,
  simeq: 8771,
  simgE: 10912,
  simlE: 10911,
  simne: 8774,
  slarr: 8592,
  smile: 8995,
  sqcap: 8851,
  sqcup: 8852,
  sqsub: 8847,
  sqsup: 8848,
  srarr: 8594,
  starf: 9733,
  strns: 175,
  subnE: 10955,
  subne: 8842,
  supnE: 10956,
  supne: 8843,
  swArr: 8665,
  swarr: 8601,
  szlig: 223,
  theta: 952,
  thkap: 8776,
  thorn: 254,
  tilde: 732,
  times: 215,
  trade: 8482,
  trisb: 10701,
  tshcy: 1115,
  twixt: 8812,
  ubrcy: 1118,
  ucirc: 251,
  udarr: 8645,
  udhar: 10606,
  uharl: 8639,
  uharr: 8638,
  uhblk: 9600,
  ultri: 9720,
  umacr: 363,
  uogon: 371,
  uplus: 8846,
  upsih: 978,
  uring: 367,
  urtri: 9721,
  utdot: 8944,
  utrif: 9652,
  uuarr: 8648,
  vBarv: 10985,
  vDash: 8872,
  varpi: 982,
  vdash: 8866,
  veeeq: 8794,
  vltri: 8882,
  vprop: 8733,
  vrtri: 8883,
  wcirc: 373,
  wedge: 8743,
  xcirc: 9711,
  xdtri: 9661,
  xhArr: 10234,
  xharr: 10231,
  xlArr: 10232,
  xlarr: 10229,
  xodot: 10752,
  xrArr: 10233,
  xrarr: 10230,
  xutri: 9651,
  ycirc: 375,
  Aopf: 120120,
  Ascr: 119964,
  Auml: 196,
  Barv: 10983,
  Beta: 914,
  Bopf: 120121,
  Bscr: 8492,
  CHcy: 1063,
  COPY: 169,
  Cdot: 266,
  Copf: 8450,
  Cscr: 119966,
  DJcy: 1026,
  DScy: 1029,
  DZcy: 1039,
  Darr: 8609,
  Dopf: 120123,
  Dscr: 119967,
  Edot: 278,
  Eopf: 120124,
  Escr: 8496,
  Esim: 10867,
  Euml: 203,
  Fopf: 120125,
  Fscr: 8497,
  GJcy: 1027,
  Gdot: 288,
  Gopf: 120126,
  Gscr: 119970,
  Hopf: 8461,
  Hscr: 8459,
  IEcy: 1045,
  IOcy: 1025,
  Idot: 304,
  Iopf: 120128,
  Iota: 921,
  Iscr: 8464,
  Iuml: 207,
  Jopf: 120129,
  Jscr: 119973,
  KHcy: 1061,
  KJcy: 1036,
  Kopf: 120130,
  Kscr: 119974,
  LJcy: 1033,
  Lang: 10218,
  Larr: 8606,
  Lopf: 120131,
  Lscr: 8466,
  Mopf: 120132,
  Mscr: 8499,
  NJcy: 1034,
  Nopf: 8469,
  Nscr: 119977,
  Oopf: 120134,
  Oscr: 119978,
  Ouml: 214,
  Popf: 8473,
  Pscr: 119979,
  QUOT: 34,
  Qopf: 8474,
  Qscr: 119980,
  Rang: 10219,
  Rarr: 8608,
  Ropf: 8477,
  Rscr: 8475,
  SHcy: 1064,
  Sopf: 120138,
  Sqrt: 8730,
  Sscr: 119982,
  Star: 8902,
  TScy: 1062,
  Topf: 120139,
  Tscr: 119983,
  Uarr: 8607,
  Uopf: 120140,
  Upsi: 978,
  Uscr: 119984,
  Uuml: 220,
  Vbar: 10987,
  Vert: 8214,
  Vopf: 120141,
  Vscr: 119985,
  Wopf: 120142,
  Wscr: 119986,
  Xopf: 120143,
  Xscr: 119987,
  YAcy: 1071,
  YIcy: 1031,
  YUcy: 1070,
  Yopf: 120144,
  Yscr: 119988,
  Yuml: 376,
  ZHcy: 1046,
  Zdot: 379,
  Zeta: 918,
  Zopf: 8484,
  Zscr: 119989,
  andd: 10844,
  andv: 10842,
  ange: 10660,
  aopf: 120146,
  apid: 8779,
  apos: 39,
  ascr: 119990,
  auml: 228,
  bNot: 10989,
  bbrk: 9141,
  beta: 946,
  beth: 8502,
  bnot: 8976,
  bopf: 120147,
  boxH: 9552,
  boxV: 9553,
  boxh: 9472,
  boxv: 9474,
  bscr: 119991,
  bsim: 8765,
  bsol: 92,
  bull: 8226,
  bump: 8782,
  cdot: 267,
  cent: 162,
  chcy: 1095,
  cirE: 10691,
  circ: 710,
  cire: 8791,
  comp: 8705,
  cong: 8773,
  copf: 120148,
  copy: 169,
  cscr: 119992,
  csub: 10959,
  csup: 10960,
  dArr: 8659,
  dHar: 10597,
  darr: 8595,
  dash: 8208,
  diam: 8900,
  djcy: 1106,
  dopf: 120149,
  dscr: 119993,
  dscy: 1109,
  dsol: 10742,
  dtri: 9663,
  dzcy: 1119,
  eDot: 8785,
  ecir: 8790,
  edot: 279,
  emsp: 8195,
  ensp: 8194,
  eopf: 120150,
  epar: 8917,
  epsi: 1013,
  escr: 8495,
  esim: 8770,
  euml: 235,
  euro: 8364,
  excl: 33,
  flat: 9837,
  fnof: 402,
  fopf: 120151,
  fork: 8916,
  fscr: 119995,
  gdot: 289,
  geqq: 8807,
  gjcy: 1107,
  gnap: 10890,
  gneq: 10888,
  gopf: 120152,
  gscr: 8458,
  gsim: 8819,
  gtcc: 10919,
  hArr: 8660,
  half: 189,
  harr: 8596,
  hbar: 8463,
  hopf: 120153,
  hscr: 119997,
  iecy: 1077,
  imof: 8887,
  iocy: 1105,
  iopf: 120154,
  iota: 953,
  iscr: 119998,
  isin: 8712,
  iuml: 239,
  jopf: 120155,
  jscr: 119999,
  khcy: 1093,
  kjcy: 1116,
  kopf: 120156,
  kscr: 12e4,
  lArr: 8656,
  lHar: 10594,
  lang: 10216,
  larr: 8592,
  late: 10925,
  lcub: 123,
  ldca: 10550,
  ldsh: 8626,
  leqq: 8806,
  ljcy: 1113,
  lnap: 10889,
  lneq: 10887,
  lopf: 120157,
  lozf: 10731,
  lpar: 40,
  lscr: 120001,
  lsim: 8818,
  lsqb: 91,
  ltcc: 10918,
  ltri: 9667,
  macr: 175,
  male: 9794,
  malt: 10016,
  mlcp: 10971,
  mldr: 8230,
  mopf: 120158,
  mscr: 120002,
  nbsp: 160,
  ncap: 10819,
  ncup: 10818,
  ngeq: 8817,
  ngtr: 8815,
  nisd: 8954,
  njcy: 1114,
  nldr: 8229,
  nleq: 8816,
  nmid: 8740,
  nopf: 120159,
  npar: 8742,
  nscr: 120003,
  nsim: 8769,
  nsub: 8836,
  nsup: 8837,
  ntgl: 8825,
  ntlg: 8824,
  oast: 8859,
  ocir: 8858,
  odiv: 10808,
  odot: 8857,
  ogon: 731,
  oint: 8750,
  omid: 10678,
  oopf: 120160,
  opar: 10679,
  ordf: 170,
  ordm: 186,
  oror: 10838,
  oscr: 8500,
  osol: 8856,
  ouml: 246,
  para: 182,
  part: 8706,
  perp: 8869,
  phiv: 966,
  plus: 43,
  popf: 120161,
  prap: 10935,
  prec: 8826,
  prnE: 10933,
  prod: 8719,
  prop: 8733,
  pscr: 120005,
  qint: 10764,
  qopf: 120162,
  qscr: 120006,
  quot: 34,
  rArr: 8658,
  rHar: 10596,
  race: 10714,
  rang: 10217,
  rarr: 8594,
  rcub: 125,
  rdca: 10551,
  rdsh: 8627,
  real: 8476,
  rect: 9645,
  rhov: 1009,
  ring: 730,
  ropf: 120163,
  rpar: 41,
  rscr: 120007,
  rsqb: 93,
  rtri: 9657,
  scap: 10936,
  scnE: 10934,
  sdot: 8901,
  sect: 167,
  semi: 59,
  sext: 10038,
  shcy: 1096,
  sime: 8771,
  simg: 10910,
  siml: 10909,
  smid: 8739,
  smte: 10924,
  solb: 10692,
  sopf: 120164,
  spar: 8741,
  squf: 9642,
  sscr: 120008,
  star: 9734,
  subE: 10949,
  sube: 8838,
  succ: 8827,
  sung: 9834,
  sup1: 185,
  sup2: 178,
  sup3: 179,
  supE: 10950,
  supe: 8839,
  tbrk: 9140,
  tdot: 8411,
  tint: 8749,
  toea: 10536,
  topf: 120165,
  tosa: 10537,
  trie: 8796,
  tscr: 120009,
  tscy: 1094,
  uArr: 8657,
  uHar: 10595,
  uarr: 8593,
  uopf: 120166,
  upsi: 965,
  uscr: 120010,
  utri: 9653,
  uuml: 252,
  vArr: 8661,
  vBar: 10984,
  varr: 8597,
  vert: 124,
  vopf: 120167,
  vscr: 120011,
  wopf: 120168,
  wscr: 120012,
  xcap: 8898,
  xcup: 8899,
  xmap: 10236,
  xnis: 8955,
  xopf: 120169,
  xscr: 120013,
  xvee: 8897,
  yacy: 1103,
  yicy: 1111,
  yopf: 120170,
  yscr: 120014,
  yucy: 1102,
  yuml: 255,
  zdot: 380,
  zeta: 950,
  zhcy: 1078,
  zopf: 120171,
  zscr: 120015,
  zwnj: 8204,
  AMP: 38,
  Acy: 1040,
  Afr: 120068,
  And: 10835,
  Bcy: 1041,
  Bfr: 120069,
  Cap: 8914,
  Cfr: 8493,
  Chi: 935,
  Cup: 8915,
  Dcy: 1044,
  Del: 8711,
  Dfr: 120071,
  Dot: 168,
  ENG: 330,
  ETH: 208,
  Ecy: 1069,
  Efr: 120072,
  Eta: 919,
  Fcy: 1060,
  Ffr: 120073,
  Gcy: 1043,
  Gfr: 120074,
  Hat: 94,
  Hfr: 8460,
  Icy: 1048,
  Ifr: 8465,
  Int: 8748,
  Jcy: 1049,
  Jfr: 120077,
  Kcy: 1050,
  Kfr: 120078,
  Lcy: 1051,
  Lfr: 120079,
  Lsh: 8624,
  Map: 10501,
  Mcy: 1052,
  Mfr: 120080,
  Ncy: 1053,
  Nfr: 120081,
  Not: 10988,
  Ocy: 1054,
  Ofr: 120082,
  Pcy: 1055,
  Pfr: 120083,
  Phi: 934,
  Psi: 936,
  Qfr: 120084,
  REG: 174,
  Rcy: 1056,
  Rfr: 8476,
  Rho: 929,
  Rsh: 8625,
  Scy: 1057,
  Sfr: 120086,
  Sub: 8912,
  Sum: 8721,
  Sup: 8913,
  Tab: 9,
  Tau: 932,
  Tcy: 1058,
  Tfr: 120087,
  Ucy: 1059,
  Ufr: 120088,
  Vcy: 1042,
  Vee: 8897,
  Vfr: 120089,
  Wfr: 120090,
  Xfr: 120091,
  Ycy: 1067,
  Yfr: 120092,
  Zcy: 1047,
  Zfr: 8488,
  acd: 8767,
  acy: 1072,
  afr: 120094,
  amp: 38,
  and: 8743,
  ang: 8736,
  apE: 10864,
  ape: 8778,
  ast: 42,
  bcy: 1073,
  bfr: 120095,
  bot: 8869,
  cap: 8745,
  cfr: 120096,
  chi: 967,
  cir: 9675,
  cup: 8746,
  dcy: 1076,
  deg: 176,
  dfr: 120097,
  die: 168,
  div: 247,
  dot: 729,
  ecy: 1101,
  efr: 120098,
  egs: 10902,
  ell: 8467,
  els: 10901,
  eng: 331,
  eta: 951,
  eth: 240,
  fcy: 1092,
  ffr: 120099,
  gEl: 10892,
  gap: 10886,
  gcy: 1075,
  gel: 8923,
  geq: 8805,
  ges: 10878,
  gfr: 120100,
  ggg: 8921,
  glE: 10898,
  gla: 10917,
  glj: 10916,
  gnE: 8809,
  gne: 10888,
  hfr: 120101,
  icy: 1080,
  iff: 8660,
  ifr: 120102,
  int: 8747,
  jcy: 1081,
  jfr: 120103,
  kcy: 1082,
  kfr: 120104,
  lEg: 10891,
  lap: 10885,
  lat: 10923,
  lcy: 1083,
  leg: 8922,
  leq: 8804,
  les: 10877,
  lfr: 120105,
  lgE: 10897,
  lnE: 8808,
  lne: 10887,
  loz: 9674,
  lrm: 8206,
  lsh: 8624,
  map: 8614,
  mcy: 1084,
  mfr: 120106,
  mho: 8487,
  mid: 8739,
  nap: 8777,
  ncy: 1085,
  nfr: 120107,
  nge: 8817,
  ngt: 8815,
  nis: 8956,
  niv: 8715,
  nle: 8816,
  nlt: 8814,
  not: 172,
  npr: 8832,
  nsc: 8833,
  num: 35,
  ocy: 1086,
  ofr: 120108,
  ogt: 10689,
  ohm: 8486,
  olt: 10688,
  ord: 10845,
  orv: 10843,
  par: 8741,
  pcy: 1087,
  pfr: 120109,
  phi: 966,
  piv: 982,
  prE: 10931,
  pre: 10927,
  psi: 968,
  qfr: 120110,
  rcy: 1088,
  reg: 174,
  rfr: 120111,
  rho: 961,
  rlm: 8207,
  rsh: 8625,
  scE: 10932,
  sce: 10928,
  scy: 1089,
  sfr: 120112,
  shy: 173,
  sim: 8764,
  smt: 10922,
  sol: 47,
  squ: 9633,
  sub: 8834,
  sum: 8721,
  sup: 8835,
  tau: 964,
  tcy: 1090,
  tfr: 120113,
  top: 8868,
  ucy: 1091,
  ufr: 120114,
  uml: 168,
  vcy: 1074,
  vee: 8744,
  vfr: 120115,
  wfr: 120116,
  xfr: 120117,
  ycy: 1099,
  yen: 165,
  yfr: 120118,
  zcy: 1079,
  zfr: 120119,
  zwj: 8205,
  DD: 8517,
  GT: 62,
  Gg: 8921,
  Gt: 8811,
  Im: 8465,
  LT: 60,
  Ll: 8920,
  Lt: 8810,
  Mu: 924,
  Nu: 925,
  Or: 10836,
  Pi: 928,
  Pr: 10939,
  Re: 8476,
  Sc: 10940,
  Xi: 926,
  ac: 8766,
  af: 8289,
  ap: 8776,
  dd: 8518,
  ee: 8519,
  eg: 10906,
  el: 10905,
  gE: 8807,
  ge: 8805,
  gg: 8811,
  gl: 8823,
  gt: 62,
  ic: 8291,
  ii: 8520,
  in: 8712,
  it: 8290,
  lE: 8806,
  le: 8804,
  lg: 8822,
  ll: 8810,
  lt: 60,
  mp: 8723,
  mu: 956,
  ne: 8800,
  ni: 8715,
  nu: 957,
  oS: 9416,
  or: 8744,
  pi: 960,
  pm: 177,
  pr: 8826,
  rx: 8478,
  sc: 8827,
  wp: 8472,
  wr: 8768,
  xi: 958
};
var windows_1252 = [
  8364,
  129,
  8218,
  402,
  8222,
  8230,
  8224,
  8225,
  710,
  8240,
  352,
  8249,
  338,
  141,
  381,
  143,
  144,
  8216,
  8217,
  8220,
  8221,
  8226,
  8211,
  8212,
  732,
  8482,
  353,
  8250,
  339,
  157,
  382,
  376
];
var entity_pattern = new RegExp(`&(#?(?:x[\\w\\d]+|\\d+|${Object.keys(entities).join("|")}))(?:;|\\b)`, "g");
function decode_character_references(html2) {
  return html2.replace(entity_pattern, (match, entity) => {
    let code2;
    if (entity[0] !== "#") {
      code2 = entities[entity];
    } else if (entity[1] === "x") {
      code2 = parseInt(entity.substring(2), 16);
    } else {
      code2 = parseInt(entity.substring(1), 10);
    }
    if (!code2) {
      return match;
    }
    return String.fromCodePoint(validate_code(code2));
  });
}
var NUL = 0;
function validate_code(code2) {
  if (code2 === 10) {
    return 32;
  }
  if (code2 < 128) {
    return code2;
  }
  if (code2 <= 159) {
    return windows_1252[code2 - 128];
  }
  if (code2 < 55296) {
    return code2;
  }
  if (code2 <= 57343) {
    return NUL;
  }
  if (code2 <= 65535) {
    return code2;
  }
  if (code2 >= 65536 && code2 <= 131071) {
    return code2;
  }
  if (code2 >= 131072 && code2 <= 196607) {
    return code2;
  }
  return NUL;
}
var disallowed_contents = /* @__PURE__ */ new Map([
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["dt", /* @__PURE__ */ new Set(["dt", "dd"])],
  ["dd", /* @__PURE__ */ new Set(["dt", "dd"])],
  [
    "p",
    new Set("address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(" "))
  ],
  ["rt", /* @__PURE__ */ new Set(["rt", "rp"])],
  ["rp", /* @__PURE__ */ new Set(["rt", "rp"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup"])],
  ["option", /* @__PURE__ */ new Set(["option", "optgroup"])],
  ["thead", /* @__PURE__ */ new Set(["tbody", "tfoot"])],
  ["tbody", /* @__PURE__ */ new Set(["tbody", "tfoot"])],
  ["tfoot", /* @__PURE__ */ new Set(["tbody"])],
  ["tr", /* @__PURE__ */ new Set(["tr", "tbody"])],
  ["td", /* @__PURE__ */ new Set(["td", "th", "tr"])],
  ["th", /* @__PURE__ */ new Set(["td", "th", "tr"])]
]);
function closing_tag_omitted(current2, next) {
  if (disallowed_contents.has(current2)) {
    if (!next || disallowed_contents.get(current2).has(next)) {
      return true;
    }
  }
  return false;
}
var valid_tag_name = /^\!?[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
var meta_tags = /* @__PURE__ */ new Map([
  ["svelte:head", "Head"],
  ["svelte:options", "Options"],
  ["svelte:window", "Window"],
  ["svelte:body", "Body"]
]);
var valid_meta_tags = Array.from(meta_tags.keys()).concat("svelte:self", "svelte:component", "svelte:fragment", "svelte:element");
var specials = /* @__PURE__ */ new Map([
  [
    "script",
    {
      read: read_script,
      property: "js"
    }
  ],
  [
    "style",
    {
      read: read_style,
      property: "css"
    }
  ]
]);
var SELF = /^svelte:self(?=[\s/>])/;
var COMPONENT = /^svelte:component(?=[\s/>])/;
var SLOT = /^svelte:fragment(?=[\s/>])/;
var ELEMENT = /^svelte:element(?=[\s/>])/;
function parent_is_head(stack) {
  let i = stack.length;
  while (i--) {
    const { type: type2 } = stack[i];
    if (type2 === "Head")
      return true;
    if (type2 === "Element" || type2 === "InlineComponent")
      return false;
  }
  return false;
}
var regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i;
var regex_closing_comment = /-->/;
var regex_capital_letter = /[A-Z]/;
function tag(parser3) {
  const start2 = parser3.index++;
  let parent = parser3.current();
  if (parser3.eat("!--")) {
    const data3 = parser3.read_until(regex_closing_comment);
    parser3.eat("-->", true, parser_errors.unclosed_comment);
    parser3.current().children.push({
      start: start2,
      end: parser3.index,
      type: "Comment",
      data: data3,
      ignores: extract_svelte_ignore(data3)
    });
    return;
  }
  const is_closing_tag = parser3.eat("/");
  const name2 = read_tag_name(parser3);
  if (meta_tags.has(name2)) {
    const slug = meta_tags.get(name2).toLowerCase();
    if (is_closing_tag) {
      if ((name2 === "svelte:window" || name2 === "svelte:body") && parser3.current().children.length) {
        parser3.error(parser_errors.invalid_element_content(slug, name2), parser3.current().children[0].start);
      }
    } else {
      if (name2 in parser3.meta_tags) {
        parser3.error(parser_errors.duplicate_element(slug, name2), start2);
      }
      if (parser3.stack.length > 1) {
        parser3.error(parser_errors.invalid_element_placement(slug, name2), start2);
      }
      parser3.meta_tags[name2] = true;
    }
  }
  const type2 = meta_tags.has(name2) ? meta_tags.get(name2) : regex_capital_letter.test(name2[0]) || name2 === "svelte:self" || name2 === "svelte:component" ? "InlineComponent" : name2 === "svelte:fragment" ? "SlotTemplate" : name2 === "title" && parent_is_head(parser3.stack) ? "Title" : name2 === "slot" && !parser3.customElement ? "Slot" : "Element";
  const element2 = {
    start: start2,
    end: null,
    type: type2,
    name: name2,
    attributes: [],
    children: []
  };
  parser3.allow_whitespace();
  if (is_closing_tag) {
    if (is_void(name2)) {
      parser3.error(parser_errors.invalid_void_content(name2), start2);
    }
    parser3.eat(">", true);
    while (parent.name !== name2) {
      if (parent.type !== "Element") {
        const error2 = parser3.last_auto_closed_tag && parser3.last_auto_closed_tag.tag === name2 ? parser_errors.invalid_closing_tag_autoclosed(name2, parser3.last_auto_closed_tag.reason) : parser_errors.invalid_closing_tag_unopened(name2);
        parser3.error(error2, start2);
      }
      parent.end = start2;
      parser3.stack.pop();
      parent = parser3.current();
    }
    parent.end = parser3.index;
    parser3.stack.pop();
    if (parser3.last_auto_closed_tag && parser3.stack.length < parser3.last_auto_closed_tag.depth) {
      parser3.last_auto_closed_tag = null;
    }
    return;
  } else if (closing_tag_omitted(parent.name, name2)) {
    parent.end = start2;
    parser3.stack.pop();
    parser3.last_auto_closed_tag = {
      tag: parent.name,
      reason: name2,
      depth: parser3.stack.length
    };
  }
  const unique_names = /* @__PURE__ */ new Set();
  let attribute2;
  while (attribute2 = read_attribute(parser3, unique_names)) {
    element2.attributes.push(attribute2);
    parser3.allow_whitespace();
  }
  if (name2 === "svelte:component") {
    const index2 = element2.attributes.findIndex((attr) => attr.type === "Attribute" && attr.name === "this");
    if (index2 === -1) {
      parser3.error(parser_errors.missing_component_definition, start2);
    }
    const definition2 = element2.attributes.splice(index2, 1)[0];
    if (definition2.value === true || definition2.value.length !== 1 || definition2.value[0].type === "Text") {
      parser3.error(parser_errors.invalid_component_definition, definition2.start);
    }
    element2.expression = definition2.value[0].expression;
  }
  if (name2 === "svelte:element") {
    const index2 = element2.attributes.findIndex((attr) => attr.type === "Attribute" && attr.name === "this");
    if (index2 === -1) {
      parser3.error(parser_errors.missing_element_definition, start2);
    }
    const definition2 = element2.attributes.splice(index2, 1)[0];
    if (definition2.value === true) {
      parser3.error(parser_errors.invalid_element_definition, definition2.start);
    }
    element2.tag = definition2.value[0].data || definition2.value[0].expression;
  }
  if (specials.has(name2) && parser3.stack.length === 1) {
    const special = specials.get(name2);
    parser3.eat(">", true);
    const content = special.read(parser3, start2, element2.attributes);
    if (content)
      parser3[special.property].push(content);
    return;
  }
  parser3.current().children.push(element2);
  const self_closing = parser3.eat("/") || is_void(name2);
  parser3.eat(">", true);
  if (self_closing) {
    element2.end = parser3.index;
  } else if (name2 === "textarea") {
    element2.children = read_sequence(parser3, () => regex_closing_textarea_tag.test(parser3.template.slice(parser3.index)), "inside <textarea>");
    parser3.read(regex_closing_textarea_tag);
    element2.end = parser3.index;
  } else if (name2 === "script" || name2 === "style") {
    const start3 = parser3.index;
    const data3 = parser3.read_until(new RegExp(`</${name2}>`));
    const end2 = parser3.index;
    element2.children.push({ start: start3, end: end2, type: "Text", data: data3 });
    parser3.eat(`</${name2}>`, true);
    element2.end = parser3.index;
  } else {
    parser3.stack.push(element2);
  }
}
var regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/;
function read_tag_name(parser3) {
  const start2 = parser3.index;
  if (parser3.read(SELF)) {
    let i = parser3.stack.length;
    let legal = false;
    while (i--) {
      const fragment2 = parser3.stack[i];
      if (fragment2.type === "IfBlock" || fragment2.type === "EachBlock" || fragment2.type === "InlineComponent") {
        legal = true;
        break;
      }
    }
    if (!legal) {
      parser3.error(parser_errors.invalid_self_placement, start2);
    }
    return "svelte:self";
  }
  if (parser3.read(COMPONENT))
    return "svelte:component";
  if (parser3.read(ELEMENT))
    return "svelte:element";
  if (parser3.read(SLOT))
    return "svelte:fragment";
  const name2 = parser3.read_until(regex_whitespace_or_slash_or_closing_tag);
  if (meta_tags.has(name2))
    return name2;
  if (name2.startsWith("svelte:")) {
    const match = fuzzymatch(name2.slice(7), valid_meta_tags);
    parser3.error(parser_errors.invalid_tag_name_svelte_element(valid_meta_tags, match), start2);
  }
  if (!valid_tag_name.test(name2)) {
    parser3.error(parser_errors.invalid_tag_name, start2);
  }
  return name2;
}
var regex_token_ending_character = /[\s=\/>"']/;
var regex_quote_characters = /["']/;
function read_attribute(parser3, unique_names) {
  const start2 = parser3.index;
  function check_unique(name3) {
    if (unique_names.has(name3)) {
      parser3.error(parser_errors.duplicate_attribute, start2);
    }
    unique_names.add(name3);
  }
  if (parser3.eat("{")) {
    parser3.allow_whitespace();
    if (parser3.eat("...")) {
      const expression2 = read_expression(parser3);
      parser3.allow_whitespace();
      parser3.eat("}", true);
      return {
        start: start2,
        end: parser3.index,
        type: "Spread",
        expression: expression2
      };
    } else {
      const value_start = parser3.index;
      const name3 = parser3.read_identifier();
      parser3.allow_whitespace();
      parser3.eat("}", true);
      if (name3 === null) {
        parser3.error(parser_errors.empty_attribute_shorthand, start2);
      }
      check_unique(name3);
      return {
        start: start2,
        end: parser3.index,
        type: "Attribute",
        name: name3,
        value: [{
          start: value_start,
          end: value_start + name3.length,
          type: "AttributeShorthand",
          expression: {
            start: value_start,
            end: value_start + name3.length,
            type: "Identifier",
            name: name3
          }
        }]
      };
    }
  }
  const name2 = parser3.read_until(regex_token_ending_character);
  if (!name2)
    return null;
  let end2 = parser3.index;
  parser3.allow_whitespace();
  const colon_index = name2.indexOf(":");
  const type2 = colon_index !== -1 && get_directive_type(name2.slice(0, colon_index));
  let value2 = true;
  if (parser3.eat("=")) {
    parser3.allow_whitespace();
    value2 = read_attribute_value(parser3);
    end2 = parser3.index;
  } else if (parser3.match_regex(regex_quote_characters)) {
    parser3.error(parser_errors.unexpected_token("="), parser3.index);
  }
  if (type2) {
    const [directive_name, ...modifiers] = name2.slice(colon_index + 1).split("|");
    if (directive_name === "") {
      parser3.error(parser_errors.empty_directive_name(type2), start2 + colon_index + 1);
    }
    if (type2 === "Binding" && directive_name !== "this") {
      check_unique(directive_name);
    } else if (type2 !== "EventHandler" && type2 !== "Action") {
      check_unique(name2);
    }
    if (type2 === "Ref") {
      parser3.error(parser_errors.invalid_ref_directive(directive_name), start2);
    }
    if (type2 === "StyleDirective") {
      return {
        start: start2,
        end: end2,
        type: type2,
        name: directive_name,
        modifiers,
        value: value2
      };
    }
    const first_value = value2[0];
    let expression2 = null;
    if (first_value) {
      const attribute_contains_text = value2.length > 1 || first_value.type === "Text";
      if (attribute_contains_text) {
        parser3.error(parser_errors.invalid_directive_value, first_value.start);
      } else {
        expression2 = first_value.expression;
      }
    }
    const directive = {
      start: start2,
      end: end2,
      type: type2,
      name: directive_name,
      modifiers,
      expression: expression2
    };
    if (type2 === "Transition") {
      const direction = name2.slice(0, colon_index);
      directive.intro = direction === "in" || direction === "transition";
      directive.outro = direction === "out" || direction === "transition";
    }
    if (!directive.expression && (type2 === "Binding" || type2 === "Class")) {
      directive.expression = {
        start: directive.start + colon_index + 1,
        end: directive.end,
        type: "Identifier",
        name: directive.name
      };
    }
    return directive;
  }
  check_unique(name2);
  return {
    start: start2,
    end: end2,
    type: "Attribute",
    name: name2,
    value: value2
  };
}
function get_directive_type(name2) {
  if (name2 === "use")
    return "Action";
  if (name2 === "animate")
    return "Animation";
  if (name2 === "bind")
    return "Binding";
  if (name2 === "class")
    return "Class";
  if (name2 === "style")
    return "StyleDirective";
  if (name2 === "on")
    return "EventHandler";
  if (name2 === "let")
    return "Let";
  if (name2 === "ref")
    return "Ref";
  if (name2 === "in" || name2 === "out" || name2 === "transition")
    return "Transition";
}
function read_attribute_value(parser3) {
  const quote_mark = parser3.eat("'") ? "'" : parser3.eat('"') ? '"' : null;
  if (quote_mark && parser3.eat(quote_mark)) {
    return [{
      start: parser3.index - 1,
      end: parser3.index - 1,
      type: "Text",
      raw: "",
      data: ""
    }];
  }
  const regex = quote_mark === "'" ? /'/ : quote_mark === '"' ? /"/ : /(\/>|[\s"'=<>`])/;
  let value2;
  try {
    value2 = read_sequence(parser3, () => !!parser3.match_regex(regex), "in attribute value");
  } catch (error2) {
    if (error2.code === "parse-error") {
      if (parser3.template.slice(error2.pos - 1, error2.pos + 1) === "/>") {
        parser3.index = error2.pos;
        parser3.error(parser_errors.unclosed_attribute_value(quote_mark || "}"));
      }
    }
    throw error2;
  }
  if (value2.length === 0 && !quote_mark) {
    parser3.error(parser_errors.missing_attribute_value);
  }
  if (quote_mark)
    parser3.index += 1;
  return value2;
}
function read_sequence(parser3, done, location) {
  let current_chunk = {
    start: parser3.index,
    end: null,
    type: "Text",
    raw: "",
    data: null
  };
  const chunks = [];
  function flush(end2) {
    if (current_chunk.raw) {
      current_chunk.data = decode_character_references(current_chunk.raw);
      current_chunk.end = end2;
      chunks.push(current_chunk);
    }
  }
  while (parser3.index < parser3.template.length) {
    const index2 = parser3.index;
    if (done()) {
      flush(parser3.index);
      return chunks;
    } else if (parser3.eat("{")) {
      if (parser3.match("#")) {
        const index3 = parser3.index - 1;
        parser3.eat("#");
        const name2 = parser3.read_until(/[^a-z]/);
        parser3.error(parser_errors.invalid_logic_block_placement(location, name2), index3);
      } else if (parser3.match("@")) {
        const index3 = parser3.index - 1;
        parser3.eat("@");
        const name2 = parser3.read_until(/[^a-z]/);
        parser3.error(parser_errors.invalid_tag_placement(location, name2), index3);
      }
      flush(parser3.index - 1);
      parser3.allow_whitespace();
      const expression2 = read_expression(parser3);
      parser3.allow_whitespace();
      parser3.eat("}", true);
      chunks.push({
        start: index2,
        end: parser3.index,
        type: "MustacheTag",
        expression: expression2
      });
      current_chunk = {
        start: parser3.index,
        end: null,
        type: "Text",
        raw: "",
        data: null
      };
    } else {
      current_chunk.raw += parser3.template[parser3.index++];
    }
  }
  parser3.error(parser_errors.unexpected_eof);
}
function full_char_code_at(str2, i) {
  const code2 = str2.charCodeAt(i);
  if (code2 <= 55295 || code2 >= 57344)
    return code2;
  const next = str2.charCodeAt(i + 1);
  return (code2 << 10) + next - 56613888;
}
var SQUARE_BRACKET_OPEN = "[".charCodeAt(0);
var SQUARE_BRACKET_CLOSE = "]".charCodeAt(0);
var CURLY_BRACKET_OPEN = "{".charCodeAt(0);
var CURLY_BRACKET_CLOSE = "}".charCodeAt(0);
function is_bracket_open(code2) {
  return code2 === SQUARE_BRACKET_OPEN || code2 === CURLY_BRACKET_OPEN;
}
function is_bracket_close(code2) {
  return code2 === SQUARE_BRACKET_CLOSE || code2 === CURLY_BRACKET_CLOSE;
}
function is_bracket_pair(open, close) {
  return open === SQUARE_BRACKET_OPEN && close === SQUARE_BRACKET_CLOSE || open === CURLY_BRACKET_OPEN && close === CURLY_BRACKET_CLOSE;
}
function get_bracket_close(open) {
  if (open === SQUARE_BRACKET_OPEN) {
    return SQUARE_BRACKET_CLOSE;
  }
  if (open === CURLY_BRACKET_OPEN) {
    return CURLY_BRACKET_CLOSE;
  }
}
function read_context(parser3) {
  const start2 = parser3.index;
  let i = parser3.index;
  const code2 = full_char_code_at(parser3.template, i);
  if (isIdentifierStart(code2, true)) {
    return {
      type: "Identifier",
      name: parser3.read_identifier(),
      start: start2,
      end: parser3.index
    };
  }
  if (!is_bracket_open(code2)) {
    parser3.error(parser_errors.unexpected_token_destructure);
  }
  const bracket_stack = [code2];
  i += code2 <= 65535 ? 1 : 2;
  while (i < parser3.template.length) {
    const code3 = full_char_code_at(parser3.template, i);
    if (is_bracket_open(code3)) {
      bracket_stack.push(code3);
    } else if (is_bracket_close(code3)) {
      if (!is_bracket_pair(bracket_stack[bracket_stack.length - 1], code3)) {
        parser3.error(parser_errors.unexpected_token(String.fromCharCode(get_bracket_close(bracket_stack[bracket_stack.length - 1]))));
      }
      bracket_stack.pop();
      if (bracket_stack.length === 0) {
        i += code3 <= 65535 ? 1 : 2;
        break;
      }
    }
    i += code3 <= 65535 ? 1 : 2;
  }
  parser3.index = i;
  const pattern_string = parser3.template.slice(start2, i);
  try {
    let space_with_newline = parser3.template.slice(0, start2).replace(regex_not_newline_characters, " ");
    const first_space = space_with_newline.indexOf(" ");
    space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);
    return parse_expression_at(`${space_with_newline}(${pattern_string} = 1)`, start2 - 1).left;
  } catch (error2) {
    parser3.acorn_error(error2);
  }
}
function trim_start(str2) {
  return str2.replace(regex_starts_with_whitespaces, "");
}
function trim_end(str2) {
  return str2.replace(regex_ends_with_whitespaces, "");
}
function to_string(node2) {
  switch (node2.type) {
    case "IfBlock":
      return "{#if} block";
    case "ThenBlock":
      return "{:then} block";
    case "ElseBlock":
      return "{:else} block";
    case "PendingBlock":
    case "AwaitBlock":
      return "{#await} block";
    case "CatchBlock":
      return "{:catch} block";
    case "EachBlock":
      return "{#each} block";
    case "RawMustacheTag":
      return "{@html} block";
    case "DebugTag":
      return "{@debug} block";
    case "ConstTag":
      return "{@const} tag";
    case "Element":
    case "InlineComponent":
    case "Slot":
    case "Title":
      return `<${node2.name}> tag`;
    default:
      return node2.type;
  }
}
function trim_whitespace(block2, trim_before, trim_after) {
  if (!block2.children || block2.children.length === 0)
    return;
  const first_child = block2.children[0];
  const last_child = block2.children[block2.children.length - 1];
  if (first_child.type === "Text" && trim_before) {
    first_child.data = trim_start(first_child.data);
    if (!first_child.data)
      block2.children.shift();
  }
  if (last_child.type === "Text" && trim_after) {
    last_child.data = trim_end(last_child.data);
    if (!last_child.data)
      block2.children.pop();
  }
  if (block2.else) {
    trim_whitespace(block2.else, trim_before, trim_after);
  }
  if (first_child.elseif) {
    trim_whitespace(first_child, trim_before, trim_after);
  }
}
var regex_whitespace_with_closing_curly_brace = /\s*}/;
function mustache(parser3) {
  const start2 = parser3.index;
  parser3.index += 1;
  parser3.allow_whitespace();
  if (parser3.eat("/")) {
    let block2 = parser3.current();
    let expected;
    if (closing_tag_omitted(block2.name)) {
      block2.end = start2;
      parser3.stack.pop();
      block2 = parser3.current();
    }
    if (block2.type === "ElseBlock" || block2.type === "PendingBlock" || block2.type === "ThenBlock" || block2.type === "CatchBlock") {
      block2.end = start2;
      parser3.stack.pop();
      block2 = parser3.current();
      expected = "await";
    }
    if (block2.type === "IfBlock") {
      expected = "if";
    } else if (block2.type === "EachBlock") {
      expected = "each";
    } else if (block2.type === "AwaitBlock") {
      expected = "await";
    } else if (block2.type === "KeyBlock") {
      expected = "key";
    } else {
      parser3.error(parser_errors.unexpected_block_close);
    }
    parser3.eat(expected, true);
    parser3.allow_whitespace();
    parser3.eat("}", true);
    while (block2.elseif) {
      block2.end = parser3.index;
      parser3.stack.pop();
      block2 = parser3.current();
      if (block2.else) {
        block2.else.end = start2;
      }
    }
    const char_before = parser3.template[block2.start - 1];
    const char_after = parser3.template[parser3.index];
    const trim_before = !char_before || regex_whitespace.test(char_before);
    const trim_after = !char_after || regex_whitespace.test(char_after);
    trim_whitespace(block2, trim_before, trim_after);
    block2.end = parser3.index;
    parser3.stack.pop();
  } else if (parser3.eat(":else")) {
    if (parser3.eat("if")) {
      parser3.error(parser_errors.invalid_elseif);
    }
    parser3.allow_whitespace();
    if (parser3.eat("if")) {
      const block2 = parser3.current();
      if (block2.type !== "IfBlock") {
        parser3.error(parser3.stack.some((block3) => block3.type === "IfBlock") ? parser_errors.invalid_elseif_placement_unclosed_block(to_string(block2)) : parser_errors.invalid_elseif_placement_outside_if);
      }
      parser3.require_whitespace();
      const expression2 = read_expression(parser3);
      parser3.allow_whitespace();
      parser3.eat("}", true);
      block2.else = {
        start: parser3.index,
        end: null,
        type: "ElseBlock",
        children: [
          {
            start: parser3.index,
            end: null,
            type: "IfBlock",
            elseif: true,
            expression: expression2,
            children: []
          }
        ]
      };
      parser3.stack.push(block2.else.children[0]);
    } else {
      const block2 = parser3.current();
      if (block2.type !== "IfBlock" && block2.type !== "EachBlock") {
        parser3.error(parser3.stack.some((block3) => block3.type === "IfBlock" || block3.type === "EachBlock") ? parser_errors.invalid_else_placement_unclosed_block(to_string(block2)) : parser_errors.invalid_else_placement_outside_if);
      }
      parser3.allow_whitespace();
      parser3.eat("}", true);
      block2.else = {
        start: parser3.index,
        end: null,
        type: "ElseBlock",
        children: []
      };
      parser3.stack.push(block2.else);
    }
  } else if (parser3.match(":then") || parser3.match(":catch")) {
    const block2 = parser3.current();
    const is_then = parser3.eat(":then") || !parser3.eat(":catch");
    if (is_then) {
      if (block2.type !== "PendingBlock") {
        parser3.error(parser3.stack.some((block3) => block3.type === "PendingBlock") ? parser_errors.invalid_then_placement_unclosed_block(to_string(block2)) : parser_errors.invalid_then_placement_without_await);
      }
    } else {
      if (block2.type !== "ThenBlock" && block2.type !== "PendingBlock") {
        parser3.error(parser3.stack.some((block3) => block3.type === "ThenBlock" || block3.type === "PendingBlock") ? parser_errors.invalid_catch_placement_unclosed_block(to_string(block2)) : parser_errors.invalid_catch_placement_without_await);
      }
    }
    block2.end = start2;
    parser3.stack.pop();
    const await_block = parser3.current();
    if (!parser3.eat("}")) {
      parser3.require_whitespace();
      await_block[is_then ? "value" : "error"] = read_context(parser3);
      parser3.allow_whitespace();
      parser3.eat("}", true);
    }
    const new_block = {
      start: start2,
      end: null,
      type: is_then ? "ThenBlock" : "CatchBlock",
      children: [],
      skip: false
    };
    await_block[is_then ? "then" : "catch"] = new_block;
    parser3.stack.push(new_block);
  } else if (parser3.eat("#")) {
    let type2;
    if (parser3.eat("if")) {
      type2 = "IfBlock";
    } else if (parser3.eat("each")) {
      type2 = "EachBlock";
    } else if (parser3.eat("await")) {
      type2 = "AwaitBlock";
    } else if (parser3.eat("key")) {
      type2 = "KeyBlock";
    } else {
      parser3.error(parser_errors.expected_block_type);
    }
    parser3.require_whitespace();
    const expression2 = read_expression(parser3);
    const block2 = type2 === "AwaitBlock" ? {
      start: start2,
      end: null,
      type: type2,
      expression: expression2,
      value: null,
      error: null,
      pending: {
        start: null,
        end: null,
        type: "PendingBlock",
        children: [],
        skip: true
      },
      then: {
        start: null,
        end: null,
        type: "ThenBlock",
        children: [],
        skip: true
      },
      catch: {
        start: null,
        end: null,
        type: "CatchBlock",
        children: [],
        skip: true
      }
    } : {
      start: start2,
      end: null,
      type: type2,
      expression: expression2,
      children: []
    };
    parser3.allow_whitespace();
    if (type2 === "EachBlock") {
      parser3.eat("as", true);
      parser3.require_whitespace();
      block2.context = read_context(parser3);
      parser3.allow_whitespace();
      if (parser3.eat(",")) {
        parser3.allow_whitespace();
        block2.index = parser3.read_identifier();
        if (!block2.index)
          parser3.error(parser_errors.expected_name);
        parser3.allow_whitespace();
      }
      if (parser3.eat("(")) {
        parser3.allow_whitespace();
        block2.key = read_expression(parser3);
        parser3.allow_whitespace();
        parser3.eat(")", true);
        parser3.allow_whitespace();
      }
    }
    const await_block_shorthand = type2 === "AwaitBlock" && parser3.eat("then");
    if (await_block_shorthand) {
      if (parser3.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser3.allow_whitespace();
      } else {
        parser3.require_whitespace();
        block2.value = read_context(parser3);
        parser3.allow_whitespace();
      }
    }
    const await_block_catch_shorthand = !await_block_shorthand && type2 === "AwaitBlock" && parser3.eat("catch");
    if (await_block_catch_shorthand) {
      if (parser3.match_regex(regex_whitespace_with_closing_curly_brace)) {
        parser3.allow_whitespace();
      } else {
        parser3.require_whitespace();
        block2.error = read_context(parser3);
        parser3.allow_whitespace();
      }
    }
    parser3.eat("}", true);
    parser3.current().children.push(block2);
    parser3.stack.push(block2);
    if (type2 === "AwaitBlock") {
      let child_block;
      if (await_block_shorthand) {
        block2.then.skip = false;
        child_block = block2.then;
      } else if (await_block_catch_shorthand) {
        block2.catch.skip = false;
        child_block = block2.catch;
      } else {
        block2.pending.skip = false;
        child_block = block2.pending;
      }
      child_block.start = parser3.index;
      parser3.stack.push(child_block);
    }
  } else if (parser3.eat("@html")) {
    parser3.require_whitespace();
    const expression2 = read_expression(parser3);
    parser3.allow_whitespace();
    parser3.eat("}", true);
    parser3.current().children.push({
      start: start2,
      end: parser3.index,
      type: "RawMustacheTag",
      expression: expression2
    });
  } else if (parser3.eat("@debug")) {
    let identifiers;
    if (parser3.read(regex_whitespace_with_closing_curly_brace)) {
      identifiers = [];
    } else {
      const expression2 = read_expression(parser3);
      identifiers = expression2.type === "SequenceExpression" ? expression2.expressions : [expression2];
      identifiers.forEach((node2) => {
        if (node2.type !== "Identifier") {
          parser3.error(parser_errors.invalid_debug_args, node2.start);
        }
      });
      parser3.allow_whitespace();
      parser3.eat("}", true);
    }
    parser3.current().children.push({
      start: start2,
      end: parser3.index,
      type: "DebugTag",
      identifiers
    });
  } else if (parser3.eat("@const")) {
    parser3.require_whitespace();
    const expression2 = read_expression(parser3);
    if (!(expression2.type === "AssignmentExpression" && expression2.operator === "=")) {
      parser3.error({
        code: "invalid-const-args",
        message: "{@const ...} must be an assignment."
      }, start2);
    }
    parser3.allow_whitespace();
    parser3.eat("}", true);
    parser3.current().children.push({
      start: start2,
      end: parser3.index,
      type: "ConstTag",
      expression: expression2
    });
  } else {
    const expression2 = read_expression(parser3);
    parser3.allow_whitespace();
    parser3.eat("}", true);
    parser3.current().children.push({
      start: start2,
      end: parser3.index,
      type: "MustacheTag",
      expression: expression2
    });
  }
}
function text(parser3) {
  const start2 = parser3.index;
  let data3 = "";
  while (parser3.index < parser3.template.length && !parser3.match("<") && !parser3.match("{")) {
    data3 += parser3.template[parser3.index++];
  }
  const node2 = {
    start: start2,
    end: parser3.index,
    type: "Text",
    raw: data3,
    data: decode_character_references(data3)
  };
  parser3.current().children.push(node2);
}
function fragment(parser3) {
  if (parser3.match("<")) {
    return tag;
  }
  if (parser3.match("{")) {
    return mustache;
  }
  return text;
}
var reserved = /* @__PURE__ */ new Set([
  "arguments",
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "eval",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "implements",
  "import",
  "in",
  "instanceof",
  "interface",
  "let",
  "new",
  "null",
  "package",
  "private",
  "protected",
  "public",
  "return",
  "static",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield"
]);
function getLocator(source, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var offsetLine = options2.offsetLine || 0;
  var offsetColumn = options2.offsetColumn || 0;
  var originalLines = source.split("\n");
  var start2 = 0;
  var lineRanges = originalLines.map(function(line2, i2) {
    var end2 = start2 + line2.length + 1;
    var range2 = { start: start2, end: end2, line: i2 };
    start2 = end2;
    return range2;
  });
  var i = 0;
  function rangeContains(range2, index2) {
    return range2.start <= index2 && index2 < range2.end;
  }
  function getLocation(range2, index2) {
    return { line: offsetLine + range2.line, column: offsetColumn + index2 - range2.start, character: index2 };
  }
  function locate3(search, startIndex) {
    if (typeof search === "string") {
      search = source.indexOf(search, startIndex || 0);
    }
    var range2 = lineRanges[i];
    var d = search >= range2.end ? 1 : -1;
    while (range2) {
      if (rangeContains(range2, search))
        return getLocation(range2, search);
      i += d;
      range2 = lineRanges[i];
    }
  }
  return locate3;
}
function locate(source, search, options2) {
  if (typeof options2 === "number") {
    throw new Error("locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument");
  }
  return getLocator(source, options2)(search, options2 && options2.startIndex);
}
var regex_tabs = /^\t+/;
function tabs_to_spaces(str2) {
  return str2.replace(regex_tabs, (match) => match.split("	").join("  "));
}
function get_code_frame(source, line2, column) {
  const lines = source.split("\n");
  const frame_start = Math.max(0, line2 - 2);
  const frame_end = Math.min(line2 + 3, lines.length);
  const digits = String(frame_end + 1).length;
  return lines.slice(frame_start, frame_end).map((str2, i) => {
    const isErrorLine = frame_start + i === line2;
    const line_num = String(i + frame_start + 1).padStart(digits, " ");
    if (isErrorLine) {
      const indicator = " ".repeat(digits + 2 + tabs_to_spaces(str2.slice(0, column)).length) + "^";
      return `${line_num}: ${tabs_to_spaces(str2)}
${indicator}`;
    }
    return `${line_num}: ${tabs_to_spaces(str2)}`;
  }).join("\n");
}
var CompileError = class extends Error {
  toString() {
    return `${this.message} (${this.start.line}:${this.start.column})
${this.frame}`;
  }
};
function error(message2, props) {
  const error2 = new CompileError(message2);
  error2.name = props.name;
  const start2 = locate(props.source, props.start, { offsetLine: 1 });
  const end2 = locate(props.source, props.end || props.start, { offsetLine: 1 });
  error2.code = props.code;
  error2.start = start2;
  error2.end = end2;
  error2.pos = props.start;
  error2.filename = props.filename;
  error2.frame = get_code_frame(props.source, start2.line - 1, start2.column);
  throw error2;
}
var regex_position_indicator = / \(\d+:\d+\)$/;
var Parser$1 = class {
  constructor(template, options2) {
    this.index = 0;
    this.stack = [];
    this.css = [];
    this.js = [];
    this.meta_tags = {};
    if (typeof template !== "string") {
      throw new TypeError("Template must be a string");
    }
    this.template = template.trimRight();
    this.filename = options2.filename;
    this.customElement = options2.customElement;
    this.html = {
      start: null,
      end: null,
      type: "Fragment",
      children: []
    };
    this.stack.push(this.html);
    let state = fragment;
    while (this.index < this.template.length) {
      state = state(this) || fragment;
    }
    if (this.stack.length > 1) {
      const current2 = this.current();
      const type2 = current2.type === "Element" ? `<${current2.name}>` : "Block";
      const slug = current2.type === "Element" ? "element" : "block";
      this.error({
        code: `unclosed-${slug}`,
        message: `${type2} was left open`
      }, current2.start);
    }
    if (state !== fragment) {
      this.error({
        code: "unexpected-eof",
        message: "Unexpected end of input"
      });
    }
    if (this.html.children.length) {
      let start2 = this.html.children[0].start;
      while (regex_whitespace.test(template[start2]))
        start2 += 1;
      let end2 = this.html.children[this.html.children.length - 1].end;
      while (regex_whitespace.test(template[end2 - 1]))
        end2 -= 1;
      this.html.start = start2;
      this.html.end = end2;
    } else {
      this.html.start = this.html.end = null;
    }
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  acorn_error(err) {
    this.error({
      code: "parse-error",
      message: err.message.replace(regex_position_indicator, "")
    }, err.pos);
  }
  error({ code: code2, message: message2 }, index2 = this.index) {
    error(message2, {
      name: "ParseError",
      code: code2,
      source: this.template,
      start: index2,
      filename: this.filename
    });
  }
  eat(str2, required, error2) {
    if (this.match(str2)) {
      this.index += str2.length;
      return true;
    }
    if (required) {
      this.error(error2 || (this.index === this.template.length ? parser_errors.unexpected_eof_token(str2) : parser_errors.unexpected_token(str2)));
    }
    return false;
  }
  match(str2) {
    return this.template.slice(this.index, this.index + str2.length) === str2;
  }
  match_regex(pattern) {
    const match = pattern.exec(this.template.slice(this.index));
    if (!match || match.index !== 0)
      return null;
    return match[0];
  }
  allow_whitespace() {
    while (this.index < this.template.length && regex_whitespace.test(this.template[this.index])) {
      this.index++;
    }
  }
  read(pattern) {
    const result = this.match_regex(pattern);
    if (result)
      this.index += result.length;
    return result;
  }
  read_identifier(allow_reserved = false) {
    const start2 = this.index;
    let i = this.index;
    const code2 = full_char_code_at(this.template, i);
    if (!isIdentifierStart(code2, true))
      return null;
    i += code2 <= 65535 ? 1 : 2;
    while (i < this.template.length) {
      const code3 = full_char_code_at(this.template, i);
      if (!isIdentifierChar(code3, true))
        break;
      i += code3 <= 65535 ? 1 : 2;
    }
    const identifier = this.template.slice(this.index, this.index = i);
    if (!allow_reserved && reserved.has(identifier)) {
      this.error({
        code: "unexpected-reserved-word",
        message: `'${identifier}' is a reserved word in JavaScript and cannot be used here`
      }, start2);
    }
    return identifier;
  }
  read_until(pattern, error_message) {
    if (this.index >= this.template.length) {
      this.error(error_message || {
        code: "unexpected-eof",
        message: "Unexpected end of input"
      });
    }
    const start2 = this.index;
    const match = pattern.exec(this.template.slice(start2));
    if (match) {
      this.index = start2 + match.index;
      return this.template.slice(start2, this.index);
    }
    this.index = this.template.length;
    return this.template.slice(start2);
  }
  require_whitespace() {
    if (!regex_whitespace.test(this.template[this.index])) {
      this.error({
        code: "missing-whitespace",
        message: "Expected whitespace"
      });
    }
    this.allow_whitespace();
  }
};
function parse$3(template, options2 = {}) {
  const parser3 = new Parser$1(template, options2);
  if (parser3.css.length > 1) {
    parser3.error(parser_errors.duplicate_style, parser3.css[1].start);
  }
  const instance_scripts = parser3.js.filter((script) => script.context === "default");
  const module_scripts = parser3.js.filter((script) => script.context === "module");
  if (instance_scripts.length > 1) {
    parser3.error(parser_errors.invalid_script_instance, instance_scripts[1].start);
  }
  if (module_scripts.length > 1) {
    parser3.error(parser_errors.invalid_script_module, module_scripts[1].start);
  }
  return {
    html: parser3.html,
    css: parser3.css[0],
    instance: instance_scripts[0],
    module: module_scripts[0]
  };
}
function unwrapExports(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
var ariaPropsMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  var properties2 = [["aria-activedescendant", {
    "type": "id"
  }], ["aria-atomic", {
    "type": "boolean"
  }], ["aria-autocomplete", {
    "type": "token",
    "values": ["inline", "list", "both", "none"]
  }], ["aria-busy", {
    "type": "boolean"
  }], ["aria-checked", {
    "type": "tristate"
  }], ["aria-colcount", {
    type: "integer"
  }], ["aria-colindex", {
    type: "integer"
  }], ["aria-colspan", {
    type: "integer"
  }], ["aria-controls", {
    "type": "idlist"
  }], ["aria-current", {
    type: "token",
    values: ["page", "step", "location", "date", "time", true, false]
  }], ["aria-describedby", {
    "type": "idlist"
  }], ["aria-details", {
    "type": "id"
  }], ["aria-disabled", {
    "type": "boolean"
  }], ["aria-dropeffect", {
    "type": "tokenlist",
    "values": ["copy", "execute", "link", "move", "none", "popup"]
  }], ["aria-errormessage", {
    "type": "id"
  }], ["aria-expanded", {
    "type": "boolean",
    "allowundefined": true
  }], ["aria-flowto", {
    "type": "idlist"
  }], ["aria-grabbed", {
    "type": "boolean",
    "allowundefined": true
  }], ["aria-haspopup", {
    "type": "token",
    "values": [false, true, "menu", "listbox", "tree", "grid", "dialog"]
  }], ["aria-hidden", {
    "type": "boolean",
    "allowundefined": true
  }], ["aria-invalid", {
    "type": "token",
    "values": ["grammar", false, "spelling", true]
  }], ["aria-keyshortcuts", {
    type: "string"
  }], ["aria-label", {
    "type": "string"
  }], ["aria-labelledby", {
    "type": "idlist"
  }], ["aria-level", {
    "type": "integer"
  }], ["aria-live", {
    "type": "token",
    "values": ["assertive", "off", "polite"]
  }], ["aria-modal", {
    type: "boolean"
  }], ["aria-multiline", {
    "type": "boolean"
  }], ["aria-multiselectable", {
    "type": "boolean"
  }], ["aria-orientation", {
    "type": "token",
    "values": ["vertical", "undefined", "horizontal"]
  }], ["aria-owns", {
    "type": "idlist"
  }], ["aria-placeholder", {
    type: "string"
  }], ["aria-posinset", {
    "type": "integer"
  }], ["aria-pressed", {
    "type": "tristate"
  }], ["aria-readonly", {
    "type": "boolean"
  }], ["aria-relevant", {
    "type": "tokenlist",
    "values": ["additions", "all", "removals", "text"]
  }], ["aria-required", {
    "type": "boolean"
  }], ["aria-roledescription", {
    type: "string"
  }], ["aria-rowcount", {
    type: "integer"
  }], ["aria-rowindex", {
    type: "integer"
  }], ["aria-rowspan", {
    type: "integer"
  }], ["aria-selected", {
    "type": "boolean",
    "allowundefined": true
  }], ["aria-setsize", {
    "type": "integer"
  }], ["aria-sort", {
    "type": "token",
    "values": ["ascending", "descending", "none", "other"]
  }], ["aria-valuemax", {
    "type": "number"
  }], ["aria-valuemin", {
    "type": "number"
  }], ["aria-valuenow", {
    "type": "number"
  }], ["aria-valuetext", {
    "type": "string"
  }]];
  var ariaPropsMap = {
    entries: function entries() {
      return properties2;
    },
    get: function get(key) {
      var item = properties2.find(function(tuple) {
        return tuple[0] === key ? true : false;
      });
      return item && item[1];
    },
    has: function has2(key) {
      return !!this.get(key);
    },
    keys: function keys2() {
      return properties2.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
        return key;
      });
    },
    values: function values2() {
      return properties2.map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), values3 = _ref4[1];
        return values3;
      });
    }
  };
  var _default2 = ariaPropsMap;
  exports.default = _default2;
});
unwrapExports(ariaPropsMap_1);
var domMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  var dom = [["a", {
    reserved: false
  }], ["abbr", {
    reserved: false
  }], ["acronym", {
    reserved: false
  }], ["address", {
    reserved: false
  }], ["applet", {
    reserved: false
  }], ["area", {
    reserved: false
  }], ["article", {
    reserved: false
  }], ["aside", {
    reserved: false
  }], ["audio", {
    reserved: false
  }], ["b", {
    reserved: false
  }], ["base", {
    reserved: true
  }], ["bdi", {
    reserved: false
  }], ["bdo", {
    reserved: false
  }], ["big", {
    reserved: false
  }], ["blink", {
    reserved: false
  }], ["blockquote", {
    reserved: false
  }], ["body", {
    reserved: false
  }], ["br", {
    reserved: false
  }], ["button", {
    reserved: false
  }], ["canvas", {
    reserved: false
  }], ["caption", {
    reserved: false
  }], ["center", {
    reserved: false
  }], ["cite", {
    reserved: false
  }], ["code", {
    reserved: false
  }], ["col", {
    reserved: true
  }], ["colgroup", {
    reserved: true
  }], ["content", {
    reserved: false
  }], ["data", {
    reserved: false
  }], ["datalist", {
    reserved: false
  }], ["dd", {
    reserved: false
  }], ["del", {
    reserved: false
  }], ["details", {
    reserved: false
  }], ["dfn", {
    reserved: false
  }], ["dialog", {
    reserved: false
  }], ["dir", {
    reserved: false
  }], ["div", {
    reserved: false
  }], ["dl", {
    reserved: false
  }], ["dt", {
    reserved: false
  }], ["em", {
    reserved: false
  }], ["embed", {
    reserved: false
  }], ["fieldset", {
    reserved: false
  }], ["figcaption", {
    reserved: false
  }], ["figure", {
    reserved: false
  }], ["font", {
    reserved: false
  }], ["footer", {
    reserved: false
  }], ["form", {
    reserved: false
  }], ["frame", {
    reserved: false
  }], ["frameset", {
    reserved: false
  }], ["h1", {
    reserved: false
  }], ["h2", {
    reserved: false
  }], ["h3", {
    reserved: false
  }], ["h4", {
    reserved: false
  }], ["h5", {
    reserved: false
  }], ["h6", {
    reserved: false
  }], ["head", {
    reserved: true
  }], ["header", {
    reserved: false
  }], ["hgroup", {
    reserved: false
  }], ["hr", {
    reserved: false
  }], ["html", {
    reserved: true
  }], ["i", {
    reserved: false
  }], ["iframe", {
    reserved: false
  }], ["img", {
    reserved: false
  }], ["input", {
    reserved: false
  }], ["ins", {
    reserved: false
  }], ["kbd", {
    reserved: false
  }], ["keygen", {
    reserved: false
  }], ["label", {
    reserved: false
  }], ["legend", {
    reserved: false
  }], ["li", {
    reserved: false
  }], ["link", {
    reserved: true
  }], ["main", {
    reserved: false
  }], ["map", {
    reserved: false
  }], ["mark", {
    reserved: false
  }], ["marquee", {
    reserved: false
  }], ["menu", {
    reserved: false
  }], ["menuitem", {
    reserved: false
  }], ["meta", {
    reserved: true
  }], ["meter", {
    reserved: false
  }], ["nav", {
    reserved: false
  }], ["noembed", {
    reserved: true
  }], ["noscript", {
    reserved: true
  }], ["object", {
    reserved: false
  }], ["ol", {
    reserved: false
  }], ["optgroup", {
    reserved: false
  }], ["option", {
    reserved: false
  }], ["output", {
    reserved: false
  }], ["p", {
    reserved: false
  }], ["param", {
    reserved: true
  }], ["picture", {
    reserved: true
  }], ["pre", {
    reserved: false
  }], ["progress", {
    reserved: false
  }], ["q", {
    reserved: false
  }], ["rp", {
    reserved: false
  }], ["rt", {
    reserved: false
  }], ["rtc", {
    reserved: false
  }], ["ruby", {
    reserved: false
  }], ["s", {
    reserved: false
  }], ["samp", {
    reserved: false
  }], ["script", {
    reserved: true
  }], ["section", {
    reserved: false
  }], ["select", {
    reserved: false
  }], ["small", {
    reserved: false
  }], ["source", {
    reserved: true
  }], ["spacer", {
    reserved: false
  }], ["span", {
    reserved: false
  }], ["strike", {
    reserved: false
  }], ["strong", {
    reserved: false
  }], ["style", {
    reserved: true
  }], ["sub", {
    reserved: false
  }], ["summary", {
    reserved: false
  }], ["sup", {
    reserved: false
  }], ["table", {
    reserved: false
  }], ["tbody", {
    reserved: false
  }], ["td", {
    reserved: false
  }], ["textarea", {
    reserved: false
  }], ["tfoot", {
    reserved: false
  }], ["th", {
    reserved: false
  }], ["thead", {
    reserved: false
  }], ["time", {
    reserved: false
  }], ["title", {
    reserved: true
  }], ["tr", {
    reserved: false
  }], ["track", {
    reserved: true
  }], ["tt", {
    reserved: false
  }], ["u", {
    reserved: false
  }], ["ul", {
    reserved: false
  }], ["var", {
    reserved: false
  }], ["video", {
    reserved: false
  }], ["wbr", {
    reserved: false
  }], ["xmp", {
    reserved: false
  }]];
  var domMap = {
    entries: function entries() {
      return dom;
    },
    get: function get(key) {
      var item = dom.find(function(tuple) {
        return tuple[0] === key ? true : false;
      });
      return item && item[1];
    },
    has: function has2(key) {
      return !!this.get(key);
    },
    keys: function keys2() {
      return dom.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
        return key;
      });
    },
    values: function values2() {
      return dom.map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), values3 = _ref4[1];
        return values3;
      });
    }
  };
  var _default2 = domMap;
  exports.default = _default2;
});
unwrapExports(domMap_1);
var commandRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var commandRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "menuitem"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget"]]
  };
  var _default2 = commandRole;
  exports.default = _default2;
});
unwrapExports(commandRole_1);
var compositeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var compositeRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-disabled": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget"]]
  };
  var _default2 = compositeRole;
  exports.default = _default2;
});
unwrapExports(compositeRole_1);
var inputRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var inputRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null
    },
    relatedConcepts: [{
      concept: {
        name: "input"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget"]]
  };
  var _default2 = inputRole;
  exports.default = _default2;
});
unwrapExports(inputRole_1);
var landmarkRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var landmarkRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = landmarkRole;
  exports.default = _default2;
});
unwrapExports(landmarkRole_1);
var rangeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var rangeRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-valuemax": null,
      "aria-valuemin": null,
      "aria-valuenow": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default2 = rangeRole;
  exports.default = _default2;
});
unwrapExports(rangeRole_1);
var roletypeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var roletypeRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {
      "aria-atomic": null,
      "aria-busy": null,
      "aria-controls": null,
      "aria-current": null,
      "aria-describedby": null,
      "aria-details": null,
      "aria-dropeffect": null,
      "aria-flowto": null,
      "aria-grabbed": null,
      "aria-hidden": null,
      "aria-keyshortcuts": null,
      "aria-label": null,
      "aria-labelledby": null,
      "aria-live": null,
      "aria-owns": null,
      "aria-relevant": null,
      "aria-roledescription": null
    },
    relatedConcepts: [{
      concept: {
        name: "rel"
      },
      module: "HTML"
    }, {
      concept: {
        name: "role"
      },
      module: "XHTML"
    }, {
      concept: {
        name: "type"
      },
      module: "Dublin Core"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: []
  };
  var _default2 = roletypeRole;
  exports.default = _default2;
});
unwrapExports(roletypeRole_1);
var sectionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var sectionRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "frontmatter"
      },
      module: "DTB"
    }, {
      concept: {
        name: "level"
      },
      module: "DTB"
    }, {
      concept: {
        name: "level"
      },
      module: "SMIL"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default2 = sectionRole;
  exports.default = _default2;
});
unwrapExports(sectionRole_1);
var sectionheadRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var sectionheadRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default2 = sectionheadRole;
  exports.default = _default2;
});
unwrapExports(sectionheadRole_1);
var selectRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var selectRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-orientation": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "group"]]
  };
  var _default2 = selectRole;
  exports.default = _default2;
});
unwrapExports(selectRole_1);
var structureRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var structureRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype"]]
  };
  var _default2 = structureRole;
  exports.default = _default2;
});
unwrapExports(structureRole_1);
var widgetRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var widgetRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype"]]
  };
  var _default2 = widgetRole;
  exports.default = _default2;
});
unwrapExports(widgetRole_1);
var windowRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var windowRole = {
    abstract: true,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-modal": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype"]]
  };
  var _default2 = windowRole;
  exports.default = _default2;
});
unwrapExports(windowRole_1);
var ariaAbstractRoles_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _commandRole = _interopRequireDefault(commandRole_1);
  var _compositeRole = _interopRequireDefault(compositeRole_1);
  var _inputRole = _interopRequireDefault(inputRole_1);
  var _landmarkRole = _interopRequireDefault(landmarkRole_1);
  var _rangeRole = _interopRequireDefault(rangeRole_1);
  var _roletypeRole = _interopRequireDefault(roletypeRole_1);
  var _sectionRole = _interopRequireDefault(sectionRole_1);
  var _sectionheadRole = _interopRequireDefault(sectionheadRole_1);
  var _selectRole = _interopRequireDefault(selectRole_1);
  var _structureRole = _interopRequireDefault(structureRole_1);
  var _widgetRole = _interopRequireDefault(widgetRole_1);
  var _windowRole = _interopRequireDefault(windowRole_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var ariaAbstractRoles = [["command", _commandRole.default], ["composite", _compositeRole.default], ["input", _inputRole.default], ["landmark", _landmarkRole.default], ["range", _rangeRole.default], ["roletype", _roletypeRole.default], ["section", _sectionRole.default], ["sectionhead", _sectionheadRole.default], ["select", _selectRole.default], ["structure", _structureRole.default], ["widget", _widgetRole.default], ["window", _windowRole.default]];
  var _default2 = ariaAbstractRoles;
  exports.default = _default2;
});
unwrapExports(ariaAbstractRoles_1);
var alertRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var alertRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-atomic": "true",
      "aria-live": "assertive"
    },
    relatedConcepts: [{
      concept: {
        name: "alert"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = alertRole;
  exports.default = _default2;
});
unwrapExports(alertRole_1);
var alertdialogRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var alertdialogRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "alert"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "alert"], ["roletype", "window", "dialog"]]
  };
  var _default2 = alertdialogRole;
  exports.default = _default2;
});
unwrapExports(alertdialogRole_1);
var applicationRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var applicationRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "Device Independence Delivery Unit"
      }
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default2 = applicationRole;
  exports.default = _default2;
});
unwrapExports(applicationRole_1);
var articleRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var articleRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-posinset": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        name: "article"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "document"]]
  };
  var _default2 = articleRole;
  exports.default = _default2;
});
unwrapExports(articleRole_1);
var bannerRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var bannerRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        constraints: ["direct descendant of document"],
        name: "header"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = bannerRole;
  exports.default = _default2;
});
unwrapExports(bannerRole_1);
var blockquoteRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var blockquoteRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = blockquoteRole;
  exports.default = _default2;
});
unwrapExports(blockquoteRole_1);
var buttonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var buttonRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-pressed": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-pressed"
        }, {
          name: "type",
          value: "checkbox"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "aria-expanded",
          value: "false"
        }],
        name: "summary"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "aria-expanded",
          value: "true"
        }],
        constraints: ["direct descendant of details element with the open attribute defined"],
        name: "summary"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "type",
          value: "button"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "type",
          value: "image"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "type",
          value: "reset"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "type",
          value: "submit"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        name: "button"
      },
      module: "HTML"
    }, {
      concept: {
        name: "trigger"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command"]]
  };
  var _default2 = buttonRole;
  exports.default = _default2;
});
unwrapExports(buttonRole_1);
var captionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var captionRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: ["figure", "grid", "table"],
    requiredContextRole: ["figure", "grid", "table"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = captionRole;
  exports.default = _default2;
});
unwrapExports(captionRole_1);
var cellRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var cellRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-colindex": null,
      "aria-colspan": null,
      "aria-rowindex": null,
      "aria-rowspan": null
    },
    relatedConcepts: [{
      concept: {
        constraints: ["descendant of table"],
        name: "td"
      },
      module: "HTML"
    }],
    requireContextRole: ["row"],
    requiredContextRole: ["row"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = cellRole;
  exports.default = _default2;
});
unwrapExports(cellRole_1);
var checkboxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var checkboxRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-checked": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "checkbox"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        name: "option"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input"]]
  };
  var _default2 = checkboxRole;
  exports.default = _default2;
});
unwrapExports(checkboxRole_1);
var codeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var codeRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = codeRole;
  exports.default = _default2;
});
unwrapExports(codeRole_1);
var columnheaderRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var columnheaderRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-sort": null
    },
    relatedConcepts: [{
      attributes: [{
        name: "scope",
        value: "col"
      }],
      concept: {
        name: "th"
      },
      module: "HTML"
    }],
    requireContextRole: ["row"],
    requiredContextRole: ["row"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
  };
  var _default2 = columnheaderRole;
  exports.default = _default2;
});
unwrapExports(columnheaderRole_1);
var comboboxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var comboboxRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-autocomplete": null,
      "aria-errormessage": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null,
      "aria-expanded": "false",
      "aria-haspopup": "listbox"
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "email"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "search"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "tel"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "text"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "url"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "list"
        }, {
          name: "type",
          value: "url"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "multiple"
        }, {
          constraints: ["undefined"],
          name: "size"
        }],
        name: "select"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "multiple"
        }, {
          name: "size",
          value: 1
        }],
        name: "select"
      },
      module: "HTML"
    }, {
      concept: {
        name: "select"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-controls": null,
      "aria-expanded": "false"
    },
    superClass: [["roletype", "widget", "input"]]
  };
  var _default2 = comboboxRole;
  exports.default = _default2;
});
unwrapExports(comboboxRole_1);
var complementaryRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var complementaryRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "aside"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = complementaryRole;
  exports.default = _default2;
});
unwrapExports(complementaryRole_1);
var contentinfoRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var contentinfoRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        constraints: ["direct descendant of document"],
        name: "footer"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = contentinfoRole;
  exports.default = _default2;
});
unwrapExports(contentinfoRole_1);
var definitionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var definitionRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "dd"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = definitionRole;
  exports.default = _default2;
});
unwrapExports(definitionRole_1);
var deletionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var deletionRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = deletionRole;
  exports.default = _default2;
});
unwrapExports(deletionRole_1);
var dialogRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var dialogRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "dialog"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "window"]]
  };
  var _default2 = dialogRole;
  exports.default = _default2;
});
unwrapExports(dialogRole_1);
var directoryRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var directoryRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      module: "DAISY Guide"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "list"]]
  };
  var _default2 = directoryRole;
  exports.default = _default2;
});
unwrapExports(directoryRole_1);
var documentRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var documentRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "Device Independence Delivery Unit"
      }
    }, {
      concept: {
        name: "body"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default2 = documentRole;
  exports.default = _default2;
});
unwrapExports(documentRole_1);
var emphasisRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var emphasisRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = emphasisRole;
  exports.default = _default2;
});
unwrapExports(emphasisRole_1);
var feedRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var feedRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["article"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "list"]]
  };
  var _default2 = feedRole;
  exports.default = _default2;
});
unwrapExports(feedRole_1);
var figureRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var figureRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "figure"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = figureRole;
  exports.default = _default2;
});
unwrapExports(figureRole_1);
var formRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var formRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-label"
        }],
        name: "form"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-labelledby"
        }],
        name: "form"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "name"
        }],
        name: "form"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = formRole;
  exports.default = _default2;
});
unwrapExports(formRole_1);
var genericRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var genericRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "span"
      },
      module: "HTML"
    }, {
      concept: {
        name: "div"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default2 = genericRole;
  exports.default = _default2;
});
unwrapExports(genericRole_1);
var gridRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var gridRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-multiselectable": null,
      "aria-readonly": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "role",
          value: "grid"
        }],
        name: "table"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["row"], ["row", "rowgroup"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite"], ["roletype", "structure", "section", "table"]]
  };
  var _default2 = gridRole;
  exports.default = _default2;
});
unwrapExports(gridRole_1);
var gridcellRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var gridcellRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null,
      "aria-selected": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "role",
          value: "gridcell"
        }],
        name: "td"
      },
      module: "HTML"
    }],
    requireContextRole: ["row"],
    requiredContextRole: ["row"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "cell"], ["roletype", "widget"]]
  };
  var _default2 = gridcellRole;
  exports.default = _default2;
});
unwrapExports(gridcellRole_1);
var groupRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var groupRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-disabled": null
    },
    relatedConcepts: [{
      concept: {
        name: "details"
      },
      module: "HTML"
    }, {
      concept: {
        name: "fieldset"
      },
      module: "HTML"
    }, {
      concept: {
        name: "optgroup"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = groupRole;
  exports.default = _default2;
});
unwrapExports(groupRole_1);
var headingRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var headingRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-level": "2"
    },
    relatedConcepts: [{
      concept: {
        name: "h1"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h2"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h3"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h4"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h5"
      },
      module: "HTML"
    }, {
      concept: {
        name: "h6"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-level": "2"
    },
    superClass: [["roletype", "structure", "sectionhead"]]
  };
  var _default2 = headingRole;
  exports.default = _default2;
});
unwrapExports(headingRole_1);
var imgRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var imgRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "alt"
        }],
        name: "img"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "alt"
        }],
        name: "img"
      },
      module: "HTML"
    }, {
      concept: {
        name: "imggroup"
      },
      module: "DTB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = imgRole;
  exports.default = _default2;
});
unwrapExports(imgRole_1);
var insertionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var insertionRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = insertionRole;
  exports.default = _default2;
});
unwrapExports(insertionRole_1);
var linkRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var linkRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-expanded": null,
      "aria-haspopup": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "href"
        }],
        name: "a"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "href"
        }],
        name: "area"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "href"
        }],
        name: "link"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command"]]
  };
  var _default2 = linkRole;
  exports.default = _default2;
});
unwrapExports(linkRole_1);
var listRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var listRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "menu"
      },
      module: "HTML"
    }, {
      concept: {
        name: "ol"
      },
      module: "HTML"
    }, {
      concept: {
        name: "ul"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["listitem"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = listRole;
  exports.default = _default2;
});
unwrapExports(listRole_1);
var listboxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var listboxRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-invalid": null,
      "aria-multiselectable": null,
      "aria-readonly": null,
      "aria-required": null,
      "aria-orientation": "vertical"
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: [">1"],
          name: "size"
        }, {
          name: "multiple"
        }],
        name: "select"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: [">1"],
          name: "size"
        }],
        name: "select"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          name: "multiple"
        }],
        name: "select"
      },
      module: "HTML"
    }, {
      concept: {
        name: "datalist"
      },
      module: "HTML"
    }, {
      concept: {
        name: "list"
      },
      module: "ARIA"
    }, {
      concept: {
        name: "select"
      },
      module: "XForms"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["option", "group"], ["option"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
  };
  var _default2 = listboxRole;
  exports.default = _default2;
});
unwrapExports(listboxRole_1);
var listitemRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var listitemRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-level": null,
      "aria-posinset": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        constraints: ["direct descendant of ol, ul or menu"],
        name: "li"
      },
      module: "HTML"
    }, {
      concept: {
        name: "item"
      },
      module: "XForms"
    }],
    requireContextRole: ["directory", "list"],
    requiredContextRole: ["directory", "list"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = listitemRole;
  exports.default = _default2;
});
unwrapExports(listitemRole_1);
var logRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var logRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-live": "polite"
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = logRole;
  exports.default = _default2;
});
unwrapExports(logRole_1);
var mainRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var mainRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "main"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = mainRole;
  exports.default = _default2;
});
unwrapExports(mainRole_1);
var marqueeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var marqueeRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = marqueeRole;
  exports.default = _default2;
});
unwrapExports(marqueeRole_1);
var mathRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var mathRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "math"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = mathRole;
  exports.default = _default2;
});
unwrapExports(mathRole_1);
var menuRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var menuRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-orientation": "vertical"
    },
    relatedConcepts: [{
      concept: {
        name: "MENU"
      },
      module: "JAPI"
    }, {
      concept: {
        name: "list"
      },
      module: "ARIA"
    }, {
      concept: {
        name: "select"
      },
      module: "XForms"
    }, {
      concept: {
        name: "sidebar"
      },
      module: "DTB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
  };
  var _default2 = menuRole;
  exports.default = _default2;
});
unwrapExports(menuRole_1);
var menubarRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var menubarRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-orientation": "horizontal"
    },
    relatedConcepts: [{
      concept: {
        name: "toolbar"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["menuitem", "group"], ["menuitemradio", "group"], ["menuitemcheckbox", "group"], ["menuitem"], ["menuitemcheckbox"], ["menuitemradio"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select", "menu"], ["roletype", "structure", "section", "group", "select", "menu"]]
  };
  var _default2 = menubarRole;
  exports.default = _default2;
});
unwrapExports(menubarRole_1);
var menuitemRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var menuitemRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-posinset": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        name: "MENU_ITEM"
      },
      module: "JAPI"
    }, {
      concept: {
        name: "listitem"
      },
      module: "ARIA"
    }, {
      concept: {
        name: "menuitem"
      },
      module: "HTML"
    }, {
      concept: {
        name: "option"
      },
      module: "ARIA"
    }],
    requireContextRole: ["group", "menu", "menubar"],
    requiredContextRole: ["group", "menu", "menubar"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command"]]
  };
  var _default2 = menuitemRole;
  exports.default = _default2;
});
unwrapExports(menuitemRole_1);
var menuitemcheckboxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var menuitemcheckboxRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "menuitem"
      },
      module: "ARIA"
    }],
    requireContextRole: ["group", "menu", "menubar"],
    requiredContextRole: ["group", "menu", "menubar"],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input", "checkbox"], ["roletype", "widget", "command", "menuitem"]]
  };
  var _default2 = menuitemcheckboxRole;
  exports.default = _default2;
});
unwrapExports(menuitemcheckboxRole_1);
var menuitemradioRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var menuitemradioRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "menuitem"
      },
      module: "ARIA"
    }],
    requireContextRole: ["group", "menu", "menubar"],
    requiredContextRole: ["group", "menu", "menubar"],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input", "checkbox", "menuitemcheckbox"], ["roletype", "widget", "command", "menuitem", "menuitemcheckbox"], ["roletype", "widget", "input", "radio"]]
  };
  var _default2 = menuitemradioRole;
  exports.default = _default2;
});
unwrapExports(menuitemradioRole_1);
var meterRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var meterRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-valuetext": null,
      "aria-valuemax": "100",
      "aria-valuemin": "0"
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-valuenow": null
    },
    superClass: [["roletype", "structure", "range"]]
  };
  var _default2 = meterRole;
  exports.default = _default2;
});
unwrapExports(meterRole_1);
var navigationRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var navigationRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "nav"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = navigationRole;
  exports.default = _default2;
});
unwrapExports(navigationRole_1);
var noneRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var noneRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: [],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: []
  };
  var _default2 = noneRole;
  exports.default = _default2;
});
unwrapExports(noneRole_1);
var noteRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var noteRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = noteRole;
  exports.default = _default2;
});
unwrapExports(noteRole_1);
var optionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var optionRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-checked": null,
      "aria-posinset": null,
      "aria-setsize": null,
      "aria-selected": "false"
    },
    relatedConcepts: [{
      concept: {
        name: "item"
      },
      module: "XForms"
    }, {
      concept: {
        name: "listitem"
      },
      module: "ARIA"
    }, {
      concept: {
        name: "option"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-selected": "false"
    },
    superClass: [["roletype", "widget", "input"]]
  };
  var _default2 = optionRole;
  exports.default = _default2;
});
unwrapExports(optionRole_1);
var paragraphRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var paragraphRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = paragraphRole;
  exports.default = _default2;
});
unwrapExports(paragraphRole_1);
var presentationRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var presentationRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default2 = presentationRole;
  exports.default = _default2;
});
unwrapExports(presentationRole_1);
var progressbarRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var progressbarRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-valuetext": null
    },
    relatedConcepts: [{
      concept: {
        name: "progress"
      },
      module: "HTML"
    }, {
      concept: {
        name: "status"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
  };
  var _default2 = progressbarRole;
  exports.default = _default2;
});
unwrapExports(progressbarRole_1);
var radioRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var radioRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-checked": null,
      "aria-posinset": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "radio"
        }],
        name: "input"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input"]]
  };
  var _default2 = radioRole;
  exports.default = _default2;
});
unwrapExports(radioRole_1);
var radiogroupRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var radiogroupRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null
    },
    relatedConcepts: [{
      concept: {
        name: "list"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["radio"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
  };
  var _default2 = radiogroupRole;
  exports.default = _default2;
});
unwrapExports(radiogroupRole_1);
var regionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var regionRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-label"
        }],
        name: "section"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["set"],
          name: "aria-labelledby"
        }],
        name: "section"
      },
      module: "HTML"
    }, {
      concept: {
        name: "Device Independence Glossart perceivable unit"
      }
    }, {
      concept: {
        name: "frame"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = regionRole;
  exports.default = _default2;
});
unwrapExports(regionRole_1);
var rowRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var rowRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-colindex": null,
      "aria-expanded": null,
      "aria-level": null,
      "aria-posinset": null,
      "aria-rowindex": null,
      "aria-selected": null,
      "aria-setsize": null
    },
    relatedConcepts: [{
      concept: {
        name: "tr"
      },
      module: "HTML"
    }],
    requireContextRole: ["grid", "rowgroup", "table", "treegrid"],
    requiredContextRole: ["grid", "rowgroup", "table", "treegrid"],
    requiredOwnedElements: [["cell"], ["columnheader"], ["gridcell"], ["rowheader"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "group"], ["roletype", "widget"]]
  };
  var _default2 = rowRole;
  exports.default = _default2;
});
unwrapExports(rowRole_1);
var rowgroupRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var rowgroupRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "tbody"
      },
      module: "HTML"
    }, {
      concept: {
        name: "tfoot"
      },
      module: "HTML"
    }, {
      concept: {
        name: "thead"
      },
      module: "HTML"
    }],
    requireContextRole: ["grid", "table", "treegrid"],
    requiredContextRole: ["grid", "table", "treegrid"],
    requiredOwnedElements: [["row"]],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default2 = rowgroupRole;
  exports.default = _default2;
});
unwrapExports(rowgroupRole_1);
var rowheaderRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var rowheaderRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-sort": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "scope",
          value: "row"
        }],
        name: "th"
      },
      module: "HTML"
    }],
    requireContextRole: ["row"],
    requiredContextRole: ["row"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "cell"], ["roletype", "structure", "section", "cell", "gridcell"], ["roletype", "widget", "gridcell"], ["roletype", "structure", "sectionhead"]]
  };
  var _default2 = rowheaderRole;
  exports.default = _default2;
});
unwrapExports(rowheaderRole_1);
var scrollbarRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var scrollbarRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-valuetext": null,
      "aria-orientation": "vertical",
      "aria-valuemax": "100",
      "aria-valuemin": "0"
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-controls": null,
      "aria-valuenow": null
    },
    superClass: [["roletype", "structure", "range"], ["roletype", "widget"]]
  };
  var _default2 = scrollbarRole;
  exports.default = _default2;
});
unwrapExports(scrollbarRole_1);
var searchRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var searchRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = searchRole;
  exports.default = _default2;
});
unwrapExports(searchRole_1);
var searchboxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var searchboxRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "search"
        }],
        name: "input"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "input", "textbox"]]
  };
  var _default2 = searchboxRole;
  exports.default = _default2;
});
unwrapExports(searchboxRole_1);
var separatorRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var separatorRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-orientation": "horizontal",
      "aria-valuemax": "100",
      "aria-valuemin": "0",
      "aria-valuenow": null,
      "aria-valuetext": null
    },
    relatedConcepts: [{
      concept: {
        name: "hr"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure"]]
  };
  var _default2 = separatorRole;
  exports.default = _default2;
});
unwrapExports(separatorRole_1);
var sliderRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var sliderRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-haspopup": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-valuetext": null,
      "aria-orientation": "horizontal",
      "aria-valuemax": "100",
      "aria-valuemin": "0"
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "range"
        }],
        name: "input"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-valuenow": null
    },
    superClass: [["roletype", "widget", "input"], ["roletype", "structure", "range"]]
  };
  var _default2 = sliderRole;
  exports.default = _default2;
});
unwrapExports(sliderRole_1);
var spinbuttonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var spinbuttonRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null,
      "aria-readonly": null,
      "aria-required": null,
      "aria-valuetext": null,
      "aria-valuenow": "0"
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          name: "type",
          value: "number"
        }],
        name: "input"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite"], ["roletype", "widget", "input"], ["roletype", "structure", "range"]]
  };
  var _default2 = spinbuttonRole;
  exports.default = _default2;
});
unwrapExports(spinbuttonRole_1);
var statusRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var statusRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-atomic": "true",
      "aria-live": "polite"
    },
    relatedConcepts: [{
      concept: {
        name: "output"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = statusRole;
  exports.default = _default2;
});
unwrapExports(statusRole_1);
var strongRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var strongRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = strongRole;
  exports.default = _default2;
});
unwrapExports(strongRole_1);
var subscriptRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var subscriptRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = subscriptRole;
  exports.default = _default2;
});
unwrapExports(subscriptRole_1);
var superscriptRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var superscriptRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["prohibited"],
    prohibitedProps: ["aria-label", "aria-labelledby"],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = superscriptRole;
  exports.default = _default2;
});
unwrapExports(superscriptRole_1);
var switchRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var switchRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "button"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-checked": null
    },
    superClass: [["roletype", "widget", "input", "checkbox"]]
  };
  var _default2 = switchRole;
  exports.default = _default2;
});
unwrapExports(switchRole_1);
var tabRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var tabRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-posinset": null,
      "aria-setsize": null,
      "aria-selected": "false"
    },
    relatedConcepts: [],
    requireContextRole: ["tablist"],
    requiredContextRole: ["tablist"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "sectionhead"], ["roletype", "widget"]]
  };
  var _default2 = tabRole;
  exports.default = _default2;
});
unwrapExports(tabRole_1);
var tableRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var tableRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-colcount": null,
      "aria-rowcount": null
    },
    relatedConcepts: [{
      concept: {
        name: "table"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["row"], ["row", "rowgroup"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = tableRole;
  exports.default = _default2;
});
unwrapExports(tableRole_1);
var tablistRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var tablistRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-level": null,
      "aria-multiselectable": null,
      "aria-orientation": "horizontal"
    },
    relatedConcepts: [{
      module: "DAISY",
      concept: {
        name: "guide"
      }
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["tab"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite"]]
  };
  var _default2 = tablistRole;
  exports.default = _default2;
});
unwrapExports(tablistRole_1);
var tabpanelRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var tabpanelRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = tabpanelRole;
  exports.default = _default2;
});
unwrapExports(tabpanelRole_1);
var termRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var termRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "dfn"
      },
      module: "HTML"
    }, {
      concept: {
        name: "dt"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = termRole;
  exports.default = _default2;
});
unwrapExports(termRole_1);
var textboxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var textboxRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-activedescendant": null,
      "aria-autocomplete": null,
      "aria-errormessage": null,
      "aria-haspopup": null,
      "aria-invalid": null,
      "aria-multiline": null,
      "aria-placeholder": null,
      "aria-readonly": null,
      "aria-required": null
    },
    relatedConcepts: [{
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "type"
        }, {
          constraints: ["undefined"],
          name: "list"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "email"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "tel"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "text"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        attributes: [{
          constraints: ["undefined"],
          name: "list"
        }, {
          name: "type",
          value: "url"
        }],
        name: "input"
      },
      module: "HTML"
    }, {
      concept: {
        name: "input"
      },
      module: "XForms"
    }, {
      concept: {
        name: "textarea"
      },
      module: "HTML"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "input"]]
  };
  var _default2 = textboxRole;
  exports.default = _default2;
});
unwrapExports(textboxRole_1);
var timeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var timeRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = timeRole;
  exports.default = _default2;
});
unwrapExports(timeRole_1);
var timerRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var timerRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "status"]]
  };
  var _default2 = timerRole;
  exports.default = _default2;
});
unwrapExports(timerRole_1);
var toolbarRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var toolbarRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-orientation": "horizontal"
    },
    relatedConcepts: [{
      concept: {
        name: "menubar"
      },
      module: "ARIA"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "group"]]
  };
  var _default2 = toolbarRole;
  exports.default = _default2;
});
unwrapExports(toolbarRole_1);
var tooltipRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var tooltipRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = tooltipRole;
  exports.default = _default2;
});
unwrapExports(tooltipRole_1);
var treeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var treeRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null,
      "aria-multiselectable": null,
      "aria-required": null,
      "aria-orientation": "vertical"
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["treeitem", "group"], ["treeitem"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "select"], ["roletype", "structure", "section", "group", "select"]]
  };
  var _default2 = treeRole;
  exports.default = _default2;
});
unwrapExports(treeRole_1);
var treegridRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var treegridRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["row"], ["row", "rowgroup"]],
    requiredProps: {},
    superClass: [["roletype", "widget", "composite", "grid"], ["roletype", "structure", "section", "table", "grid"], ["roletype", "widget", "composite", "select", "tree"], ["roletype", "structure", "section", "group", "select", "tree"]]
  };
  var _default2 = treegridRole;
  exports.default = _default2;
});
unwrapExports(treegridRole_1);
var treeitemRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var treeitemRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-expanded": null,
      "aria-haspopup": null
    },
    relatedConcepts: [],
    requireContextRole: ["group", "tree"],
    requiredContextRole: ["group", "tree"],
    requiredOwnedElements: [],
    requiredProps: {
      "aria-selected": null
    },
    superClass: [["roletype", "structure", "section", "listitem"], ["roletype", "widget", "input", "option"]]
  };
  var _default2 = treeitemRole;
  exports.default = _default2;
});
unwrapExports(treeitemRole_1);
var ariaLiteralRoles_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _alertRole = _interopRequireDefault(alertRole_1);
  var _alertdialogRole = _interopRequireDefault(alertdialogRole_1);
  var _applicationRole = _interopRequireDefault(applicationRole_1);
  var _articleRole = _interopRequireDefault(articleRole_1);
  var _bannerRole = _interopRequireDefault(bannerRole_1);
  var _blockquoteRole = _interopRequireDefault(blockquoteRole_1);
  var _buttonRole = _interopRequireDefault(buttonRole_1);
  var _captionRole = _interopRequireDefault(captionRole_1);
  var _cellRole = _interopRequireDefault(cellRole_1);
  var _checkboxRole = _interopRequireDefault(checkboxRole_1);
  var _codeRole = _interopRequireDefault(codeRole_1);
  var _columnheaderRole = _interopRequireDefault(columnheaderRole_1);
  var _comboboxRole = _interopRequireDefault(comboboxRole_1);
  var _complementaryRole = _interopRequireDefault(complementaryRole_1);
  var _contentinfoRole = _interopRequireDefault(contentinfoRole_1);
  var _definitionRole = _interopRequireDefault(definitionRole_1);
  var _deletionRole = _interopRequireDefault(deletionRole_1);
  var _dialogRole = _interopRequireDefault(dialogRole_1);
  var _directoryRole = _interopRequireDefault(directoryRole_1);
  var _documentRole = _interopRequireDefault(documentRole_1);
  var _emphasisRole = _interopRequireDefault(emphasisRole_1);
  var _feedRole = _interopRequireDefault(feedRole_1);
  var _figureRole = _interopRequireDefault(figureRole_1);
  var _formRole = _interopRequireDefault(formRole_1);
  var _genericRole = _interopRequireDefault(genericRole_1);
  var _gridRole = _interopRequireDefault(gridRole_1);
  var _gridcellRole = _interopRequireDefault(gridcellRole_1);
  var _groupRole = _interopRequireDefault(groupRole_1);
  var _headingRole = _interopRequireDefault(headingRole_1);
  var _imgRole = _interopRequireDefault(imgRole_1);
  var _insertionRole = _interopRequireDefault(insertionRole_1);
  var _linkRole = _interopRequireDefault(linkRole_1);
  var _listRole = _interopRequireDefault(listRole_1);
  var _listboxRole = _interopRequireDefault(listboxRole_1);
  var _listitemRole = _interopRequireDefault(listitemRole_1);
  var _logRole = _interopRequireDefault(logRole_1);
  var _mainRole = _interopRequireDefault(mainRole_1);
  var _marqueeRole = _interopRequireDefault(marqueeRole_1);
  var _mathRole = _interopRequireDefault(mathRole_1);
  var _menuRole = _interopRequireDefault(menuRole_1);
  var _menubarRole = _interopRequireDefault(menubarRole_1);
  var _menuitemRole = _interopRequireDefault(menuitemRole_1);
  var _menuitemcheckboxRole = _interopRequireDefault(menuitemcheckboxRole_1);
  var _menuitemradioRole = _interopRequireDefault(menuitemradioRole_1);
  var _meterRole = _interopRequireDefault(meterRole_1);
  var _navigationRole = _interopRequireDefault(navigationRole_1);
  var _noneRole = _interopRequireDefault(noneRole_1);
  var _noteRole = _interopRequireDefault(noteRole_1);
  var _optionRole = _interopRequireDefault(optionRole_1);
  var _paragraphRole = _interopRequireDefault(paragraphRole_1);
  var _presentationRole = _interopRequireDefault(presentationRole_1);
  var _progressbarRole = _interopRequireDefault(progressbarRole_1);
  var _radioRole = _interopRequireDefault(radioRole_1);
  var _radiogroupRole = _interopRequireDefault(radiogroupRole_1);
  var _regionRole = _interopRequireDefault(regionRole_1);
  var _rowRole = _interopRequireDefault(rowRole_1);
  var _rowgroupRole = _interopRequireDefault(rowgroupRole_1);
  var _rowheaderRole = _interopRequireDefault(rowheaderRole_1);
  var _scrollbarRole = _interopRequireDefault(scrollbarRole_1);
  var _searchRole = _interopRequireDefault(searchRole_1);
  var _searchboxRole = _interopRequireDefault(searchboxRole_1);
  var _separatorRole = _interopRequireDefault(separatorRole_1);
  var _sliderRole = _interopRequireDefault(sliderRole_1);
  var _spinbuttonRole = _interopRequireDefault(spinbuttonRole_1);
  var _statusRole = _interopRequireDefault(statusRole_1);
  var _strongRole = _interopRequireDefault(strongRole_1);
  var _subscriptRole = _interopRequireDefault(subscriptRole_1);
  var _superscriptRole = _interopRequireDefault(superscriptRole_1);
  var _switchRole = _interopRequireDefault(switchRole_1);
  var _tabRole = _interopRequireDefault(tabRole_1);
  var _tableRole = _interopRequireDefault(tableRole_1);
  var _tablistRole = _interopRequireDefault(tablistRole_1);
  var _tabpanelRole = _interopRequireDefault(tabpanelRole_1);
  var _termRole = _interopRequireDefault(termRole_1);
  var _textboxRole = _interopRequireDefault(textboxRole_1);
  var _timeRole = _interopRequireDefault(timeRole_1);
  var _timerRole = _interopRequireDefault(timerRole_1);
  var _toolbarRole = _interopRequireDefault(toolbarRole_1);
  var _tooltipRole = _interopRequireDefault(tooltipRole_1);
  var _treeRole = _interopRequireDefault(treeRole_1);
  var _treegridRole = _interopRequireDefault(treegridRole_1);
  var _treeitemRole = _interopRequireDefault(treeitemRole_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var ariaLiteralRoles = [["alert", _alertRole.default], ["alertdialog", _alertdialogRole.default], ["application", _applicationRole.default], ["article", _articleRole.default], ["banner", _bannerRole.default], ["blockquote", _blockquoteRole.default], ["button", _buttonRole.default], ["caption", _captionRole.default], ["cell", _cellRole.default], ["checkbox", _checkboxRole.default], ["code", _codeRole.default], ["columnheader", _columnheaderRole.default], ["combobox", _comboboxRole.default], ["complementary", _complementaryRole.default], ["contentinfo", _contentinfoRole.default], ["definition", _definitionRole.default], ["deletion", _deletionRole.default], ["dialog", _dialogRole.default], ["directory", _directoryRole.default], ["document", _documentRole.default], ["emphasis", _emphasisRole.default], ["feed", _feedRole.default], ["figure", _figureRole.default], ["form", _formRole.default], ["generic", _genericRole.default], ["grid", _gridRole.default], ["gridcell", _gridcellRole.default], ["group", _groupRole.default], ["heading", _headingRole.default], ["img", _imgRole.default], ["insertion", _insertionRole.default], ["link", _linkRole.default], ["list", _listRole.default], ["listbox", _listboxRole.default], ["listitem", _listitemRole.default], ["log", _logRole.default], ["main", _mainRole.default], ["marquee", _marqueeRole.default], ["math", _mathRole.default], ["menu", _menuRole.default], ["menubar", _menubarRole.default], ["menuitem", _menuitemRole.default], ["menuitemcheckbox", _menuitemcheckboxRole.default], ["menuitemradio", _menuitemradioRole.default], ["meter", _meterRole.default], ["navigation", _navigationRole.default], ["none", _noneRole.default], ["note", _noteRole.default], ["option", _optionRole.default], ["paragraph", _paragraphRole.default], ["presentation", _presentationRole.default], ["progressbar", _progressbarRole.default], ["radio", _radioRole.default], ["radiogroup", _radiogroupRole.default], ["region", _regionRole.default], ["row", _rowRole.default], ["rowgroup", _rowgroupRole.default], ["rowheader", _rowheaderRole.default], ["scrollbar", _scrollbarRole.default], ["search", _searchRole.default], ["searchbox", _searchboxRole.default], ["separator", _separatorRole.default], ["slider", _sliderRole.default], ["spinbutton", _spinbuttonRole.default], ["status", _statusRole.default], ["strong", _strongRole.default], ["subscript", _subscriptRole.default], ["superscript", _superscriptRole.default], ["switch", _switchRole.default], ["tab", _tabRole.default], ["table", _tableRole.default], ["tablist", _tablistRole.default], ["tabpanel", _tabpanelRole.default], ["term", _termRole.default], ["textbox", _textboxRole.default], ["time", _timeRole.default], ["timer", _timerRole.default], ["toolbar", _toolbarRole.default], ["tooltip", _tooltipRole.default], ["tree", _treeRole.default], ["treegrid", _treegridRole.default], ["treeitem", _treeitemRole.default]];
  var _default2 = ariaLiteralRoles;
  exports.default = _default2;
});
unwrapExports(ariaLiteralRoles_1);
var docAbstractRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docAbstractRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "abstract [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = docAbstractRole;
  exports.default = _default2;
});
unwrapExports(docAbstractRole_1);
var docAcknowledgmentsRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docAcknowledgmentsRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "acknowledgments [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = docAcknowledgmentsRole;
  exports.default = _default2;
});
unwrapExports(docAcknowledgmentsRole_1);
var docAfterwordRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docAfterwordRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "afterword [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = docAfterwordRole;
  exports.default = _default2;
});
unwrapExports(docAfterwordRole_1);
var docAppendixRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docAppendixRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "appendix [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = docAppendixRole;
  exports.default = _default2;
});
unwrapExports(docAppendixRole_1);
var docBacklinkRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docBacklinkRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "content"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "referrer [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command", "link"]]
  };
  var _default2 = docBacklinkRole;
  exports.default = _default2;
});
unwrapExports(docBacklinkRole_1);
var docBiblioentryRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docBiblioentryRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "EPUB biblioentry [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: ["doc-bibliography"],
    requiredContextRole: ["doc-bibliography"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "listitem"]]
  };
  var _default2 = docBiblioentryRole;
  exports.default = _default2;
});
unwrapExports(docBiblioentryRole_1);
var docBibliographyRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docBibliographyRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "bibliography [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["doc-biblioentry"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = docBibliographyRole;
  exports.default = _default2;
});
unwrapExports(docBibliographyRole_1);
var docBibliorefRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docBibliorefRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "biblioref [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command", "link"]]
  };
  var _default2 = docBibliorefRole;
  exports.default = _default2;
});
unwrapExports(docBibliorefRole_1);
var docChapterRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docChapterRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "chapter [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = docChapterRole;
  exports.default = _default2;
});
unwrapExports(docChapterRole_1);
var docColophonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docColophonRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "colophon [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = docColophonRole;
  exports.default = _default2;
});
unwrapExports(docColophonRole_1);
var docConclusionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docConclusionRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "conclusion [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = docConclusionRole;
  exports.default = _default2;
});
unwrapExports(docConclusionRole_1);
var docCoverRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docCoverRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "cover [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "img"]]
  };
  var _default2 = docCoverRole;
  exports.default = _default2;
});
unwrapExports(docCoverRole_1);
var docCreditRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docCreditRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "credit [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = docCreditRole;
  exports.default = _default2;
});
unwrapExports(docCreditRole_1);
var docCreditsRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docCreditsRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "credits [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = docCreditsRole;
  exports.default = _default2;
});
unwrapExports(docCreditsRole_1);
var docDedicationRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docDedicationRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "dedication [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = docDedicationRole;
  exports.default = _default2;
});
unwrapExports(docDedicationRole_1);
var docEndnoteRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docEndnoteRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "rearnote [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: ["doc-endnotes"],
    requiredContextRole: ["doc-endnotes"],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "listitem"]]
  };
  var _default2 = docEndnoteRole;
  exports.default = _default2;
});
unwrapExports(docEndnoteRole_1);
var docEndnotesRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docEndnotesRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "rearnotes [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["doc-endnote"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = docEndnotesRole;
  exports.default = _default2;
});
unwrapExports(docEndnotesRole_1);
var docEpigraphRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docEpigraphRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "epigraph [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = docEpigraphRole;
  exports.default = _default2;
});
unwrapExports(docEpigraphRole_1);
var docEpilogueRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docEpilogueRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "epilogue [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = docEpilogueRole;
  exports.default = _default2;
});
unwrapExports(docEpilogueRole_1);
var docErrataRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docErrataRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "errata [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = docErrataRole;
  exports.default = _default2;
});
unwrapExports(docErrataRole_1);
var docExampleRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docExampleRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = docExampleRole;
  exports.default = _default2;
});
unwrapExports(docExampleRole_1);
var docFootnoteRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docFootnoteRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "footnote [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = docFootnoteRole;
  exports.default = _default2;
});
unwrapExports(docFootnoteRole_1);
var docForewordRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docForewordRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "foreword [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = docForewordRole;
  exports.default = _default2;
});
unwrapExports(docForewordRole_1);
var docGlossaryRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docGlossaryRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "glossary [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [["definition"], ["term"]],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = docGlossaryRole;
  exports.default = _default2;
});
unwrapExports(docGlossaryRole_1);
var docGlossrefRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docGlossrefRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "glossref [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command", "link"]]
  };
  var _default2 = docGlossrefRole;
  exports.default = _default2;
});
unwrapExports(docGlossrefRole_1);
var docIndexRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docIndexRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "index [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
  };
  var _default2 = docIndexRole;
  exports.default = _default2;
});
unwrapExports(docIndexRole_1);
var docIntroductionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docIntroductionRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "introduction [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = docIntroductionRole;
  exports.default = _default2;
});
unwrapExports(docIntroductionRole_1);
var docNoterefRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docNoterefRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author", "contents"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "noteref [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "widget", "command", "link"]]
  };
  var _default2 = docNoterefRole;
  exports.default = _default2;
});
unwrapExports(docNoterefRole_1);
var docNoticeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docNoticeRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "notice [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "note"]]
  };
  var _default2 = docNoticeRole;
  exports.default = _default2;
});
unwrapExports(docNoticeRole_1);
var docPagebreakRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docPagebreakRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: true,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "pagebreak [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "separator"]]
  };
  var _default2 = docPagebreakRole;
  exports.default = _default2;
});
unwrapExports(docPagebreakRole_1);
var docPagelistRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docPagelistRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "page-list [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
  };
  var _default2 = docPagelistRole;
  exports.default = _default2;
});
unwrapExports(docPagelistRole_1);
var docPartRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docPartRole = {
    abstract: false,
    accessibleNameRequired: true,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "part [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = docPartRole;
  exports.default = _default2;
});
unwrapExports(docPartRole_1);
var docPrefaceRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docPrefaceRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "preface [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = docPrefaceRole;
  exports.default = _default2;
});
unwrapExports(docPrefaceRole_1);
var docPrologueRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docPrologueRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "prologue [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark"]]
  };
  var _default2 = docPrologueRole;
  exports.default = _default2;
});
unwrapExports(docPrologueRole_1);
var docPullquoteRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docPullquoteRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {},
    relatedConcepts: [{
      concept: {
        name: "pullquote [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["none"]]
  };
  var _default2 = docPullquoteRole;
  exports.default = _default2;
});
unwrapExports(docPullquoteRole_1);
var docQnaRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docQnaRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "qna [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section"]]
  };
  var _default2 = docQnaRole;
  exports.default = _default2;
});
unwrapExports(docQnaRole_1);
var docSubtitleRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docSubtitleRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "subtitle [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "sectionhead"]]
  };
  var _default2 = docSubtitleRole;
  exports.default = _default2;
});
unwrapExports(docSubtitleRole_1);
var docTipRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docTipRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "help [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "note"]]
  };
  var _default2 = docTipRole;
  exports.default = _default2;
});
unwrapExports(docTipRole_1);
var docTocRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var docTocRole = {
    abstract: false,
    accessibleNameRequired: false,
    baseConcepts: [],
    childrenPresentational: false,
    nameFrom: ["author"],
    prohibitedProps: [],
    props: {
      "aria-disabled": null,
      "aria-errormessage": null,
      "aria-expanded": null,
      "aria-haspopup": null,
      "aria-invalid": null
    },
    relatedConcepts: [{
      concept: {
        name: "toc [EPUB-SSV]"
      },
      module: "EPUB"
    }],
    requireContextRole: [],
    requiredContextRole: [],
    requiredOwnedElements: [],
    requiredProps: {},
    superClass: [["roletype", "structure", "section", "landmark", "navigation"]]
  };
  var _default2 = docTocRole;
  exports.default = _default2;
});
unwrapExports(docTocRole_1);
var ariaDpubRoles_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _docAbstractRole = _interopRequireDefault(docAbstractRole_1);
  var _docAcknowledgmentsRole = _interopRequireDefault(docAcknowledgmentsRole_1);
  var _docAfterwordRole = _interopRequireDefault(docAfterwordRole_1);
  var _docAppendixRole = _interopRequireDefault(docAppendixRole_1);
  var _docBacklinkRole = _interopRequireDefault(docBacklinkRole_1);
  var _docBiblioentryRole = _interopRequireDefault(docBiblioentryRole_1);
  var _docBibliographyRole = _interopRequireDefault(docBibliographyRole_1);
  var _docBibliorefRole = _interopRequireDefault(docBibliorefRole_1);
  var _docChapterRole = _interopRequireDefault(docChapterRole_1);
  var _docColophonRole = _interopRequireDefault(docColophonRole_1);
  var _docConclusionRole = _interopRequireDefault(docConclusionRole_1);
  var _docCoverRole = _interopRequireDefault(docCoverRole_1);
  var _docCreditRole = _interopRequireDefault(docCreditRole_1);
  var _docCreditsRole = _interopRequireDefault(docCreditsRole_1);
  var _docDedicationRole = _interopRequireDefault(docDedicationRole_1);
  var _docEndnoteRole = _interopRequireDefault(docEndnoteRole_1);
  var _docEndnotesRole = _interopRequireDefault(docEndnotesRole_1);
  var _docEpigraphRole = _interopRequireDefault(docEpigraphRole_1);
  var _docEpilogueRole = _interopRequireDefault(docEpilogueRole_1);
  var _docErrataRole = _interopRequireDefault(docErrataRole_1);
  var _docExampleRole = _interopRequireDefault(docExampleRole_1);
  var _docFootnoteRole = _interopRequireDefault(docFootnoteRole_1);
  var _docForewordRole = _interopRequireDefault(docForewordRole_1);
  var _docGlossaryRole = _interopRequireDefault(docGlossaryRole_1);
  var _docGlossrefRole = _interopRequireDefault(docGlossrefRole_1);
  var _docIndexRole = _interopRequireDefault(docIndexRole_1);
  var _docIntroductionRole = _interopRequireDefault(docIntroductionRole_1);
  var _docNoterefRole = _interopRequireDefault(docNoterefRole_1);
  var _docNoticeRole = _interopRequireDefault(docNoticeRole_1);
  var _docPagebreakRole = _interopRequireDefault(docPagebreakRole_1);
  var _docPagelistRole = _interopRequireDefault(docPagelistRole_1);
  var _docPartRole = _interopRequireDefault(docPartRole_1);
  var _docPrefaceRole = _interopRequireDefault(docPrefaceRole_1);
  var _docPrologueRole = _interopRequireDefault(docPrologueRole_1);
  var _docPullquoteRole = _interopRequireDefault(docPullquoteRole_1);
  var _docQnaRole = _interopRequireDefault(docQnaRole_1);
  var _docSubtitleRole = _interopRequireDefault(docSubtitleRole_1);
  var _docTipRole = _interopRequireDefault(docTipRole_1);
  var _docTocRole = _interopRequireDefault(docTocRole_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var ariaDpubRoles = [["doc-abstract", _docAbstractRole.default], ["doc-acknowledgments", _docAcknowledgmentsRole.default], ["doc-afterword", _docAfterwordRole.default], ["doc-appendix", _docAppendixRole.default], ["doc-backlink", _docBacklinkRole.default], ["doc-biblioentry", _docBiblioentryRole.default], ["doc-bibliography", _docBibliographyRole.default], ["doc-biblioref", _docBibliorefRole.default], ["doc-chapter", _docChapterRole.default], ["doc-colophon", _docColophonRole.default], ["doc-conclusion", _docConclusionRole.default], ["doc-cover", _docCoverRole.default], ["doc-credit", _docCreditRole.default], ["doc-credits", _docCreditsRole.default], ["doc-dedication", _docDedicationRole.default], ["doc-endnote", _docEndnoteRole.default], ["doc-endnotes", _docEndnotesRole.default], ["doc-epigraph", _docEpigraphRole.default], ["doc-epilogue", _docEpilogueRole.default], ["doc-errata", _docErrataRole.default], ["doc-example", _docExampleRole.default], ["doc-footnote", _docFootnoteRole.default], ["doc-foreword", _docForewordRole.default], ["doc-glossary", _docGlossaryRole.default], ["doc-glossref", _docGlossrefRole.default], ["doc-index", _docIndexRole.default], ["doc-introduction", _docIntroductionRole.default], ["doc-noteref", _docNoterefRole.default], ["doc-notice", _docNoticeRole.default], ["doc-pagebreak", _docPagebreakRole.default], ["doc-pagelist", _docPagelistRole.default], ["doc-part", _docPartRole.default], ["doc-preface", _docPrefaceRole.default], ["doc-prologue", _docPrologueRole.default], ["doc-pullquote", _docPullquoteRole.default], ["doc-qna", _docQnaRole.default], ["doc-subtitle", _docSubtitleRole.default], ["doc-tip", _docTipRole.default], ["doc-toc", _docTocRole.default]];
  var _default2 = ariaDpubRoles;
  exports.default = _default2;
});
unwrapExports(ariaDpubRoles_1);
var rolesMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _ariaAbstractRoles = _interopRequireDefault(ariaAbstractRoles_1);
  var _ariaLiteralRoles = _interopRequireDefault(ariaLiteralRoles_1);
  var _ariaDpubRoles = _interopRequireDefault(ariaDpubRoles_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _defineProperty(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it2) {
      if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it2)
          o = it2;
        var i = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n2() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it2 = it2.call(o);
    }, n: function n2() {
      var step = it2.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f() {
      try {
        if (!normalCompletion && it2.return != null)
          it2.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  var roles2 = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default);
  roles2.forEach(function(_ref) {
    var _ref2 = _slicedToArray(_ref, 2), roleDefinition = _ref2[1];
    var _iterator = _createForOfIteratorHelper(roleDefinition.superClass), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var superClassIter = _step.value;
        var _iterator2 = _createForOfIteratorHelper(superClassIter), _step2;
        try {
          var _loop = function _loop2() {
            var superClassName = _step2.value;
            var superClassRoleTuple = roles2.find(function(_ref3) {
              var _ref4 = _slicedToArray(_ref3, 1), name2 = _ref4[0];
              return name2 === superClassName;
            });
            if (superClassRoleTuple) {
              var superClassDefinition = superClassRoleTuple[1];
              for (var _i2 = 0, _Object$keys = Object.keys(superClassDefinition.props); _i2 < _Object$keys.length; _i2++) {
                var prop2 = _Object$keys[_i2];
                if (!Object.prototype.hasOwnProperty.call(roleDefinition.props, prop2)) {
                  Object.assign(roleDefinition.props, _defineProperty({}, prop2, superClassDefinition.props[prop2]));
                }
              }
            }
          };
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            _loop();
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  });
  var rolesMap = {
    entries: function entries() {
      return roles2;
    },
    get: function get(key) {
      var item = roles2.find(function(tuple) {
        return tuple[0] === key ? true : false;
      });
      return item && item[1];
    },
    has: function has2(key) {
      return !!this.get(key);
    },
    keys: function keys2() {
      return roles2.map(function(_ref5) {
        var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
        return key;
      });
    },
    values: function values2() {
      return roles2.map(function(_ref7) {
        var _ref8 = _slicedToArray(_ref7, 2), values3 = _ref8[1];
        return values3;
      });
    }
  };
  var _default2 = rolesMap;
  exports.default = _default2;
});
unwrapExports(rolesMap_1);
var elementRoleMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _rolesMap = _interopRequireDefault(rolesMap_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i2) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function _iterableToArrayLimit(arr, i2) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  var elementRoles = [];
  var keys2 = _rolesMap.default.keys();
  for (var i = 0; i < keys2.length; i++) {
    var _key = keys2[i];
    var role = _rolesMap.default.get(_key);
    if (role) {
      var concepts = [].concat(role.baseConcepts, role.relatedConcepts);
      for (var k = 0; k < concepts.length; k++) {
        var relation = concepts[k];
        if (relation.module === "HTML") {
          var concept = relation.concept;
          if (concept) {
            (function() {
              var conceptStr = JSON.stringify(concept);
              var elementRoleRelation = elementRoles.find(function(relation2) {
                return JSON.stringify(relation2[0]) === conceptStr;
              });
              var roles2 = void 0;
              if (elementRoleRelation) {
                roles2 = elementRoleRelation[1];
              } else {
                roles2 = [];
              }
              var isUnique = true;
              for (var _i = 0; _i < roles2.length; _i++) {
                if (roles2[_i] === _key) {
                  isUnique = false;
                  break;
                }
              }
              if (isUnique) {
                roles2.push(_key);
              }
              elementRoles.push([concept, roles2]);
            })();
          }
        }
      }
    }
  }
  var elementRoleMap = {
    entries: function entries() {
      return elementRoles;
    },
    get: function get(key) {
      var item = elementRoles.find(function(tuple) {
        return JSON.stringify(tuple[0]) === JSON.stringify(key) ? true : false;
      });
      return item && item[1];
    },
    has: function has2(key) {
      return !!this.get(key);
    },
    keys: function keys3() {
      return elementRoles.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
        return key;
      });
    },
    values: function values2() {
      return elementRoles.map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), values3 = _ref4[1];
        return values3;
      });
    }
  };
  var _default2 = elementRoleMap;
  exports.default = _default2;
});
unwrapExports(elementRoleMap_1);
var roleElementMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _rolesMap = _interopRequireDefault(rolesMap_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i2) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function _iterableToArrayLimit(arr, i2) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  var roleElement = [];
  var keys2 = _rolesMap.default.keys();
  var _loop = function _loop2(i2) {
    var key = keys2[i2];
    var role = _rolesMap.default.get(key);
    if (role) {
      var concepts = [].concat(role.baseConcepts, role.relatedConcepts);
      for (var k = 0; k < concepts.length; k++) {
        var relation = concepts[k];
        if (relation.module === "HTML") {
          var concept = relation.concept;
          if (concept) {
            var roleElementRelation = roleElement.find(function(item) {
              return item[0] === key;
            });
            var relationConcepts = void 0;
            if (roleElementRelation) {
              relationConcepts = roleElementRelation[1];
            } else {
              relationConcepts = [];
            }
            relationConcepts.push(concept);
            roleElement.push([key, relationConcepts]);
          }
        }
      }
    }
  };
  for (var i = 0; i < keys2.length; i++) {
    _loop(i);
  }
  var roleElementMap = {
    entries: function entries() {
      return roleElement;
    },
    get: function get(key) {
      var item = roleElement.find(function(tuple) {
        return tuple[0] === key ? true : false;
      });
      return item && item[1];
    },
    has: function has2(key) {
      return !!this.get(key);
    },
    keys: function keys3() {
      return roleElement.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
        return key;
      });
    },
    values: function values2() {
      return roleElement.map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), values3 = _ref4[1];
        return values3;
      });
    }
  };
  var _default2 = roleElementMap;
  exports.default = _default2;
});
unwrapExports(roleElementMap_1);
var lib = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.roleElements = exports.elementRoles = exports.roles = exports.dom = exports.aria = void 0;
  var _ariaPropsMap = _interopRequireDefault(ariaPropsMap_1);
  var _domMap = _interopRequireDefault(domMap_1);
  var _rolesMap = _interopRequireDefault(rolesMap_1);
  var _elementRoleMap = _interopRequireDefault(elementRoleMap_1);
  var _roleElementMap = _interopRequireDefault(roleElementMap_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var aria2 = _ariaPropsMap.default;
  exports.aria = aria2;
  var dom = _domMap.default;
  exports.dom = dom;
  var roles2 = _rolesMap.default;
  exports.roles = roles2;
  var elementRoles = _elementRoleMap.default;
  exports.elementRoles = elementRoles;
  var roleElements = _roleElementMap.default;
  exports.roleElements = roleElements;
});
unwrapExports(lib);
var lib_1 = lib.roleElements;
var lib_2 = lib.elementRoles;
var lib_3 = lib.roles;
var lib_4 = lib.dom;
var lib_5 = lib.aria;
var AbbrRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var AbbrRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "abbr"
      }
    }],
    type: "structure"
  };
  var _default2 = AbbrRole;
  exports.default = _default2;
});
unwrapExports(AbbrRole_1);
var AlertDialogRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var AlertDialogRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "alertdialog"
      }
    }],
    type: "window"
  };
  var _default2 = AlertDialogRole;
  exports.default = _default2;
});
unwrapExports(AlertDialogRole_1);
var AlertRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var AlertRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "alert"
      }
    }],
    type: "structure"
  };
  var _default2 = AlertRole;
  exports.default = _default2;
});
unwrapExports(AlertRole_1);
var AnnotationRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var AnnotationRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default2 = AnnotationRole;
  exports.default = _default2;
});
unwrapExports(AnnotationRole_1);
var ApplicationRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ApplicationRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "application"
      }
    }],
    type: "window"
  };
  var _default2 = ApplicationRole;
  exports.default = _default2;
});
unwrapExports(ApplicationRole_1);
var ArticleRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ArticleRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "article"
      }
    }, {
      module: "HTML",
      concept: {
        name: "article"
      }
    }],
    type: "structure"
  };
  var _default2 = ArticleRole;
  exports.default = _default2;
});
unwrapExports(ArticleRole_1);
var AudioRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var AudioRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "audio"
      }
    }],
    type: "widget"
  };
  var _default2 = AudioRole;
  exports.default = _default2;
});
unwrapExports(AudioRole_1);
var BannerRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var BannerRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "banner"
      }
    }],
    type: "structure"
  };
  var _default2 = BannerRole;
  exports.default = _default2;
});
unwrapExports(BannerRole_1);
var BlockquoteRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var BlockquoteRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "blockquote"
      }
    }],
    type: "structure"
  };
  var _default2 = BlockquoteRole;
  exports.default = _default2;
});
unwrapExports(BlockquoteRole_1);
var BusyIndicatorRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var BusyIndicatorRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        attributes: [{
          name: "aria-busy",
          value: "true"
        }]
      }
    }],
    type: "widget"
  };
  var _default2 = BusyIndicatorRole;
  exports.default = _default2;
});
unwrapExports(BusyIndicatorRole_1);
var ButtonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ButtonRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "button"
      }
    }, {
      module: "HTML",
      concept: {
        name: "button"
      }
    }],
    type: "widget"
  };
  var _default2 = ButtonRole;
  exports.default = _default2;
});
unwrapExports(ButtonRole_1);
var CanvasRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var CanvasRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "canvas"
      }
    }],
    type: "widget"
  };
  var _default2 = CanvasRole;
  exports.default = _default2;
});
unwrapExports(CanvasRole_1);
var CaptionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var CaptionRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "caption"
      }
    }],
    type: "structure"
  };
  var _default2 = CaptionRole;
  exports.default = _default2;
});
unwrapExports(CaptionRole_1);
var CellRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var CellRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "cell"
      }
    }, {
      module: "ARIA",
      concept: {
        name: "gridcell"
      }
    }, {
      module: "HTML",
      concept: {
        name: "td"
      }
    }],
    type: "widget"
  };
  var _default2 = CellRole;
  exports.default = _default2;
});
unwrapExports(CellRole_1);
var CheckBoxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var CheckBoxRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "checkbox"
      }
    }, {
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "checkbox"
        }]
      }
    }],
    type: "widget"
  };
  var _default2 = CheckBoxRole;
  exports.default = _default2;
});
unwrapExports(CheckBoxRole_1);
var ColorWellRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ColorWellRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "color"
        }]
      }
    }],
    type: "widget"
  };
  var _default2 = ColorWellRole;
  exports.default = _default2;
});
unwrapExports(ColorWellRole_1);
var ColumnHeaderRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ColumnHeaderRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "columnheader"
      }
    }, {
      module: "HTML",
      concept: {
        name: "th"
      }
    }],
    type: "widget"
  };
  var _default2 = ColumnHeaderRole;
  exports.default = _default2;
});
unwrapExports(ColumnHeaderRole_1);
var ColumnRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ColumnRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default2 = ColumnRole;
  exports.default = _default2;
});
unwrapExports(ColumnRole_1);
var ComboBoxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ComboBoxRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "combobox"
      }
    }, {
      module: "HTML",
      concept: {
        name: "select"
      }
    }],
    type: "widget"
  };
  var _default2 = ComboBoxRole;
  exports.default = _default2;
});
unwrapExports(ComboBoxRole_1);
var ComplementaryRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ComplementaryRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "complementary"
      }
    }],
    type: "structure"
  };
  var _default2 = ComplementaryRole;
  exports.default = _default2;
});
unwrapExports(ComplementaryRole_1);
var ContentInfoRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ContentInfoRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "structureinfo"
      }
    }],
    type: "structure"
  };
  var _default2 = ContentInfoRole;
  exports.default = _default2;
});
unwrapExports(ContentInfoRole_1);
var DateRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DateRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "date"
        }]
      }
    }],
    type: "widget"
  };
  var _default2 = DateRole;
  exports.default = _default2;
});
unwrapExports(DateRole_1);
var DateTimeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DateTimeRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "datetime"
        }]
      }
    }],
    type: "widget"
  };
  var _default2 = DateTimeRole;
  exports.default = _default2;
});
unwrapExports(DateTimeRole_1);
var DefinitionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DefinitionRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "dfn"
      }
    }],
    type: "structure"
  };
  var _default2 = DefinitionRole;
  exports.default = _default2;
});
unwrapExports(DefinitionRole_1);
var DescriptionListDetailRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DescriptionListDetailRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "dd"
      }
    }],
    type: "structure"
  };
  var _default2 = DescriptionListDetailRole;
  exports.default = _default2;
});
unwrapExports(DescriptionListDetailRole_1);
var DescriptionListRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DescriptionListRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "dl"
      }
    }],
    type: "structure"
  };
  var _default2 = DescriptionListRole;
  exports.default = _default2;
});
unwrapExports(DescriptionListRole_1);
var DescriptionListTermRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DescriptionListTermRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "dt"
      }
    }],
    type: "structure"
  };
  var _default2 = DescriptionListTermRole;
  exports.default = _default2;
});
unwrapExports(DescriptionListTermRole_1);
var DetailsRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DetailsRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "details"
      }
    }],
    type: "structure"
  };
  var _default2 = DetailsRole;
  exports.default = _default2;
});
unwrapExports(DetailsRole_1);
var DialogRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DialogRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "dialog"
      }
    }, {
      module: "HTML",
      concept: {
        name: "dialog"
      }
    }],
    type: "window"
  };
  var _default2 = DialogRole;
  exports.default = _default2;
});
unwrapExports(DialogRole_1);
var DirectoryRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DirectoryRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "directory"
      }
    }, {
      module: "HTML",
      concept: {
        name: "dir"
      }
    }],
    type: "structure"
  };
  var _default2 = DirectoryRole;
  exports.default = _default2;
});
unwrapExports(DirectoryRole_1);
var DisclosureTriangleRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DisclosureTriangleRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "summary"
      }
    }],
    type: "widget"
  };
  var _default2 = DisclosureTriangleRole;
  exports.default = _default2;
});
unwrapExports(DisclosureTriangleRole_1);
var DivRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DivRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "div"
      }
    }],
    type: "generic"
  };
  var _default2 = DivRole;
  exports.default = _default2;
});
unwrapExports(DivRole_1);
var DocumentRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var DocumentRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "document"
      }
    }],
    type: "structure"
  };
  var _default2 = DocumentRole;
  exports.default = _default2;
});
unwrapExports(DocumentRole_1);
var EmbeddedObjectRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var EmbeddedObjectRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "embed"
      }
    }],
    type: "widget"
  };
  var _default2 = EmbeddedObjectRole;
  exports.default = _default2;
});
unwrapExports(EmbeddedObjectRole_1);
var FeedRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var FeedRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "feed"
      }
    }],
    type: "structure"
  };
  var _default2 = FeedRole;
  exports.default = _default2;
});
unwrapExports(FeedRole_1);
var FigcaptionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var FigcaptionRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "figcaption"
      }
    }],
    type: "structure"
  };
  var _default2 = FigcaptionRole;
  exports.default = _default2;
});
unwrapExports(FigcaptionRole_1);
var FigureRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var FigureRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "figure"
      }
    }, {
      module: "HTML",
      concept: {
        name: "figure"
      }
    }],
    type: "structure"
  };
  var _default2 = FigureRole;
  exports.default = _default2;
});
unwrapExports(FigureRole_1);
var FooterRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var FooterRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "footer"
      }
    }],
    type: "structure"
  };
  var _default2 = FooterRole;
  exports.default = _default2;
});
unwrapExports(FooterRole_1);
var FormRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var FormRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "form"
      }
    }, {
      module: "HTML",
      concept: {
        name: "form"
      }
    }],
    type: "structure"
  };
  var _default2 = FormRole;
  exports.default = _default2;
});
unwrapExports(FormRole_1);
var GridRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var GridRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "grid"
      }
    }],
    type: "widget"
  };
  var _default2 = GridRole;
  exports.default = _default2;
});
unwrapExports(GridRole_1);
var GroupRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var GroupRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "group"
      }
    }],
    type: "structure"
  };
  var _default2 = GroupRole;
  exports.default = _default2;
});
unwrapExports(GroupRole_1);
var HeadingRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var HeadingRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "heading"
      }
    }, {
      module: "HTML",
      concept: {
        name: "h1"
      }
    }, {
      module: "HTML",
      concept: {
        name: "h2"
      }
    }, {
      module: "HTML",
      concept: {
        name: "h3"
      }
    }, {
      module: "HTML",
      concept: {
        name: "h4"
      }
    }, {
      module: "HTML",
      concept: {
        name: "h5"
      }
    }, {
      module: "HTML",
      concept: {
        name: "h6"
      }
    }],
    type: "structure"
  };
  var _default2 = HeadingRole;
  exports.default = _default2;
});
unwrapExports(HeadingRole_1);
var IframePresentationalRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var IframePresentationalRole = {
    relatedConcepts: [],
    type: "window"
  };
  var _default2 = IframePresentationalRole;
  exports.default = _default2;
});
unwrapExports(IframePresentationalRole_1);
var IframeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var IframeRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "iframe"
      }
    }],
    type: "window"
  };
  var _default2 = IframeRole;
  exports.default = _default2;
});
unwrapExports(IframeRole_1);
var IgnoredRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var IgnoredRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default2 = IgnoredRole;
  exports.default = _default2;
});
unwrapExports(IgnoredRole_1);
var ImageMapLinkRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ImageMapLinkRole = {
    relatedConcepts: [],
    type: "widget"
  };
  var _default2 = ImageMapLinkRole;
  exports.default = _default2;
});
unwrapExports(ImageMapLinkRole_1);
var ImageMapRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ImageMapRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "img",
        attributes: [{
          name: "usemap"
        }]
      }
    }],
    type: "structure"
  };
  var _default2 = ImageMapRole;
  exports.default = _default2;
});
unwrapExports(ImageMapRole_1);
var ImageRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ImageRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "img"
      }
    }, {
      module: "HTML",
      concept: {
        name: "img"
      }
    }],
    type: "structure"
  };
  var _default2 = ImageRole;
  exports.default = _default2;
});
unwrapExports(ImageRole_1);
var InlineTextBoxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var InlineTextBoxRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "input"
      }
    }],
    type: "widget"
  };
  var _default2 = InlineTextBoxRole;
  exports.default = _default2;
});
unwrapExports(InlineTextBoxRole_1);
var InputTimeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var InputTimeRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "time"
        }]
      }
    }],
    type: "widget"
  };
  var _default2 = InputTimeRole;
  exports.default = _default2;
});
unwrapExports(InputTimeRole_1);
var LabelRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var LabelRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "label"
      }
    }],
    type: "structure"
  };
  var _default2 = LabelRole;
  exports.default = _default2;
});
unwrapExports(LabelRole_1);
var LegendRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var LegendRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "legend"
      }
    }],
    type: "structure"
  };
  var _default2 = LegendRole;
  exports.default = _default2;
});
unwrapExports(LegendRole_1);
var LineBreakRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var LineBreakRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "br"
      }
    }],
    type: "structure"
  };
  var _default2 = LineBreakRole;
  exports.default = _default2;
});
unwrapExports(LineBreakRole_1);
var LinkRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var LinkRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "link"
      }
    }, {
      module: "HTML",
      concept: {
        name: "a",
        attributes: [{
          name: "href"
        }]
      }
    }],
    type: "widget"
  };
  var _default2 = LinkRole;
  exports.default = _default2;
});
unwrapExports(LinkRole_1);
var ListBoxOptionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ListBoxOptionRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "option"
      }
    }, {
      module: "HTML",
      concept: {
        name: "option"
      }
    }],
    type: "widget"
  };
  var _default2 = ListBoxOptionRole;
  exports.default = _default2;
});
unwrapExports(ListBoxOptionRole_1);
var ListBoxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ListBoxRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "listbox"
      }
    }, {
      module: "HTML",
      concept: {
        name: "datalist"
      }
    }, {
      module: "HTML",
      concept: {
        name: "select"
      }
    }],
    type: "widget"
  };
  var _default2 = ListBoxRole;
  exports.default = _default2;
});
unwrapExports(ListBoxRole_1);
var ListItemRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ListItemRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "listitem"
      }
    }, {
      module: "HTML",
      concept: {
        name: "li"
      }
    }],
    type: "structure"
  };
  var _default2 = ListItemRole;
  exports.default = _default2;
});
unwrapExports(ListItemRole_1);
var ListMarkerRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ListMarkerRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default2 = ListMarkerRole;
  exports.default = _default2;
});
unwrapExports(ListMarkerRole_1);
var ListRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ListRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "list"
      }
    }, {
      module: "HTML",
      concept: {
        name: "ul"
      }
    }, {
      module: "HTML",
      concept: {
        name: "ol"
      }
    }],
    type: "structure"
  };
  var _default2 = ListRole;
  exports.default = _default2;
});
unwrapExports(ListRole_1);
var LogRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var LogRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "log"
      }
    }],
    type: "structure"
  };
  var _default2 = LogRole;
  exports.default = _default2;
});
unwrapExports(LogRole_1);
var MainRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MainRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "main"
      }
    }, {
      module: "HTML",
      concept: {
        name: "main"
      }
    }],
    type: "structure"
  };
  var _default2 = MainRole;
  exports.default = _default2;
});
unwrapExports(MainRole_1);
var MarkRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MarkRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "mark"
      }
    }],
    type: "structure"
  };
  var _default2 = MarkRole;
  exports.default = _default2;
});
unwrapExports(MarkRole_1);
var MarqueeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MarqueeRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "marquee"
      }
    }, {
      module: "HTML",
      concept: {
        name: "marquee"
      }
    }],
    type: "structure"
  };
  var _default2 = MarqueeRole;
  exports.default = _default2;
});
unwrapExports(MarqueeRole_1);
var MathRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MathRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "math"
      }
    }],
    type: "structure"
  };
  var _default2 = MathRole;
  exports.default = _default2;
});
unwrapExports(MathRole_1);
var MenuBarRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MenuBarRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "menubar"
      }
    }],
    type: "structure"
  };
  var _default2 = MenuBarRole;
  exports.default = _default2;
});
unwrapExports(MenuBarRole_1);
var MenuButtonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MenuButtonRole = {
    relatedConcepts: [],
    type: "widget"
  };
  var _default2 = MenuButtonRole;
  exports.default = _default2;
});
unwrapExports(MenuButtonRole_1);
var MenuItemRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MenuItemRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "menuitem"
      }
    }, {
      module: "HTML",
      concept: {
        name: "menuitem"
      }
    }],
    type: "widget"
  };
  var _default2 = MenuItemRole;
  exports.default = _default2;
});
unwrapExports(MenuItemRole_1);
var MenuItemCheckBoxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MenuItemCheckBoxRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "menuitemcheckbox"
      }
    }],
    type: "widget"
  };
  var _default2 = MenuItemCheckBoxRole;
  exports.default = _default2;
});
unwrapExports(MenuItemCheckBoxRole_1);
var MenuItemRadioRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MenuItemRadioRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "menuitemradio"
      }
    }],
    type: "widget"
  };
  var _default2 = MenuItemRadioRole;
  exports.default = _default2;
});
unwrapExports(MenuItemRadioRole_1);
var MenuListOptionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MenuListOptionRole = {
    relatedConcepts: [],
    type: "widget"
  };
  var _default2 = MenuListOptionRole;
  exports.default = _default2;
});
unwrapExports(MenuListOptionRole_1);
var MenuListPopupRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MenuListPopupRole = {
    relatedConcepts: [],
    type: "widget"
  };
  var _default2 = MenuListPopupRole;
  exports.default = _default2;
});
unwrapExports(MenuListPopupRole_1);
var MenuRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MenuRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "menu"
      }
    }, {
      module: "HTML",
      concept: {
        name: "menu"
      }
    }],
    type: "structure"
  };
  var _default2 = MenuRole;
  exports.default = _default2;
});
unwrapExports(MenuRole_1);
var MeterRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var MeterRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "meter"
      }
    }],
    type: "structure"
  };
  var _default2 = MeterRole;
  exports.default = _default2;
});
unwrapExports(MeterRole_1);
var NavigationRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var NavigationRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "navigation"
      }
    }, {
      module: "HTML",
      concept: {
        name: "nav"
      }
    }],
    type: "structure"
  };
  var _default2 = NavigationRole;
  exports.default = _default2;
});
unwrapExports(NavigationRole_1);
var NoneRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var NoneRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "none"
      }
    }],
    type: "structure"
  };
  var _default2 = NoneRole;
  exports.default = _default2;
});
unwrapExports(NoneRole_1);
var NoteRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var NoteRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "note"
      }
    }],
    type: "structure"
  };
  var _default2 = NoteRole;
  exports.default = _default2;
});
unwrapExports(NoteRole_1);
var OutlineRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var OutlineRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default2 = OutlineRole;
  exports.default = _default2;
});
unwrapExports(OutlineRole_1);
var ParagraphRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ParagraphRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "p"
      }
    }],
    type: "structure"
  };
  var _default2 = ParagraphRole;
  exports.default = _default2;
});
unwrapExports(ParagraphRole_1);
var PopUpButtonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var PopUpButtonRole = {
    relatedConcepts: [],
    type: "widget"
  };
  var _default2 = PopUpButtonRole;
  exports.default = _default2;
});
unwrapExports(PopUpButtonRole_1);
var PreRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var PreRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "pre"
      }
    }],
    type: "structure"
  };
  var _default2 = PreRole;
  exports.default = _default2;
});
unwrapExports(PreRole_1);
var PresentationalRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var PresentationalRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "presentation"
      }
    }],
    type: "structure"
  };
  var _default2 = PresentationalRole;
  exports.default = _default2;
});
unwrapExports(PresentationalRole_1);
var ProgressIndicatorRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ProgressIndicatorRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "progressbar"
      }
    }, {
      module: "HTML",
      concept: {
        name: "progress"
      }
    }],
    type: "structure"
  };
  var _default2 = ProgressIndicatorRole;
  exports.default = _default2;
});
unwrapExports(ProgressIndicatorRole_1);
var RadioButtonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var RadioButtonRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "radio"
      }
    }, {
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "radio"
        }]
      }
    }],
    type: "widget"
  };
  var _default2 = RadioButtonRole;
  exports.default = _default2;
});
unwrapExports(RadioButtonRole_1);
var RadioGroupRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var RadioGroupRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "radiogroup"
      }
    }],
    type: "structure"
  };
  var _default2 = RadioGroupRole;
  exports.default = _default2;
});
unwrapExports(RadioGroupRole_1);
var RegionRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var RegionRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "region"
      }
    }],
    type: "structure"
  };
  var _default2 = RegionRole;
  exports.default = _default2;
});
unwrapExports(RegionRole_1);
var RootWebAreaRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var RootWebAreaRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default2 = RootWebAreaRole;
  exports.default = _default2;
});
unwrapExports(RootWebAreaRole_1);
var RowHeaderRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var RowHeaderRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "rowheader"
      }
    }, {
      module: "HTML",
      concept: {
        name: "th",
        attributes: [{
          name: "scope",
          value: "row"
        }]
      }
    }],
    type: "widget"
  };
  var _default2 = RowHeaderRole;
  exports.default = _default2;
});
unwrapExports(RowHeaderRole_1);
var RowRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var RowRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "row"
      }
    }, {
      module: "HTML",
      concept: {
        name: "tr"
      }
    }],
    type: "structure"
  };
  var _default2 = RowRole;
  exports.default = _default2;
});
unwrapExports(RowRole_1);
var RubyRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var RubyRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "ruby"
      }
    }],
    type: "structure"
  };
  var _default2 = RubyRole;
  exports.default = _default2;
});
unwrapExports(RubyRole_1);
var RulerRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var RulerRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default2 = RulerRole;
  exports.default = _default2;
});
unwrapExports(RulerRole_1);
var ScrollAreaRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ScrollAreaRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default2 = ScrollAreaRole;
  exports.default = _default2;
});
unwrapExports(ScrollAreaRole_1);
var ScrollBarRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ScrollBarRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "scrollbar"
      }
    }],
    type: "widget"
  };
  var _default2 = ScrollBarRole;
  exports.default = _default2;
});
unwrapExports(ScrollBarRole_1);
var SeamlessWebAreaRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SeamlessWebAreaRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default2 = SeamlessWebAreaRole;
  exports.default = _default2;
});
unwrapExports(SeamlessWebAreaRole_1);
var SearchRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SearchRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "search"
      }
    }],
    type: "structure"
  };
  var _default2 = SearchRole;
  exports.default = _default2;
});
unwrapExports(SearchRole_1);
var SearchBoxRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SearchBoxRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "searchbox"
      }
    }, {
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "search"
        }]
      }
    }],
    type: "widget"
  };
  var _default2 = SearchBoxRole;
  exports.default = _default2;
});
unwrapExports(SearchBoxRole_1);
var SliderRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SliderRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "slider"
      }
    }, {
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "range"
        }]
      }
    }],
    type: "widget"
  };
  var _default2 = SliderRole;
  exports.default = _default2;
});
unwrapExports(SliderRole_1);
var SliderThumbRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SliderThumbRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default2 = SliderThumbRole;
  exports.default = _default2;
});
unwrapExports(SliderThumbRole_1);
var SpinButtonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SpinButtonRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "spinbutton"
      }
    }, {
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "number"
        }]
      }
    }],
    type: "widget"
  };
  var _default2 = SpinButtonRole;
  exports.default = _default2;
});
unwrapExports(SpinButtonRole_1);
var SpinButtonPartRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SpinButtonPartRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default2 = SpinButtonPartRole;
  exports.default = _default2;
});
unwrapExports(SpinButtonPartRole_1);
var SplitterRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SplitterRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "separator"
      }
    }],
    type: "widget"
  };
  var _default2 = SplitterRole;
  exports.default = _default2;
});
unwrapExports(SplitterRole_1);
var StaticTextRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var StaticTextRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default2 = StaticTextRole;
  exports.default = _default2;
});
unwrapExports(StaticTextRole_1);
var StatusRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var StatusRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "status"
      }
    }],
    type: "structure"
  };
  var _default2 = StatusRole;
  exports.default = _default2;
});
unwrapExports(StatusRole_1);
var SVGRootRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SVGRootRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default2 = SVGRootRole;
  exports.default = _default2;
});
unwrapExports(SVGRootRole_1);
var SwitchRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var SwitchRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "switch"
      }
    }, {
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "checkbox"
        }]
      }
    }],
    type: "widget"
  };
  var _default2 = SwitchRole;
  exports.default = _default2;
});
unwrapExports(SwitchRole_1);
var TabGroupRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TabGroupRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "tablist"
      }
    }],
    type: "structure"
  };
  var _default2 = TabGroupRole;
  exports.default = _default2;
});
unwrapExports(TabGroupRole_1);
var TabRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TabRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "tab"
      }
    }],
    type: "widget"
  };
  var _default2 = TabRole;
  exports.default = _default2;
});
unwrapExports(TabRole_1);
var TableHeaderContainerRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TableHeaderContainerRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default2 = TableHeaderContainerRole;
  exports.default = _default2;
});
unwrapExports(TableHeaderContainerRole_1);
var TableRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TableRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "table"
      }
    }, {
      module: "HTML",
      concept: {
        name: "table"
      }
    }],
    type: "structure"
  };
  var _default2 = TableRole;
  exports.default = _default2;
});
unwrapExports(TableRole_1);
var TabListRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TabListRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "tablist"
      }
    }],
    type: "structure"
  };
  var _default2 = TabListRole;
  exports.default = _default2;
});
unwrapExports(TabListRole_1);
var TabPanelRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TabPanelRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "tabpanel"
      }
    }],
    type: "structure"
  };
  var _default2 = TabPanelRole;
  exports.default = _default2;
});
unwrapExports(TabPanelRole_1);
var TermRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TermRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "term"
      }
    }],
    type: "structure"
  };
  var _default2 = TermRole;
  exports.default = _default2;
});
unwrapExports(TermRole_1);
var TextFieldRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TextFieldRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "textbox"
      }
    }, {
      module: "HTML",
      concept: {
        name: "input"
      }
    }, {
      module: "HTML",
      concept: {
        name: "input",
        attributes: [{
          name: "type",
          value: "text"
        }]
      }
    }],
    type: "widget"
  };
  var _default2 = TextFieldRole;
  exports.default = _default2;
});
unwrapExports(TextFieldRole_1);
var TimeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TimeRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "time"
      }
    }],
    type: "structure"
  };
  var _default2 = TimeRole;
  exports.default = _default2;
});
unwrapExports(TimeRole_1);
var TimerRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TimerRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "timer"
      }
    }],
    type: "structure"
  };
  var _default2 = TimerRole;
  exports.default = _default2;
});
unwrapExports(TimerRole_1);
var ToggleButtonRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ToggleButtonRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        attributes: [{
          name: "aria-pressed"
        }]
      }
    }],
    type: "widget"
  };
  var _default2 = ToggleButtonRole;
  exports.default = _default2;
});
unwrapExports(ToggleButtonRole_1);
var ToolbarRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var ToolbarRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "toolbar"
      }
    }],
    type: "structure"
  };
  var _default2 = ToolbarRole;
  exports.default = _default2;
});
unwrapExports(ToolbarRole_1);
var TreeRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TreeRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "tree"
      }
    }],
    type: "widget"
  };
  var _default2 = TreeRole;
  exports.default = _default2;
});
unwrapExports(TreeRole_1);
var TreeGridRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TreeGridRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "treegrid"
      }
    }],
    type: "widget"
  };
  var _default2 = TreeGridRole;
  exports.default = _default2;
});
unwrapExports(TreeGridRole_1);
var TreeItemRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var TreeItemRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "treeitem"
      }
    }],
    type: "widget"
  };
  var _default2 = TreeItemRole;
  exports.default = _default2;
});
unwrapExports(TreeItemRole_1);
var UserInterfaceTooltipRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var UserInterfaceTooltipRole = {
    relatedConcepts: [{
      module: "ARIA",
      concept: {
        name: "tooltip"
      }
    }],
    type: "structure"
  };
  var _default2 = UserInterfaceTooltipRole;
  exports.default = _default2;
});
unwrapExports(UserInterfaceTooltipRole_1);
var VideoRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var VideoRole = {
    relatedConcepts: [{
      module: "HTML",
      concept: {
        name: "video"
      }
    }],
    type: "widget"
  };
  var _default2 = VideoRole;
  exports.default = _default2;
});
unwrapExports(VideoRole_1);
var WebAreaRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var WebAreaRole = {
    relatedConcepts: [],
    type: "structure"
  };
  var _default2 = WebAreaRole;
  exports.default = _default2;
});
unwrapExports(WebAreaRole_1);
var WindowRole_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var WindowRole = {
    relatedConcepts: [],
    type: "window"
  };
  var _default2 = WindowRole;
  exports.default = _default2;
});
unwrapExports(WindowRole_1);
var AXObjectsMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AbbrRole = _interopRequireDefault(AbbrRole_1);
  var _AlertDialogRole = _interopRequireDefault(AlertDialogRole_1);
  var _AlertRole = _interopRequireDefault(AlertRole_1);
  var _AnnotationRole = _interopRequireDefault(AnnotationRole_1);
  var _ApplicationRole = _interopRequireDefault(ApplicationRole_1);
  var _ArticleRole = _interopRequireDefault(ArticleRole_1);
  var _AudioRole = _interopRequireDefault(AudioRole_1);
  var _BannerRole = _interopRequireDefault(BannerRole_1);
  var _BlockquoteRole = _interopRequireDefault(BlockquoteRole_1);
  var _BusyIndicatorRole = _interopRequireDefault(BusyIndicatorRole_1);
  var _ButtonRole = _interopRequireDefault(ButtonRole_1);
  var _CanvasRole = _interopRequireDefault(CanvasRole_1);
  var _CaptionRole = _interopRequireDefault(CaptionRole_1);
  var _CellRole = _interopRequireDefault(CellRole_1);
  var _CheckBoxRole = _interopRequireDefault(CheckBoxRole_1);
  var _ColorWellRole = _interopRequireDefault(ColorWellRole_1);
  var _ColumnHeaderRole = _interopRequireDefault(ColumnHeaderRole_1);
  var _ColumnRole = _interopRequireDefault(ColumnRole_1);
  var _ComboBoxRole = _interopRequireDefault(ComboBoxRole_1);
  var _ComplementaryRole = _interopRequireDefault(ComplementaryRole_1);
  var _ContentInfoRole = _interopRequireDefault(ContentInfoRole_1);
  var _DateRole = _interopRequireDefault(DateRole_1);
  var _DateTimeRole = _interopRequireDefault(DateTimeRole_1);
  var _DefinitionRole = _interopRequireDefault(DefinitionRole_1);
  var _DescriptionListDetailRole = _interopRequireDefault(DescriptionListDetailRole_1);
  var _DescriptionListRole = _interopRequireDefault(DescriptionListRole_1);
  var _DescriptionListTermRole = _interopRequireDefault(DescriptionListTermRole_1);
  var _DetailsRole = _interopRequireDefault(DetailsRole_1);
  var _DialogRole = _interopRequireDefault(DialogRole_1);
  var _DirectoryRole = _interopRequireDefault(DirectoryRole_1);
  var _DisclosureTriangleRole = _interopRequireDefault(DisclosureTriangleRole_1);
  var _DivRole = _interopRequireDefault(DivRole_1);
  var _DocumentRole = _interopRequireDefault(DocumentRole_1);
  var _EmbeddedObjectRole = _interopRequireDefault(EmbeddedObjectRole_1);
  var _FeedRole = _interopRequireDefault(FeedRole_1);
  var _FigcaptionRole = _interopRequireDefault(FigcaptionRole_1);
  var _FigureRole = _interopRequireDefault(FigureRole_1);
  var _FooterRole = _interopRequireDefault(FooterRole_1);
  var _FormRole = _interopRequireDefault(FormRole_1);
  var _GridRole = _interopRequireDefault(GridRole_1);
  var _GroupRole = _interopRequireDefault(GroupRole_1);
  var _HeadingRole = _interopRequireDefault(HeadingRole_1);
  var _IframePresentationalRole = _interopRequireDefault(IframePresentationalRole_1);
  var _IframeRole = _interopRequireDefault(IframeRole_1);
  var _IgnoredRole = _interopRequireDefault(IgnoredRole_1);
  var _ImageMapLinkRole = _interopRequireDefault(ImageMapLinkRole_1);
  var _ImageMapRole = _interopRequireDefault(ImageMapRole_1);
  var _ImageRole = _interopRequireDefault(ImageRole_1);
  var _InlineTextBoxRole = _interopRequireDefault(InlineTextBoxRole_1);
  var _InputTimeRole = _interopRequireDefault(InputTimeRole_1);
  var _LabelRole = _interopRequireDefault(LabelRole_1);
  var _LegendRole = _interopRequireDefault(LegendRole_1);
  var _LineBreakRole = _interopRequireDefault(LineBreakRole_1);
  var _LinkRole = _interopRequireDefault(LinkRole_1);
  var _ListBoxOptionRole = _interopRequireDefault(ListBoxOptionRole_1);
  var _ListBoxRole = _interopRequireDefault(ListBoxRole_1);
  var _ListItemRole = _interopRequireDefault(ListItemRole_1);
  var _ListMarkerRole = _interopRequireDefault(ListMarkerRole_1);
  var _ListRole = _interopRequireDefault(ListRole_1);
  var _LogRole = _interopRequireDefault(LogRole_1);
  var _MainRole = _interopRequireDefault(MainRole_1);
  var _MarkRole = _interopRequireDefault(MarkRole_1);
  var _MarqueeRole = _interopRequireDefault(MarqueeRole_1);
  var _MathRole = _interopRequireDefault(MathRole_1);
  var _MenuBarRole = _interopRequireDefault(MenuBarRole_1);
  var _MenuButtonRole = _interopRequireDefault(MenuButtonRole_1);
  var _MenuItemRole = _interopRequireDefault(MenuItemRole_1);
  var _MenuItemCheckBoxRole = _interopRequireDefault(MenuItemCheckBoxRole_1);
  var _MenuItemRadioRole = _interopRequireDefault(MenuItemRadioRole_1);
  var _MenuListOptionRole = _interopRequireDefault(MenuListOptionRole_1);
  var _MenuListPopupRole = _interopRequireDefault(MenuListPopupRole_1);
  var _MenuRole = _interopRequireDefault(MenuRole_1);
  var _MeterRole = _interopRequireDefault(MeterRole_1);
  var _NavigationRole = _interopRequireDefault(NavigationRole_1);
  var _NoneRole = _interopRequireDefault(NoneRole_1);
  var _NoteRole = _interopRequireDefault(NoteRole_1);
  var _OutlineRole = _interopRequireDefault(OutlineRole_1);
  var _ParagraphRole = _interopRequireDefault(ParagraphRole_1);
  var _PopUpButtonRole = _interopRequireDefault(PopUpButtonRole_1);
  var _PreRole = _interopRequireDefault(PreRole_1);
  var _PresentationalRole = _interopRequireDefault(PresentationalRole_1);
  var _ProgressIndicatorRole = _interopRequireDefault(ProgressIndicatorRole_1);
  var _RadioButtonRole = _interopRequireDefault(RadioButtonRole_1);
  var _RadioGroupRole = _interopRequireDefault(RadioGroupRole_1);
  var _RegionRole = _interopRequireDefault(RegionRole_1);
  var _RootWebAreaRole = _interopRequireDefault(RootWebAreaRole_1);
  var _RowHeaderRole = _interopRequireDefault(RowHeaderRole_1);
  var _RowRole = _interopRequireDefault(RowRole_1);
  var _RubyRole = _interopRequireDefault(RubyRole_1);
  var _RulerRole = _interopRequireDefault(RulerRole_1);
  var _ScrollAreaRole = _interopRequireDefault(ScrollAreaRole_1);
  var _ScrollBarRole = _interopRequireDefault(ScrollBarRole_1);
  var _SeamlessWebAreaRole = _interopRequireDefault(SeamlessWebAreaRole_1);
  var _SearchRole = _interopRequireDefault(SearchRole_1);
  var _SearchBoxRole = _interopRequireDefault(SearchBoxRole_1);
  var _SliderRole = _interopRequireDefault(SliderRole_1);
  var _SliderThumbRole = _interopRequireDefault(SliderThumbRole_1);
  var _SpinButtonRole = _interopRequireDefault(SpinButtonRole_1);
  var _SpinButtonPartRole = _interopRequireDefault(SpinButtonPartRole_1);
  var _SplitterRole = _interopRequireDefault(SplitterRole_1);
  var _StaticTextRole = _interopRequireDefault(StaticTextRole_1);
  var _StatusRole = _interopRequireDefault(StatusRole_1);
  var _SVGRootRole = _interopRequireDefault(SVGRootRole_1);
  var _SwitchRole = _interopRequireDefault(SwitchRole_1);
  var _TabGroupRole = _interopRequireDefault(TabGroupRole_1);
  var _TabRole = _interopRequireDefault(TabRole_1);
  var _TableHeaderContainerRole = _interopRequireDefault(TableHeaderContainerRole_1);
  var _TableRole = _interopRequireDefault(TableRole_1);
  var _TabListRole = _interopRequireDefault(TabListRole_1);
  var _TabPanelRole = _interopRequireDefault(TabPanelRole_1);
  var _TermRole = _interopRequireDefault(TermRole_1);
  var _TextFieldRole = _interopRequireDefault(TextFieldRole_1);
  var _TimeRole = _interopRequireDefault(TimeRole_1);
  var _TimerRole = _interopRequireDefault(TimerRole_1);
  var _ToggleButtonRole = _interopRequireDefault(ToggleButtonRole_1);
  var _ToolbarRole = _interopRequireDefault(ToolbarRole_1);
  var _TreeRole = _interopRequireDefault(TreeRole_1);
  var _TreeGridRole = _interopRequireDefault(TreeGridRole_1);
  var _TreeItemRole = _interopRequireDefault(TreeItemRole_1);
  var _UserInterfaceTooltipRole = _interopRequireDefault(UserInterfaceTooltipRole_1);
  var _VideoRole = _interopRequireDefault(VideoRole_1);
  var _WebAreaRole = _interopRequireDefault(WebAreaRole_1);
  var _WindowRole = _interopRequireDefault(WindowRole_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  var AXObjects = [["AbbrRole", _AbbrRole.default], ["AlertDialogRole", _AlertDialogRole.default], ["AlertRole", _AlertRole.default], ["AnnotationRole", _AnnotationRole.default], ["ApplicationRole", _ApplicationRole.default], ["ArticleRole", _ArticleRole.default], ["AudioRole", _AudioRole.default], ["BannerRole", _BannerRole.default], ["BlockquoteRole", _BlockquoteRole.default], ["BusyIndicatorRole", _BusyIndicatorRole.default], ["ButtonRole", _ButtonRole.default], ["CanvasRole", _CanvasRole.default], ["CaptionRole", _CaptionRole.default], ["CellRole", _CellRole.default], ["CheckBoxRole", _CheckBoxRole.default], ["ColorWellRole", _ColorWellRole.default], ["ColumnHeaderRole", _ColumnHeaderRole.default], ["ColumnRole", _ColumnRole.default], ["ComboBoxRole", _ComboBoxRole.default], ["ComplementaryRole", _ComplementaryRole.default], ["ContentInfoRole", _ContentInfoRole.default], ["DateRole", _DateRole.default], ["DateTimeRole", _DateTimeRole.default], ["DefinitionRole", _DefinitionRole.default], ["DescriptionListDetailRole", _DescriptionListDetailRole.default], ["DescriptionListRole", _DescriptionListRole.default], ["DescriptionListTermRole", _DescriptionListTermRole.default], ["DetailsRole", _DetailsRole.default], ["DialogRole", _DialogRole.default], ["DirectoryRole", _DirectoryRole.default], ["DisclosureTriangleRole", _DisclosureTriangleRole.default], ["DivRole", _DivRole.default], ["DocumentRole", _DocumentRole.default], ["EmbeddedObjectRole", _EmbeddedObjectRole.default], ["FeedRole", _FeedRole.default], ["FigcaptionRole", _FigcaptionRole.default], ["FigureRole", _FigureRole.default], ["FooterRole", _FooterRole.default], ["FormRole", _FormRole.default], ["GridRole", _GridRole.default], ["GroupRole", _GroupRole.default], ["HeadingRole", _HeadingRole.default], ["IframePresentationalRole", _IframePresentationalRole.default], ["IframeRole", _IframeRole.default], ["IgnoredRole", _IgnoredRole.default], ["ImageMapLinkRole", _ImageMapLinkRole.default], ["ImageMapRole", _ImageMapRole.default], ["ImageRole", _ImageRole.default], ["InlineTextBoxRole", _InlineTextBoxRole.default], ["InputTimeRole", _InputTimeRole.default], ["LabelRole", _LabelRole.default], ["LegendRole", _LegendRole.default], ["LineBreakRole", _LineBreakRole.default], ["LinkRole", _LinkRole.default], ["ListBoxOptionRole", _ListBoxOptionRole.default], ["ListBoxRole", _ListBoxRole.default], ["ListItemRole", _ListItemRole.default], ["ListMarkerRole", _ListMarkerRole.default], ["ListRole", _ListRole.default], ["LogRole", _LogRole.default], ["MainRole", _MainRole.default], ["MarkRole", _MarkRole.default], ["MarqueeRole", _MarqueeRole.default], ["MathRole", _MathRole.default], ["MenuBarRole", _MenuBarRole.default], ["MenuButtonRole", _MenuButtonRole.default], ["MenuItemRole", _MenuItemRole.default], ["MenuItemCheckBoxRole", _MenuItemCheckBoxRole.default], ["MenuItemRadioRole", _MenuItemRadioRole.default], ["MenuListOptionRole", _MenuListOptionRole.default], ["MenuListPopupRole", _MenuListPopupRole.default], ["MenuRole", _MenuRole.default], ["MeterRole", _MeterRole.default], ["NavigationRole", _NavigationRole.default], ["NoneRole", _NoneRole.default], ["NoteRole", _NoteRole.default], ["OutlineRole", _OutlineRole.default], ["ParagraphRole", _ParagraphRole.default], ["PopUpButtonRole", _PopUpButtonRole.default], ["PreRole", _PreRole.default], ["PresentationalRole", _PresentationalRole.default], ["ProgressIndicatorRole", _ProgressIndicatorRole.default], ["RadioButtonRole", _RadioButtonRole.default], ["RadioGroupRole", _RadioGroupRole.default], ["RegionRole", _RegionRole.default], ["RootWebAreaRole", _RootWebAreaRole.default], ["RowHeaderRole", _RowHeaderRole.default], ["RowRole", _RowRole.default], ["RubyRole", _RubyRole.default], ["RulerRole", _RulerRole.default], ["ScrollAreaRole", _ScrollAreaRole.default], ["ScrollBarRole", _ScrollBarRole.default], ["SeamlessWebAreaRole", _SeamlessWebAreaRole.default], ["SearchRole", _SearchRole.default], ["SearchBoxRole", _SearchBoxRole.default], ["SliderRole", _SliderRole.default], ["SliderThumbRole", _SliderThumbRole.default], ["SpinButtonRole", _SpinButtonRole.default], ["SpinButtonPartRole", _SpinButtonPartRole.default], ["SplitterRole", _SplitterRole.default], ["StaticTextRole", _StaticTextRole.default], ["StatusRole", _StatusRole.default], ["SVGRootRole", _SVGRootRole.default], ["SwitchRole", _SwitchRole.default], ["TabGroupRole", _TabGroupRole.default], ["TabRole", _TabRole.default], ["TableHeaderContainerRole", _TableHeaderContainerRole.default], ["TableRole", _TableRole.default], ["TabListRole", _TabListRole.default], ["TabPanelRole", _TabPanelRole.default], ["TermRole", _TermRole.default], ["TextFieldRole", _TextFieldRole.default], ["TimeRole", _TimeRole.default], ["TimerRole", _TimerRole.default], ["ToggleButtonRole", _ToggleButtonRole.default], ["ToolbarRole", _ToolbarRole.default], ["TreeRole", _TreeRole.default], ["TreeGridRole", _TreeGridRole.default], ["TreeItemRole", _TreeItemRole.default], ["UserInterfaceTooltipRole", _UserInterfaceTooltipRole.default], ["VideoRole", _VideoRole.default], ["WebAreaRole", _WebAreaRole.default], ["WindowRole", _WindowRole.default]];
  var AXObjectsMap = {
    entries: function entries() {
      return AXObjects;
    },
    get: function get(key) {
      var item = AXObjects.find(function(tuple) {
        return tuple[0] === key ? true : false;
      });
      return item && item[1];
    },
    has: function has2(key) {
      return !!this.get(key);
    },
    keys: function keys2() {
      return AXObjects.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
        return key;
      });
    },
    values: function values2() {
      return AXObjects.map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), values3 = _ref4[1];
        return values3;
      });
    }
  };
  var _default2 = AXObjectsMap;
  exports.default = _default2;
});
unwrapExports(AXObjectsMap_1);
var AXObjectElementMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AXObjectsMap = _interopRequireDefault(AXObjectsMap_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it2) {
      if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it2)
          o = it2;
        var i = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n2() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it2 = it2.call(o);
    }, n: function n2() {
      var step = it2.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f() {
      try {
        if (!normalCompletion && it2.return != null)
          it2.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var AXObjectElements = [];
  var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()), _step;
  try {
    var _loop = function _loop2() {
      var _step$value = _slicedToArray(_step.value, 2), name2 = _step$value[0], def = _step$value[1];
      var relatedConcepts = def.relatedConcepts;
      if (Array.isArray(relatedConcepts)) {
        relatedConcepts.forEach(function(relation) {
          if (relation.module === "HTML") {
            var concept = relation.concept;
            if (concept) {
              var index2 = AXObjectElements.findIndex(function(_ref5) {
                var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
                return key === name2;
              });
              if (index2 === -1) {
                AXObjectElements.push([name2, []]);
                index2 = AXObjectElements.length - 1;
              }
              AXObjectElements[index2][1].push(concept);
            }
          }
        });
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var AXObjectElementMap = {
    entries: function entries() {
      return AXObjectElements;
    },
    get: function get(key) {
      var item = AXObjectElements.find(function(tuple) {
        return tuple[0] === key ? true : false;
      });
      return item && item[1];
    },
    has: function has2(key) {
      return !!this.get(key);
    },
    keys: function keys2() {
      return AXObjectElements.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
        return key;
      });
    },
    values: function values2() {
      return AXObjectElements.map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), values3 = _ref4[1];
        return values3;
      });
    }
  };
  var _default2 = AXObjectElementMap;
  exports.default = _default2;
});
unwrapExports(AXObjectElementMap_1);
var AXObjectRoleMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AXObjectsMap = _interopRequireDefault(AXObjectsMap_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it2) {
      if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it2)
          o = it2;
        var i = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n2() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it2 = it2.call(o);
    }, n: function n2() {
      var step = it2.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f() {
      try {
        if (!normalCompletion && it2.return != null)
          it2.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var AXObjectRoleElements = [];
  var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()), _step;
  try {
    var _loop = function _loop2() {
      var _step$value = _slicedToArray(_step.value, 2), name2 = _step$value[0], def = _step$value[1];
      var relatedConcepts = def.relatedConcepts;
      if (Array.isArray(relatedConcepts)) {
        relatedConcepts.forEach(function(relation) {
          if (relation.module === "ARIA") {
            var concept = relation.concept;
            if (concept) {
              var index2 = AXObjectRoleElements.findIndex(function(_ref5) {
                var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
                return key === name2;
              });
              if (index2 === -1) {
                AXObjectRoleElements.push([name2, []]);
                index2 = AXObjectRoleElements.length - 1;
              }
              AXObjectRoleElements[index2][1].push(concept);
            }
          }
        });
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var AXObjectRoleMap = {
    entries: function entries() {
      return AXObjectRoleElements;
    },
    get: function get(key) {
      var item = AXObjectRoleElements.find(function(tuple) {
        return tuple[0] === key ? true : false;
      });
      return item && item[1];
    },
    has: function has2(key) {
      return !!this.get(key);
    },
    keys: function keys2() {
      return AXObjectRoleElements.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
        return key;
      });
    },
    values: function values2() {
      return AXObjectRoleElements.map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), values3 = _ref4[1];
        return values3;
      });
    }
  };
  var _default2 = AXObjectRoleMap;
  exports.default = _default2;
});
unwrapExports(AXObjectRoleMap_1);
var elementAXObjectMap_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _AXObjectsMap = _interopRequireDefault(AXObjectsMap_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it2) {
      if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it2)
          o = it2;
        var i = 0;
        var F2 = function F3() {
        };
        return { s: F2, n: function n2() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e2) {
          throw _e2;
        }, f: F2 };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it2 = it2.call(o);
    }, n: function n2() {
      var step = it2.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f() {
      try {
        if (!normalCompletion && it2.return != null)
          it2.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var elementAXObjects = [];
  var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()), _step;
  try {
    var _loop = function _loop2() {
      var _step$value = _slicedToArray(_step.value, 2), name2 = _step$value[0], def = _step$value[1];
      var relatedConcepts = def.relatedConcepts;
      if (Array.isArray(relatedConcepts)) {
        relatedConcepts.forEach(function(relation) {
          if (relation.module === "HTML") {
            var concept = relation.concept;
            if (concept) {
              var conceptStr = JSON.stringify(concept);
              var axObjects;
              var index2 = 0;
              for (; index2 < elementAXObjects.length; index2++) {
                var _key = elementAXObjects[index2][0];
                if (JSON.stringify(_key) === conceptStr) {
                  axObjects = elementAXObjects[index2][1];
                  break;
                }
              }
              if (!axObjects) {
                axObjects = [];
              }
              var loc = axObjects.findIndex(function(item) {
                return item === name2;
              });
              if (loc === -1) {
                axObjects.push(name2);
              }
              if (index2 < elementAXObjects.length) {
                elementAXObjects.splice(index2, 1, [concept, axObjects]);
              } else {
                elementAXObjects.push([concept, axObjects]);
              }
            }
          }
        });
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var elementAXObjectMap = {
    entries: function entries() {
      return elementAXObjects;
    },
    get: function get(key) {
      var item = elementAXObjects.find(function(tuple) {
        return tuple[0] === key ? true : false;
      });
      return item && item[1];
    },
    has: function has2(key) {
      return !!this.get(key);
    },
    keys: function keys2() {
      return elementAXObjects.map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
        return key;
      });
    },
    values: function values2() {
      return elementAXObjects.map(function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2), values3 = _ref4[1];
        return values3;
      });
    }
  };
  var _default2 = elementAXObjectMap;
  exports.default = _default2;
});
unwrapExports(elementAXObjectMap_1);
var lib$1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.elementAXObjects = exports.AXObjects = exports.AXObjectRoles = exports.AXObjectElements = void 0;
  var _AXObjectElementMap = _interopRequireDefault(AXObjectElementMap_1);
  var _AXObjectRoleMap = _interopRequireDefault(AXObjectRoleMap_1);
  var _AXObjectsMap = _interopRequireDefault(AXObjectsMap_1);
  var _elementAXObjectMap = _interopRequireDefault(elementAXObjectMap_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var AXObjectElements = _AXObjectElementMap.default;
  exports.AXObjectElements = AXObjectElements;
  var AXObjectRoles = _AXObjectRoleMap.default;
  exports.AXObjectRoles = AXObjectRoles;
  var AXObjects = _AXObjectsMap.default;
  exports.AXObjects = AXObjects;
  var elementAXObjects = _elementAXObjectMap.default;
  exports.elementAXObjects = elementAXObjects;
});
unwrapExports(lib$1);
var lib_1$1 = lib$1.elementAXObjects;
var lib_2$1 = lib$1.AXObjects;
var lib_3$1 = lib$1.AXObjectRoles;
var lib_4$1 = lib$1.AXObjectElements;
var roles = [...lib_3.keys()];
var non_interactive_roles = new Set(roles.filter((name2) => {
  const role = lib_3.get(name2);
  return !lib_3.get(name2).abstract && name2 !== "toolbar" && !role.superClass.some((classes) => classes.includes("widget"));
}).concat(
  "progressbar"
));
var interactive_roles = new Set(roles.filter((name2) => {
  const role = lib_3.get(name2);
  return !role.abstract && name2 !== "progressbar" && role.superClass.some((classes) => classes.includes("widget"));
}).concat(
  "toolbar"
));
var non_interactive_element_role_schemas = [];
lib_2.entries().forEach(([schema2, roles2]) => {
  if ([...roles2].every((role) => non_interactive_roles.has(role))) {
    non_interactive_element_role_schemas.push(schema2);
  }
});
var interactive_element_role_schemas = [];
lib_2.entries().forEach(([schema2, roles2]) => {
  if ([...roles2].every((role) => interactive_roles.has(role))) {
    interactive_element_role_schemas.push(schema2);
  }
});
var interactive_ax_objects = new Set([...lib_2$1.keys()].filter((name2) => lib_2$1.get(name2).type === "widget"));
var interactive_element_ax_object_schemas = [];
lib_1$1.entries().forEach(([schema2, ax_object]) => {
  if ([...ax_object].every((role) => interactive_ax_objects.has(role))) {
    interactive_element_ax_object_schemas.push(schema2);
  }
});
var aria_attributes = "activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext".split(" ");
var aria_attribute_set = new Set(aria_attributes);
var aria_roles = lib_3.keys();
var aria_role_set = new Set(aria_roles);
var aria_role_abstract_set = new Set(lib_3.keys().filter((role) => lib_3.get(role).abstract));
var TRUE = x`true`;
var FALSE = x`false`;
var svg_attributes = "accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan".split(" ");
var svg_attribute_lookup = /* @__PURE__ */ new Map();
svg_attributes.forEach((name2) => {
  svg_attribute_lookup.set(name2.toLowerCase(), name2);
});
var attribute_lookup = {
  allowfullscreen: { property_name: "allowFullscreen", applies_to: ["iframe"] },
  allowpaymentrequest: { property_name: "allowPaymentRequest", applies_to: ["iframe"] },
  async: { applies_to: ["script"] },
  autofocus: { applies_to: ["button", "input", "keygen", "select", "textarea"] },
  autoplay: { applies_to: ["audio", "video"] },
  checked: { applies_to: ["input"] },
  controls: { applies_to: ["audio", "video"] },
  default: { applies_to: ["track"] },
  defer: { applies_to: ["script"] },
  disabled: {
    applies_to: [
      "button",
      "fieldset",
      "input",
      "keygen",
      "optgroup",
      "option",
      "select",
      "textarea"
    ]
  },
  formnovalidate: { property_name: "formNoValidate", applies_to: ["button", "input"] },
  hidden: {},
  indeterminate: { applies_to: ["input"] },
  ismap: { property_name: "isMap", applies_to: ["img"] },
  loop: { applies_to: ["audio", "bgsound", "video"] },
  multiple: { applies_to: ["input", "select"] },
  muted: { applies_to: ["audio", "video"] },
  nomodule: { property_name: "noModule", applies_to: ["script"] },
  novalidate: { property_name: "noValidate", applies_to: ["form"] },
  open: { applies_to: ["details", "dialog"] },
  playsinline: { property_name: "playsInline", applies_to: ["video"] },
  readonly: { property_name: "readOnly", applies_to: ["input", "textarea"] },
  required: { applies_to: ["input", "select", "textarea"] },
  reversed: { applies_to: ["ol"] },
  selected: { applies_to: ["option"] },
  value: {
    applies_to: [
      "button",
      "option",
      "input",
      "li",
      "meter",
      "progress",
      "param",
      "select",
      "textarea"
    ]
  }
};
Object.keys(attribute_lookup).forEach((name2) => {
  const metadata = attribute_lookup[name2];
  if (!metadata.property_name)
    metadata.property_name = name2;
});
var charToInteger$1 = {};
var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
for (i$3 = 0; i$3 < chars$1.length; i$3++) {
  charToInteger$1[chars$1.charCodeAt(i$3)] = i$3;
}
var i$3;
var Url$1 = typeof URL !== "undefined" ? URL : require_url().URL;
var Chunk = function Chunk2(start2, end2, content) {
  this.start = start2;
  this.end = end2;
  this.original = content;
  this.intro = "";
  this.outro = "";
  this.content = content;
  this.storeName = false;
  this.edited = false;
  Object.defineProperties(this, {
    previous: { writable: true, value: null },
    next: { writable: true, value: null }
  });
};
Chunk.prototype.appendLeft = function appendLeft(content) {
  this.outro += content;
};
Chunk.prototype.appendRight = function appendRight(content) {
  this.intro = this.intro + content;
};
Chunk.prototype.clone = function clone() {
  var chunk = new Chunk(this.start, this.end, this.original);
  chunk.intro = this.intro;
  chunk.outro = this.outro;
  chunk.content = this.content;
  chunk.storeName = this.storeName;
  chunk.edited = this.edited;
  return chunk;
};
Chunk.prototype.contains = function contains(index2) {
  return this.start < index2 && index2 < this.end;
};
Chunk.prototype.eachNext = function eachNext(fn) {
  var chunk = this;
  while (chunk) {
    fn(chunk);
    chunk = chunk.next;
  }
};
Chunk.prototype.eachPrevious = function eachPrevious(fn) {
  var chunk = this;
  while (chunk) {
    fn(chunk);
    chunk = chunk.previous;
  }
};
Chunk.prototype.edit = function edit(content, storeName, contentOnly) {
  this.content = content;
  if (!contentOnly) {
    this.intro = "";
    this.outro = "";
  }
  this.storeName = storeName;
  this.edited = true;
  return this;
};
Chunk.prototype.prependLeft = function prependLeft(content) {
  this.outro = content + this.outro;
};
Chunk.prototype.prependRight = function prependRight(content) {
  this.intro = content + this.intro;
};
Chunk.prototype.split = function split(index2) {
  var sliceIndex = index2 - this.start;
  var originalBefore = this.original.slice(0, sliceIndex);
  var originalAfter = this.original.slice(sliceIndex);
  this.original = originalBefore;
  var newChunk = new Chunk(index2, this.end, originalAfter);
  newChunk.outro = this.outro;
  this.outro = "";
  this.end = index2;
  if (this.edited) {
    newChunk.edit("", false);
    this.content = "";
  } else {
    this.content = originalBefore;
  }
  newChunk.next = this.next;
  if (newChunk.next) {
    newChunk.next.previous = newChunk;
  }
  newChunk.previous = this;
  this.next = newChunk;
  return newChunk;
};
Chunk.prototype.toString = function toString2() {
  return this.intro + this.content + this.outro;
};
Chunk.prototype.trimEnd = function trimEnd(rx2) {
  this.outro = this.outro.replace(rx2, "");
  if (this.outro.length) {
    return true;
  }
  var trimmed = this.content.replace(rx2, "");
  if (trimmed.length) {
    if (trimmed !== this.content) {
      this.split(this.start + trimmed.length).edit("", void 0, true);
    }
    return true;
  } else {
    this.edit("", void 0, true);
    this.intro = this.intro.replace(rx2, "");
    if (this.intro.length) {
      return true;
    }
  }
};
Chunk.prototype.trimStart = function trimStart(rx2) {
  this.intro = this.intro.replace(rx2, "");
  if (this.intro.length) {
    return true;
  }
  var trimmed = this.content.replace(rx2, "");
  if (trimmed.length) {
    if (trimmed !== this.content) {
      this.split(this.end - trimmed.length);
      this.edit("", void 0, true);
    }
    return true;
  } else {
    this.edit("", void 0, true);
    this.outro = this.outro.replace(rx2, "");
    if (this.outro.length) {
      return true;
    }
  }
};
var btoa$2 = function() {
  throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
};
if (typeof window !== "undefined" && typeof window.btoa === "function") {
  btoa$2 = function(str2) {
    return window.btoa(unescape(encodeURIComponent(str2)));
  };
} else if (typeof Buffer === "function") {
  btoa$2 = function(str2) {
    return Buffer.from(str2, "utf-8").toString("base64");
  };
}
var SourceMap$1 = function SourceMap(properties2) {
  this.version = 3;
  this.file = properties2.file;
  this.sources = properties2.sources;
  this.sourcesContent = properties2.sourcesContent;
  this.names = properties2.names;
  this.mappings = encode(properties2.mappings);
};
SourceMap$1.prototype.toString = function toString3() {
  return JSON.stringify(this);
};
SourceMap$1.prototype.toUrl = function toUrl() {
  return "data:application/json;charset=utf-8;base64," + btoa$2(this.toString());
};
function guessIndent(code2) {
  var lines = code2.split("\n");
  var tabbed = lines.filter(function(line2) {
    return /^\t+/.test(line2);
  });
  var spaced = lines.filter(function(line2) {
    return /^ {2,}/.test(line2);
  });
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  var min = spaced.reduce(function(previous, current2) {
    var numSpaces = /^ +/.exec(current2)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(" ");
}
function getRelativePath(from, to) {
  var fromParts = from.split(/[/\\]/);
  var toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    var i = fromParts.length;
    while (i--) {
      fromParts[i] = "..";
    }
  }
  return fromParts.concat(toParts).join("/");
}
var toString$1 = Object.prototype.toString;
function isObject(thing) {
  return toString$1.call(thing) === "[object Object]";
}
function getLocator$1(source) {
  var originalLines = source.split("\n");
  var lineOffsets = [];
  for (var i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate3(index2) {
    var i2 = 0;
    var j = lineOffsets.length;
    while (i2 < j) {
      var m = i2 + j >> 1;
      if (index2 < lineOffsets[m]) {
        j = m;
      } else {
        i2 = m + 1;
      }
    }
    var line2 = i2 - 1;
    var column = index2 - lineOffsets[line2];
    return { line: line2, column };
  };
}
var Mappings = function Mappings2(hires) {
  this.hires = hires;
  this.generatedCodeLine = 0;
  this.generatedCodeColumn = 0;
  this.raw = [];
  this.rawSegments = this.raw[this.generatedCodeLine] = [];
  this.pending = null;
};
Mappings.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {
  if (content.length) {
    var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
    if (nameIndex >= 0) {
      segment.push(nameIndex);
    }
    this.rawSegments.push(segment);
  } else if (this.pending) {
    this.rawSegments.push(this.pending);
  }
  this.advance(content);
  this.pending = null;
};
Mappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
  var originalCharIndex = chunk.start;
  var first2 = true;
  while (originalCharIndex < chunk.end) {
    if (this.hires || first2 || sourcemapLocations[originalCharIndex]) {
      this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
    }
    if (original[originalCharIndex] === "\n") {
      loc.line += 1;
      loc.column = 0;
      this.generatedCodeLine += 1;
      this.raw[this.generatedCodeLine] = this.rawSegments = [];
      this.generatedCodeColumn = 0;
    } else {
      loc.column += 1;
      this.generatedCodeColumn += 1;
    }
    originalCharIndex += 1;
    first2 = false;
  }
  this.pending = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
};
Mappings.prototype.advance = function advance2(str2) {
  if (!str2) {
    return;
  }
  var lines = str2.split("\n");
  if (lines.length > 1) {
    for (var i = 0; i < lines.length - 1; i++) {
      this.generatedCodeLine++;
      this.raw[this.generatedCodeLine] = this.rawSegments = [];
    }
    this.generatedCodeColumn = 0;
  }
  this.generatedCodeColumn += lines[lines.length - 1].length;
};
var n = "\n";
var warned = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
var MagicString = function MagicString2(string, options2) {
  if (options2 === void 0)
    options2 = {};
  var chunk = new Chunk(0, string.length, string);
  Object.defineProperties(this, {
    original: { writable: true, value: string },
    outro: { writable: true, value: "" },
    intro: { writable: true, value: "" },
    firstChunk: { writable: true, value: chunk },
    lastChunk: { writable: true, value: chunk },
    lastSearchedChunk: { writable: true, value: chunk },
    byStart: { writable: true, value: {} },
    byEnd: { writable: true, value: {} },
    filename: { writable: true, value: options2.filename },
    indentExclusionRanges: { writable: true, value: options2.indentExclusionRanges },
    sourcemapLocations: { writable: true, value: {} },
    storedNames: { writable: true, value: {} },
    indentStr: { writable: true, value: guessIndent(string) }
  });
  this.byStart[0] = chunk;
  this.byEnd[string.length] = chunk;
};
MagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {
  this.sourcemapLocations[char] = true;
};
MagicString.prototype.append = function append(content) {
  if (typeof content !== "string") {
    throw new TypeError("outro content must be a string");
  }
  this.outro += content;
  return this;
};
MagicString.prototype.appendLeft = function appendLeft2(index2, content) {
  if (typeof content !== "string") {
    throw new TypeError("inserted content must be a string");
  }
  this._split(index2);
  var chunk = this.byEnd[index2];
  if (chunk) {
    chunk.appendLeft(content);
  } else {
    this.intro += content;
  }
  return this;
};
MagicString.prototype.appendRight = function appendRight2(index2, content) {
  if (typeof content !== "string") {
    throw new TypeError("inserted content must be a string");
  }
  this._split(index2);
  var chunk = this.byStart[index2];
  if (chunk) {
    chunk.appendRight(content);
  } else {
    this.outro += content;
  }
  return this;
};
MagicString.prototype.clone = function clone2() {
  var cloned = new MagicString(this.original, { filename: this.filename });
  var originalChunk = this.firstChunk;
  var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
  while (originalChunk) {
    cloned.byStart[clonedChunk.start] = clonedChunk;
    cloned.byEnd[clonedChunk.end] = clonedChunk;
    var nextOriginalChunk = originalChunk.next;
    var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
    if (nextClonedChunk) {
      clonedChunk.next = nextClonedChunk;
      nextClonedChunk.previous = clonedChunk;
      clonedChunk = nextClonedChunk;
    }
    originalChunk = nextOriginalChunk;
  }
  cloned.lastChunk = clonedChunk;
  if (this.indentExclusionRanges) {
    cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
  }
  Object.keys(this.sourcemapLocations).forEach(function(loc) {
    cloned.sourcemapLocations[loc] = true;
  });
  return cloned;
};
MagicString.prototype.generateDecodedMap = function generateDecodedMap(options2) {
  var this$1 = this;
  options2 = options2 || {};
  var sourceIndex = 0;
  var names2 = Object.keys(this.storedNames);
  var mappings = new Mappings(options2.hires);
  var locate3 = getLocator$1(this.original);
  if (this.intro) {
    mappings.advance(this.intro);
  }
  this.firstChunk.eachNext(function(chunk) {
    var loc = locate3(chunk.start);
    if (chunk.intro.length) {
      mappings.advance(chunk.intro);
    }
    if (chunk.edited) {
      mappings.addEdit(
        sourceIndex,
        chunk.content,
        loc,
        chunk.storeName ? names2.indexOf(chunk.original) : -1
      );
    } else {
      mappings.addUneditedChunk(sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations);
    }
    if (chunk.outro.length) {
      mappings.advance(chunk.outro);
    }
  });
  return {
    file: options2.file ? options2.file.split(/[/\\]/).pop() : null,
    sources: [options2.source ? getRelativePath(options2.file || "", options2.source) : null],
    sourcesContent: options2.includeContent ? [this.original] : [null],
    names: names2,
    mappings: mappings.raw
  };
};
MagicString.prototype.generateMap = function generateMap(options2) {
  return new SourceMap$1(this.generateDecodedMap(options2));
};
MagicString.prototype.getIndentString = function getIndentString() {
  return this.indentStr === null ? "	" : this.indentStr;
};
MagicString.prototype.indent = function indent(indentStr, options2) {
  var pattern = /^[^\r\n]/gm;
  if (isObject(indentStr)) {
    options2 = indentStr;
    indentStr = void 0;
  }
  indentStr = indentStr !== void 0 ? indentStr : this.indentStr || "	";
  if (indentStr === "") {
    return this;
  }
  options2 = options2 || {};
  var isExcluded = {};
  if (options2.exclude) {
    var exclusions = typeof options2.exclude[0] === "number" ? [options2.exclude] : options2.exclude;
    exclusions.forEach(function(exclusion) {
      for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
        isExcluded[i] = true;
      }
    });
  }
  var shouldIndentNextCharacter = options2.indentStart !== false;
  var replacer = function(match) {
    if (shouldIndentNextCharacter) {
      return "" + indentStr + match;
    }
    shouldIndentNextCharacter = true;
    return match;
  };
  this.intro = this.intro.replace(pattern, replacer);
  var charIndex = 0;
  var chunk = this.firstChunk;
  while (chunk) {
    var end2 = chunk.end;
    if (chunk.edited) {
      if (!isExcluded[charIndex]) {
        chunk.content = chunk.content.replace(pattern, replacer);
        if (chunk.content.length) {
          shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
        }
      }
    } else {
      charIndex = chunk.start;
      while (charIndex < end2) {
        if (!isExcluded[charIndex]) {
          var char = this.original[charIndex];
          if (char === "\n") {
            shouldIndentNextCharacter = true;
          } else if (char !== "\r" && shouldIndentNextCharacter) {
            shouldIndentNextCharacter = false;
            if (charIndex === chunk.start) {
              chunk.prependRight(indentStr);
            } else {
              this._splitChunk(chunk, charIndex);
              chunk = chunk.next;
              chunk.prependRight(indentStr);
            }
          }
        }
        charIndex += 1;
      }
    }
    charIndex = chunk.end;
    chunk = chunk.next;
  }
  this.outro = this.outro.replace(pattern, replacer);
  return this;
};
MagicString.prototype.insert = function insert() {
  throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
};
MagicString.prototype.insertLeft = function insertLeft(index2, content) {
  if (!warned.insertLeft) {
    console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
    warned.insertLeft = true;
  }
  return this.appendLeft(index2, content);
};
MagicString.prototype.insertRight = function insertRight(index2, content) {
  if (!warned.insertRight) {
    console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
    warned.insertRight = true;
  }
  return this.prependRight(index2, content);
};
MagicString.prototype.move = function move(start2, end2, index2) {
  if (index2 >= start2 && index2 <= end2) {
    throw new Error("Cannot move a selection inside itself");
  }
  this._split(start2);
  this._split(end2);
  this._split(index2);
  var first2 = this.byStart[start2];
  var last = this.byEnd[end2];
  var oldLeft = first2.previous;
  var oldRight = last.next;
  var newRight = this.byStart[index2];
  if (!newRight && last === this.lastChunk) {
    return this;
  }
  var newLeft = newRight ? newRight.previous : this.lastChunk;
  if (oldLeft) {
    oldLeft.next = oldRight;
  }
  if (oldRight) {
    oldRight.previous = oldLeft;
  }
  if (newLeft) {
    newLeft.next = first2;
  }
  if (newRight) {
    newRight.previous = last;
  }
  if (!first2.previous) {
    this.firstChunk = last.next;
  }
  if (!last.next) {
    this.lastChunk = first2.previous;
    this.lastChunk.next = null;
  }
  first2.previous = newLeft;
  last.next = newRight || null;
  if (!newLeft) {
    this.firstChunk = first2;
  }
  if (!newRight) {
    this.lastChunk = last;
  }
  return this;
};
MagicString.prototype.overwrite = function overwrite(start2, end2, content, options2) {
  if (typeof content !== "string") {
    throw new TypeError("replacement content must be a string");
  }
  while (start2 < 0) {
    start2 += this.original.length;
  }
  while (end2 < 0) {
    end2 += this.original.length;
  }
  if (end2 > this.original.length) {
    throw new Error("end is out of bounds");
  }
  if (start2 === end2) {
    throw new Error("Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead");
  }
  this._split(start2);
  this._split(end2);
  if (options2 === true) {
    if (!warned.storeName) {
      console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
      warned.storeName = true;
    }
    options2 = { storeName: true };
  }
  var storeName = options2 !== void 0 ? options2.storeName : false;
  var contentOnly = options2 !== void 0 ? options2.contentOnly : false;
  if (storeName) {
    var original = this.original.slice(start2, end2);
    this.storedNames[original] = true;
  }
  var first2 = this.byStart[start2];
  var last = this.byEnd[end2];
  if (first2) {
    if (end2 > first2.end && first2.next !== this.byStart[first2.end]) {
      throw new Error("Cannot overwrite across a split point");
    }
    first2.edit(content, storeName, contentOnly);
    if (first2 !== last) {
      var chunk = first2.next;
      while (chunk !== last) {
        chunk.edit("", false);
        chunk = chunk.next;
      }
      chunk.edit("", false);
    }
  } else {
    var newChunk = new Chunk(start2, end2, "").edit(content, storeName);
    last.next = newChunk;
    newChunk.previous = last;
  }
  return this;
};
MagicString.prototype.prepend = function prepend(content) {
  if (typeof content !== "string") {
    throw new TypeError("outro content must be a string");
  }
  this.intro = content + this.intro;
  return this;
};
MagicString.prototype.prependLeft = function prependLeft2(index2, content) {
  if (typeof content !== "string") {
    throw new TypeError("inserted content must be a string");
  }
  this._split(index2);
  var chunk = this.byEnd[index2];
  if (chunk) {
    chunk.prependLeft(content);
  } else {
    this.intro = content + this.intro;
  }
  return this;
};
MagicString.prototype.prependRight = function prependRight2(index2, content) {
  if (typeof content !== "string") {
    throw new TypeError("inserted content must be a string");
  }
  this._split(index2);
  var chunk = this.byStart[index2];
  if (chunk) {
    chunk.prependRight(content);
  } else {
    this.outro = content + this.outro;
  }
  return this;
};
MagicString.prototype.remove = function remove(start2, end2) {
  while (start2 < 0) {
    start2 += this.original.length;
  }
  while (end2 < 0) {
    end2 += this.original.length;
  }
  if (start2 === end2) {
    return this;
  }
  if (start2 < 0 || end2 > this.original.length) {
    throw new Error("Character is out of bounds");
  }
  if (start2 > end2) {
    throw new Error("end must be greater than start");
  }
  this._split(start2);
  this._split(end2);
  var chunk = this.byStart[start2];
  while (chunk) {
    chunk.intro = "";
    chunk.outro = "";
    chunk.edit("");
    chunk = end2 > chunk.end ? this.byStart[chunk.end] : null;
  }
  return this;
};
MagicString.prototype.lastChar = function lastChar() {
  if (this.outro.length) {
    return this.outro[this.outro.length - 1];
  }
  var chunk = this.lastChunk;
  do {
    if (chunk.outro.length) {
      return chunk.outro[chunk.outro.length - 1];
    }
    if (chunk.content.length) {
      return chunk.content[chunk.content.length - 1];
    }
    if (chunk.intro.length) {
      return chunk.intro[chunk.intro.length - 1];
    }
  } while (chunk = chunk.previous);
  if (this.intro.length) {
    return this.intro[this.intro.length - 1];
  }
  return "";
};
MagicString.prototype.lastLine = function lastLine() {
  var lineIndex = this.outro.lastIndexOf(n);
  if (lineIndex !== -1) {
    return this.outro.substr(lineIndex + 1);
  }
  var lineStr = this.outro;
  var chunk = this.lastChunk;
  do {
    if (chunk.outro.length > 0) {
      lineIndex = chunk.outro.lastIndexOf(n);
      if (lineIndex !== -1) {
        return chunk.outro.substr(lineIndex + 1) + lineStr;
      }
      lineStr = chunk.outro + lineStr;
    }
    if (chunk.content.length > 0) {
      lineIndex = chunk.content.lastIndexOf(n);
      if (lineIndex !== -1) {
        return chunk.content.substr(lineIndex + 1) + lineStr;
      }
      lineStr = chunk.content + lineStr;
    }
    if (chunk.intro.length > 0) {
      lineIndex = chunk.intro.lastIndexOf(n);
      if (lineIndex !== -1) {
        return chunk.intro.substr(lineIndex + 1) + lineStr;
      }
      lineStr = chunk.intro + lineStr;
    }
  } while (chunk = chunk.previous);
  lineIndex = this.intro.lastIndexOf(n);
  if (lineIndex !== -1) {
    return this.intro.substr(lineIndex + 1) + lineStr;
  }
  return this.intro + lineStr;
};
MagicString.prototype.slice = function slice(start2, end2) {
  if (start2 === void 0)
    start2 = 0;
  if (end2 === void 0)
    end2 = this.original.length;
  while (start2 < 0) {
    start2 += this.original.length;
  }
  while (end2 < 0) {
    end2 += this.original.length;
  }
  var result = "";
  var chunk = this.firstChunk;
  while (chunk && (chunk.start > start2 || chunk.end <= start2)) {
    if (chunk.start < end2 && chunk.end >= end2) {
      return result;
    }
    chunk = chunk.next;
  }
  if (chunk && chunk.edited && chunk.start !== start2) {
    throw new Error("Cannot use replaced character " + start2 + " as slice start anchor.");
  }
  var startChunk = chunk;
  while (chunk) {
    if (chunk.intro && (startChunk !== chunk || chunk.start === start2)) {
      result += chunk.intro;
    }
    var containsEnd = chunk.start < end2 && chunk.end >= end2;
    if (containsEnd && chunk.edited && chunk.end !== end2) {
      throw new Error("Cannot use replaced character " + end2 + " as slice end anchor.");
    }
    var sliceStart = startChunk === chunk ? start2 - chunk.start : 0;
    var sliceEnd = containsEnd ? chunk.content.length + end2 - chunk.end : chunk.content.length;
    result += chunk.content.slice(sliceStart, sliceEnd);
    if (chunk.outro && (!containsEnd || chunk.end === end2)) {
      result += chunk.outro;
    }
    if (containsEnd) {
      break;
    }
    chunk = chunk.next;
  }
  return result;
};
MagicString.prototype.snip = function snip(start2, end2) {
  var clone3 = this.clone();
  clone3.remove(0, start2);
  clone3.remove(end2, clone3.original.length);
  return clone3;
};
MagicString.prototype._split = function _split(index2) {
  if (this.byStart[index2] || this.byEnd[index2]) {
    return;
  }
  var chunk = this.lastSearchedChunk;
  var searchForward = index2 > chunk.end;
  while (chunk) {
    if (chunk.contains(index2)) {
      return this._splitChunk(chunk, index2);
    }
    chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
  }
};
MagicString.prototype._splitChunk = function _splitChunk(chunk, index2) {
  if (chunk.edited && chunk.content.length) {
    var loc = getLocator$1(this.original)(index2);
    throw new Error(
      "Cannot split a chunk that has already been edited (" + loc.line + ":" + loc.column + ' \u2013 "' + chunk.original + '")'
    );
  }
  var newChunk = chunk.split(index2);
  this.byEnd[index2] = chunk;
  this.byStart[index2] = newChunk;
  this.byEnd[newChunk.end] = newChunk;
  if (chunk === this.lastChunk) {
    this.lastChunk = newChunk;
  }
  this.lastSearchedChunk = chunk;
  return true;
};
MagicString.prototype.toString = function toString4() {
  var str2 = this.intro;
  var chunk = this.firstChunk;
  while (chunk) {
    str2 += chunk.toString();
    chunk = chunk.next;
  }
  return str2 + this.outro;
};
MagicString.prototype.isEmpty = function isEmpty() {
  var chunk = this.firstChunk;
  do {
    if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) {
      return false;
    }
  } while (chunk = chunk.next);
  return true;
};
MagicString.prototype.length = function length() {
  var chunk = this.firstChunk;
  var length2 = 0;
  do {
    length2 += chunk.intro.length + chunk.content.length + chunk.outro.length;
  } while (chunk = chunk.next);
  return length2;
};
MagicString.prototype.trimLines = function trimLines() {
  return this.trim("[\\r\\n]");
};
MagicString.prototype.trim = function trim(charType) {
  return this.trimStart(charType).trimEnd(charType);
};
MagicString.prototype.trimEndAborted = function trimEndAborted(charType) {
  var rx2 = new RegExp((charType || "\\s") + "+$");
  this.outro = this.outro.replace(rx2, "");
  if (this.outro.length) {
    return true;
  }
  var chunk = this.lastChunk;
  do {
    var end2 = chunk.end;
    var aborted = chunk.trimEnd(rx2);
    if (chunk.end !== end2) {
      if (this.lastChunk === chunk) {
        this.lastChunk = chunk.next;
      }
      this.byEnd[chunk.end] = chunk;
      this.byStart[chunk.next.start] = chunk.next;
      this.byEnd[chunk.next.end] = chunk.next;
    }
    if (aborted) {
      return true;
    }
    chunk = chunk.previous;
  } while (chunk);
  return false;
};
MagicString.prototype.trimEnd = function trimEnd2(charType) {
  this.trimEndAborted(charType);
  return this;
};
MagicString.prototype.trimStartAborted = function trimStartAborted(charType) {
  var rx2 = new RegExp("^" + (charType || "\\s") + "+");
  this.intro = this.intro.replace(rx2, "");
  if (this.intro.length) {
    return true;
  }
  var chunk = this.firstChunk;
  do {
    var end2 = chunk.end;
    var aborted = chunk.trimStart(rx2);
    if (chunk.end !== end2) {
      if (chunk === this.lastChunk) {
        this.lastChunk = chunk.next;
      }
      this.byEnd[chunk.end] = chunk;
      this.byStart[chunk.next.start] = chunk.next;
      this.byEnd[chunk.next.end] = chunk.next;
    }
    if (aborted) {
      return true;
    }
    chunk = chunk.next;
  } while (chunk);
  return false;
};
MagicString.prototype.trimStart = function trimStart2(charType) {
  this.trimStartAborted(charType);
  return this;
};
var BlockAppliesToNode;
(function(BlockAppliesToNode2) {
  BlockAppliesToNode2[BlockAppliesToNode2["NotPossible"] = 0] = "NotPossible";
  BlockAppliesToNode2[BlockAppliesToNode2["Possible"] = 1] = "Possible";
  BlockAppliesToNode2[BlockAppliesToNode2["UnknownSelectorType"] = 2] = "UnknownSelectorType";
})(BlockAppliesToNode || (BlockAppliesToNode = {}));
var NodeExist;
(function(NodeExist2) {
  NodeExist2[NodeExist2["Probably"] = 1] = "Probably";
  NodeExist2[NodeExist2["Definitely"] = 2] = "Definitely";
})(NodeExist || (NodeExist = {}));
var test = typeof process !== "undefined" && process.env.TEST;

// node_modules/mdsvex/dist/main.es.js
var import_util = __toESM(require_util());
var defineConfig = (config) => config;
var bail_1 = bail;
function bail(err) {
  if (err) {
    throw err;
  }
}
var isBuffer = function isBuffer2(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
};
var hasOwn2 = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;
var isArray2 = function isArray3(arr) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr);
  }
  return toStr.call(arr) === "[object Array]";
};
var isPlainObject = function isPlainObject2(obj) {
  if (!obj || toStr.call(obj) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn2.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn2.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key;
  for (key in obj) {
  }
  return typeof key === "undefined" || hasOwn2.call(obj, key);
};
var setProperty = function setProperty2(target2, options2) {
  if (defineProperty && options2.name === "__proto__") {
    defineProperty(target2, options2.name, {
      enumerable: true,
      configurable: true,
      value: options2.newValue,
      writable: true
    });
  } else {
    target2[options2.name] = options2.newValue;
  }
};
var getProperty = function getProperty2(obj, name2) {
  if (name2 === "__proto__") {
    if (!hasOwn2.call(obj, name2)) {
      return void 0;
    } else if (gOPD) {
      return gOPD(obj, name2).value;
    }
  }
  return obj[name2];
};
var extend$2 = function extend2() {
  var options2, name2, src, copy2, copyIsArray, clone3;
  var target2 = arguments[0];
  var i = 1;
  var length2 = arguments.length;
  var deep = false;
  if (typeof target2 === "boolean") {
    deep = target2;
    target2 = arguments[1] || {};
    i = 2;
  }
  if (target2 == null || typeof target2 !== "object" && typeof target2 !== "function") {
    target2 = {};
  }
  for (; i < length2; ++i) {
    options2 = arguments[i];
    if (options2 != null) {
      for (name2 in options2) {
        src = getProperty(target2, name2);
        copy2 = getProperty(options2, name2);
        if (target2 !== copy2) {
          if (deep && copy2 && (isPlainObject(copy2) || (copyIsArray = isArray2(copy2)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone3 = src && isArray2(src) ? src : [];
            } else {
              clone3 = src && isPlainObject(src) ? src : {};
            }
            setProperty(target2, { name: name2, newValue: extend2(deep, clone3, copy2) });
          } else if (typeof copy2 !== "undefined") {
            setProperty(target2, { name: name2, newValue: copy2 });
          }
        }
      }
    }
  }
  return target2;
};
var isPlainObj = (value2) => {
  if (Object.prototype.toString.call(value2) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value2);
  return prototype === null || prototype === Object.prototype;
};
var slice$3 = [].slice;
var wrap_1$1 = wrap$2;
function wrap$2(fn, callback) {
  var invoked;
  return wrapped;
  function wrapped() {
    var params = slice$3.call(arguments, 0);
    var callback2 = fn.length > params.length;
    var result;
    if (callback2) {
      params.push(done);
    }
    try {
      result = fn.apply(null, params);
    } catch (error2) {
      if (callback2 && invoked) {
        throw error2;
      }
      return done(error2);
    }
    if (!callback2) {
      if (result && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done() {
    if (!invoked) {
      invoked = true;
      callback.apply(null, arguments);
    }
  }
  function then(value2) {
    done(null, value2);
  }
}
var trough_1 = trough;
trough.wrap = wrap_1$1;
var slice$2 = [].slice;
function trough() {
  var fns = [];
  var middleware = {};
  middleware.run = run2;
  middleware.use = use;
  return middleware;
  function run2() {
    var index2 = -1;
    var input = slice$2.call(arguments, 0, -1);
    var done = arguments[arguments.length - 1];
    if (typeof done !== "function") {
      throw new Error("Expected function as last argument, not " + done);
    }
    next.apply(null, [null].concat(input));
    function next(err) {
      var fn = fns[++index2];
      var params = slice$2.call(arguments, 0);
      var values2 = params.slice(1);
      var length2 = input.length;
      var pos = -1;
      if (err) {
        done(err);
        return;
      }
      while (++pos < length2) {
        if (values2[pos] === null || values2[pos] === void 0) {
          values2[pos] = input[pos];
        }
      }
      input = values2;
      if (fn) {
        wrap_1$1(fn, next).apply(null, input);
      } else {
        done.apply(null, [null].concat(input));
      }
    }
  }
  function use(fn) {
    if (typeof fn !== "function") {
      throw new Error("Expected `fn` to be a function, not " + fn);
    }
    fns.push(fn);
    return middleware;
  }
}
var own$f = {}.hasOwnProperty;
var unistUtilStringifyPosition = stringify$4;
function stringify$4(value2) {
  if (!value2 || typeof value2 !== "object") {
    return "";
  }
  if (own$f.call(value2, "position") || own$f.call(value2, "type")) {
    return position$1(value2.position);
  }
  if (own$f.call(value2, "start") || own$f.call(value2, "end")) {
    return position$1(value2);
  }
  if (own$f.call(value2, "line") || own$f.call(value2, "column")) {
    return point(value2);
  }
  return "";
}
function point(point2) {
  if (!point2 || typeof point2 !== "object") {
    point2 = {};
  }
  return index$6(point2.line) + ":" + index$6(point2.column);
}
function position$1(pos) {
  if (!pos || typeof pos !== "object") {
    pos = {};
  }
  return point(pos.start) + "-" + point(pos.end);
}
function index$6(value2) {
  return value2 && typeof value2 === "number" ? value2 : 1;
}
var vfileMessage = VMessage;
function VMessagePrototype() {
}
VMessagePrototype.prototype = Error.prototype;
VMessage.prototype = new VMessagePrototype();
var proto$6 = VMessage.prototype;
proto$6.file = "";
proto$6.name = "";
proto$6.reason = "";
proto$6.message = "";
proto$6.stack = "";
proto$6.fatal = null;
proto$6.column = null;
proto$6.line = null;
function VMessage(reason, position2, origin) {
  var parts;
  var range2;
  var location;
  if (typeof position2 === "string") {
    origin = position2;
    position2 = null;
  }
  parts = parseOrigin(origin);
  range2 = unistUtilStringifyPosition(position2) || "1:1";
  location = {
    start: { line: null, column: null },
    end: { line: null, column: null }
  };
  if (position2 && position2.position) {
    position2 = position2.position;
  }
  if (position2) {
    if (position2.start) {
      location = position2;
      position2 = position2.start;
    } else {
      location.start = position2;
    }
  }
  if (reason.stack) {
    this.stack = reason.stack;
    reason = reason.message;
  }
  this.message = reason;
  this.name = range2;
  this.reason = reason;
  this.line = position2 ? position2.line : null;
  this.column = position2 ? position2.column : null;
  this.location = location;
  this.source = parts[0];
  this.ruleId = parts[1];
}
function parseOrigin(origin) {
  var result = [null, null];
  var index2;
  if (typeof origin === "string") {
    index2 = origin.indexOf(":");
    if (index2 === -1) {
      result[1] = origin;
    } else {
      result[0] = origin.slice(0, index2);
      result[1] = origin.slice(index2 + 1);
    }
  }
  return result;
}
function replaceExt(npath, ext) {
  if (typeof npath !== "string") {
    return npath;
  }
  if (npath.length === 0) {
    return npath;
  }
  var nFileName = import_path.default.basename(npath, import_path.default.extname(npath)) + ext;
  return import_path.default.join(import_path.default.dirname(npath), nFileName);
}
var replaceExt_1 = replaceExt;
var core$1 = VFile;
var own$e = {}.hasOwnProperty;
var proto$5 = VFile.prototype;
var order$1 = ["history", "path", "basename", "stem", "extname", "dirname"];
proto$5.toString = toString5;
Object.defineProperty(proto$5, "path", { get: getPath, set: setPath });
Object.defineProperty(proto$5, "dirname", { get: getDirname, set: setDirname });
Object.defineProperty(proto$5, "basename", { get: getBasename, set: setBasename });
Object.defineProperty(proto$5, "extname", { get: getExtname, set: setExtname });
Object.defineProperty(proto$5, "stem", { get: getStem, set: setStem });
function VFile(options2) {
  var prop2;
  var index2;
  var length2;
  if (!options2) {
    options2 = {};
  } else if (typeof options2 === "string" || isBuffer(options2)) {
    options2 = { contents: options2 };
  } else if ("message" in options2 && "messages" in options2) {
    return options2;
  }
  if (!(this instanceof VFile)) {
    return new VFile(options2);
  }
  this.data = {};
  this.messages = [];
  this.history = [];
  this.cwd = process.cwd();
  index2 = -1;
  length2 = order$1.length;
  while (++index2 < length2) {
    prop2 = order$1[index2];
    if (own$e.call(options2, prop2)) {
      this[prop2] = options2[prop2];
    }
  }
  for (prop2 in options2) {
    if (order$1.indexOf(prop2) === -1) {
      this[prop2] = options2[prop2];
    }
  }
}
function getPath() {
  return this.history[this.history.length - 1];
}
function setPath(path2) {
  assertNonEmpty(path2, "path");
  if (path2 !== this.path) {
    this.history.push(path2);
  }
}
function getDirname() {
  return typeof this.path === "string" ? import_path.default.dirname(this.path) : void 0;
}
function setDirname(dirname) {
  assertPath(this.path, "dirname");
  this.path = import_path.default.join(dirname || "", this.basename);
}
function getBasename() {
  return typeof this.path === "string" ? import_path.default.basename(this.path) : void 0;
}
function setBasename(basename) {
  assertNonEmpty(basename, "basename");
  assertPart(basename, "basename");
  this.path = import_path.default.join(this.dirname || "", basename);
}
function getExtname() {
  return typeof this.path === "string" ? import_path.default.extname(this.path) : void 0;
}
function setExtname(extname) {
  var ext = extname || "";
  assertPart(ext, "extname");
  assertPath(this.path, "extname");
  if (ext) {
    if (ext.charAt(0) !== ".") {
      throw new Error("`extname` must start with `.`");
    }
    if (ext.indexOf(".", 1) !== -1) {
      throw new Error("`extname` cannot contain multiple dots");
    }
  }
  this.path = replaceExt_1(this.path, ext);
}
function getStem() {
  return typeof this.path === "string" ? import_path.default.basename(this.path, this.extname) : void 0;
}
function setStem(stem) {
  assertNonEmpty(stem, "stem");
  assertPart(stem, "stem");
  this.path = import_path.default.join(this.dirname || "", stem + (this.extname || ""));
}
function toString5(encoding) {
  var value2 = this.contents || "";
  return isBuffer(value2) ? value2.toString(encoding) : String(value2);
}
function assertPart(part2, name2) {
  if (part2.indexOf(import_path.default.sep) !== -1) {
    throw new Error(
      "`" + name2 + "` cannot be a path: did not expect `" + import_path.default.sep + "`"
    );
  }
}
function assertNonEmpty(part2, name2) {
  if (!part2) {
    throw new Error("`" + name2 + "` cannot be empty");
  }
}
function assertPath(path2, name2) {
  if (!path2) {
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
  }
}
var vfile = core$1;
var proto$4 = core$1.prototype;
proto$4.message = message;
proto$4.info = info$1;
proto$4.fail = fail;
function message(reason, position2, origin) {
  var filePath = this.path;
  var message2 = new vfileMessage(reason, position2, origin);
  if (filePath) {
    message2.name = filePath + ":" + message2.name;
    message2.file = filePath;
  }
  message2.fatal = false;
  this.messages.push(message2);
  return message2;
}
function fail() {
  var message2 = this.message.apply(this, arguments);
  message2.fatal = true;
  throw message2;
}
function info$1() {
  var message2 = this.message.apply(this, arguments);
  message2.fatal = null;
  return message2;
}
var unified_1$1 = unified$1().freeze();
var slice$1 = [].slice;
var own$d = {}.hasOwnProperty;
var pipeline$1 = trough_1().use(pipelineParse$1).use(pipelineRun$1).use(pipelineStringify$1);
function pipelineParse$1(p2, ctx) {
  ctx.tree = p2.parse(ctx.file);
}
function pipelineRun$1(p2, ctx, next) {
  p2.run(ctx.tree, ctx.file, done);
  function done(err, tree, file) {
    if (err) {
      next(err);
    } else {
      ctx.tree = tree;
      ctx.file = file;
      next();
    }
  }
}
function pipelineStringify$1(p2, ctx) {
  var result = p2.stringify(ctx.tree, ctx.file);
  var file = ctx.file;
  if (result === void 0 || result === null)
    ;
  else if (typeof result === "string" || isBuffer(result)) {
    file.contents = result;
  } else {
    file.result = result;
  }
}
function unified$1() {
  var attachers = [];
  var transformers = trough_1();
  var namespace = {};
  var frozen = false;
  var freezeIndex = -1;
  processor.data = data3;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse5;
  processor.stringify = stringify2;
  processor.run = run2;
  processor.runSync = runSync;
  processor.process = process2;
  processor.processSync = processSync;
  return processor;
  function processor() {
    var destination = unified$1();
    var length2 = attachers.length;
    var index2 = -1;
    while (++index2 < length2) {
      destination.use.apply(null, attachers[index2]);
    }
    destination.data(extend$2(true, {}, namespace));
    return destination;
  }
  function freeze() {
    var values2;
    var plugin;
    var options2;
    var transformer;
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      values2 = attachers[freezeIndex];
      plugin = values2[0];
      options2 = values2[1];
      transformer = null;
      if (options2 === false) {
        continue;
      }
      if (options2 === true) {
        values2[1] = void 0;
      }
      transformer = plugin.apply(processor, values2.slice(1));
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Infinity;
    return processor;
  }
  function data3(key, value2) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen$1("data", frozen);
        namespace[key] = value2;
        return processor;
      }
      return own$d.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      assertUnfrozen$1("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function use(value2) {
    var settings;
    assertUnfrozen$1("use", frozen);
    if (value2 === null || value2 === void 0)
      ;
    else if (typeof value2 === "function") {
      addPlugin.apply(null, arguments);
    } else if (typeof value2 === "object") {
      if ("length" in value2) {
        addList(value2);
      } else {
        addPreset(value2);
      }
    } else {
      throw new Error("Expected usable value, not `" + value2 + "`");
    }
    if (settings) {
      namespace.settings = extend$2(namespace.settings || {}, settings);
    }
    return processor;
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = extend$2(settings || {}, result.settings);
      }
    }
    function add(value3) {
      if (typeof value3 === "function") {
        addPlugin(value3);
      } else if (typeof value3 === "object") {
        if ("length" in value3) {
          addPlugin.apply(null, value3);
        } else {
          addPreset(value3);
        }
      } else {
        throw new Error("Expected usable value, not `" + value3 + "`");
      }
    }
    function addList(plugins) {
      var length2;
      var index2;
      if (plugins === null || plugins === void 0)
        ;
      else if (typeof plugins === "object" && "length" in plugins) {
        length2 = plugins.length;
        index2 = -1;
        while (++index2 < length2) {
          add(plugins[index2]);
        }
      } else {
        throw new Error("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value3) {
      var entry = find2(plugin);
      if (entry) {
        if (isPlainObj(entry[1]) && isPlainObj(value3)) {
          value3 = extend$2(entry[1], value3);
        }
        entry[1] = value3;
      } else {
        attachers.push(slice$1.call(arguments));
      }
    }
  }
  function find2(plugin) {
    var length2 = attachers.length;
    var index2 = -1;
    var entry;
    while (++index2 < length2) {
      entry = attachers[index2];
      if (entry[0] === plugin) {
        return entry;
      }
    }
  }
  function parse5(doc) {
    var file = vfile(doc);
    var Parser4;
    freeze();
    Parser4 = processor.Parser;
    assertParser$1("parse", Parser4);
    if (newable$1(Parser4, "parse")) {
      return new Parser4(String(file), file).parse();
    }
    return Parser4(String(file), file);
  }
  function run2(node2, file, cb) {
    assertNode$1(node2);
    freeze();
    if (!cb && typeof file === "function") {
      cb = file;
      file = null;
    }
    if (!cb) {
      return new Promise(executor);
    }
    executor(null, cb);
    function executor(resolve, reject) {
      transformers.run(node2, vfile(file), done);
      function done(err, tree, file2) {
        tree = tree || node2;
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(tree);
        } else {
          cb(null, tree, file2);
        }
      }
    }
  }
  function runSync(node2, file) {
    var complete = false;
    var result;
    run2(node2, file, done);
    assertDone$1("runSync", "run", complete);
    return result;
    function done(err, tree) {
      complete = true;
      bail_1(err);
      result = tree;
    }
  }
  function stringify2(node2, doc) {
    var file = vfile(doc);
    var Compiler;
    freeze();
    Compiler = processor.Compiler;
    assertCompiler$1("stringify", Compiler);
    assertNode$1(node2);
    if (newable$1(Compiler, "compile")) {
      return new Compiler(node2, file).compile();
    }
    return Compiler(node2, file);
  }
  function process2(doc, cb) {
    freeze();
    assertParser$1("process", processor.Parser);
    assertCompiler$1("process", processor.Compiler);
    if (!cb) {
      return new Promise(executor);
    }
    executor(null, cb);
    function executor(resolve, reject) {
      var file = vfile(doc);
      pipeline$1.run(processor, { file }, done);
      function done(err) {
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(file);
        } else {
          cb(null, file);
        }
      }
    }
  }
  function processSync(doc) {
    var complete = false;
    var file;
    freeze();
    assertParser$1("processSync", processor.Parser);
    assertCompiler$1("processSync", processor.Compiler);
    file = vfile(doc);
    process2(file, done);
    assertDone$1("processSync", "process", complete);
    return file;
    function done(err) {
      complete = true;
      bail_1(err);
    }
  }
}
function newable$1(value2, name2) {
  return typeof value2 === "function" && value2.prototype && (keys$2(value2.prototype) || name2 in value2.prototype);
}
function keys$2(value2) {
  var key;
  for (key in value2) {
    return true;
  }
  return false;
}
function assertParser$1(name2, Parser4) {
  if (typeof Parser4 !== "function") {
    throw new Error("Cannot `" + name2 + "` without `Parser`");
  }
}
function assertCompiler$1(name2, Compiler) {
  if (typeof Compiler !== "function") {
    throw new Error("Cannot `" + name2 + "` without `Compiler`");
  }
}
function assertUnfrozen$1(name2, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot invoke `" + name2 + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode$1(node2) {
  if (!node2 || typeof node2.type !== "string") {
    throw new Error("Expected node, got `" + node2 + "`");
  }
}
function assertDone$1(name2, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
var immutable = extend$1;
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
function extend$1() {
  var target2 = {};
  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (hasOwnProperty2.call(source, key)) {
        target2[key] = source[key];
      }
    }
  }
  return target2;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
}
function createCommonjsModule2(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
function getCjsExportFromNamespace(n2) {
  return n2 && n2["default"] || n2;
}
var inherits_browser = createCommonjsModule2(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var inherits = createCommonjsModule2(function(module) {
  try {
    var util$1 = import_util.default;
    if (typeof util$1.inherits !== "function")
      throw "";
    module.exports = util$1.inherits;
  } catch (e) {
    module.exports = inherits_browser;
  }
});
var unherit_1 = unherit;
function unherit(Super) {
  var result;
  var key;
  var value2;
  inherits(Of, Super);
  inherits(From, Of);
  result = Of.prototype;
  for (key in result) {
    value2 = result[key];
    if (value2 && typeof value2 === "object") {
      result[key] = "concat" in value2 ? value2.concat() : immutable(value2);
    }
  }
  return Of;
  function From(parameters) {
    return Super.apply(this, parameters);
  }
  function Of() {
    if (!(this instanceof Of)) {
      return new From(arguments);
    }
    return Super.apply(this, arguments);
  }
}
var stateToggle = factory$6;
function factory$6(key, state, ctx) {
  return enter;
  function enter() {
    var context2 = ctx || this;
    var current2 = context2[key];
    context2[key] = !state;
    return exit;
    function exit() {
      context2[key] = current2;
    }
  }
}
var vfileLocation = factory$5;
function factory$5(file) {
  var contents = indices(String(file));
  return {
    toPosition: offsetToPositionFactory(contents),
    toOffset: positionToOffsetFactory(contents)
  };
}
function offsetToPositionFactory(indices2) {
  return offsetToPosition;
  function offsetToPosition(offset2) {
    var index2 = -1;
    var length2 = indices2.length;
    if (offset2 < 0) {
      return {};
    }
    while (++index2 < length2) {
      if (indices2[index2] > offset2) {
        return {
          line: index2 + 1,
          column: offset2 - (indices2[index2 - 1] || 0) + 1,
          offset: offset2
        };
      }
    }
    return {};
  }
}
function positionToOffsetFactory(indices2) {
  return positionToOffset;
  function positionToOffset(position2) {
    var line2 = position2 && position2.line;
    var column = position2 && position2.column;
    if (!isNaN(line2) && !isNaN(column) && line2 - 1 in indices2) {
      return (indices2[line2 - 2] || 0) + column - 1 || 0;
    }
    return -1;
  }
}
function indices(value2) {
  var result = [];
  var index2 = value2.indexOf("\n");
  while (index2 !== -1) {
    result.push(index2 + 1);
    index2 = value2.indexOf("\n", index2 + 1);
  }
  result.push(value2.length + 1);
  return result;
}
var _unescape = factory$4;
var backslash$7 = "\\";
function factory$4(ctx, key) {
  return unescape2;
  function unescape2(value2) {
    var previous = 0;
    var index2 = value2.indexOf(backslash$7);
    var escape2 = ctx[key];
    var queue = [];
    var character;
    while (index2 !== -1) {
      queue.push(value2.slice(previous, index2));
      previous = index2 + 1;
      character = value2.charAt(previous);
      if (!character || escape2.indexOf(character) === -1) {
        queue.push(backslash$7);
      }
      index2 = value2.indexOf(backslash$7, previous + 1);
    }
    queue.push(value2.slice(previous));
    return queue.join("");
  }
}
var AElig$2 = "\xC6";
var AMP$2 = "&";
var Aacute$2 = "\xC1";
var Acirc$2 = "\xC2";
var Agrave$2 = "\xC0";
var Aring$2 = "\xC5";
var Atilde$2 = "\xC3";
var Auml$2 = "\xC4";
var COPY$1 = "\xA9";
var Ccedil$2 = "\xC7";
var ETH$2 = "\xD0";
var Eacute$2 = "\xC9";
var Ecirc$2 = "\xCA";
var Egrave$2 = "\xC8";
var Euml$2 = "\xCB";
var GT$2 = ">";
var Iacute$2 = "\xCD";
var Icirc$2 = "\xCE";
var Igrave$2 = "\xCC";
var Iuml$2 = "\xCF";
var LT$2 = "<";
var Ntilde$2 = "\xD1";
var Oacute$2 = "\xD3";
var Ocirc$2 = "\xD4";
var Ograve$2 = "\xD2";
var Oslash$2 = "\xD8";
var Otilde$2 = "\xD5";
var Ouml$2 = "\xD6";
var QUOT$1 = '"';
var REG$1 = "\xAE";
var THORN$2 = "\xDE";
var Uacute$2 = "\xDA";
var Ucirc$2 = "\xDB";
var Ugrave$2 = "\xD9";
var Uuml$2 = "\xDC";
var Yacute$2 = "\xDD";
var aacute$2 = "\xE1";
var acirc$2 = "\xE2";
var acute$2 = "\xB4";
var aelig$2 = "\xE6";
var agrave$2 = "\xE0";
var amp$2 = "&";
var aring$2 = "\xE5";
var atilde$2 = "\xE3";
var auml$2 = "\xE4";
var brvbar$2 = "\xA6";
var ccedil$2 = "\xE7";
var cedil$2 = "\xB8";
var cent$2 = "\xA2";
var copy$2 = "\xA9";
var curren$2 = "\xA4";
var deg$2 = "\xB0";
var divide$2 = "\xF7";
var eacute$2 = "\xE9";
var ecirc$2 = "\xEA";
var egrave$2 = "\xE8";
var eth$2 = "\xF0";
var euml$2 = "\xEB";
var frac12$2 = "\xBD";
var frac14$2 = "\xBC";
var frac34$2 = "\xBE";
var gt$2 = ">";
var iacute$2 = "\xED";
var icirc$2 = "\xEE";
var iexcl$2 = "\xA1";
var igrave$2 = "\xEC";
var iquest$2 = "\xBF";
var iuml$2 = "\xEF";
var laquo$2 = "\xAB";
var lt$2 = "<";
var macr$2 = "\xAF";
var micro$2 = "\xB5";
var middot$2 = "\xB7";
var nbsp$2 = "\xA0";
var not$2 = "\xAC";
var ntilde$2 = "\xF1";
var oacute$2 = "\xF3";
var ocirc$2 = "\xF4";
var ograve$2 = "\xF2";
var ordf$2 = "\xAA";
var ordm$2 = "\xBA";
var oslash$2 = "\xF8";
var otilde$2 = "\xF5";
var ouml$2 = "\xF6";
var para$2 = "\xB6";
var plusmn$2 = "\xB1";
var pound$2 = "\xA3";
var quot$2 = '"';
var raquo$2 = "\xBB";
var reg$2 = "\xAE";
var sect$2 = "\xA7";
var shy$2 = "\xAD";
var sup1$2 = "\xB9";
var sup2$2 = "\xB2";
var sup3$2 = "\xB3";
var szlig$2 = "\xDF";
var thorn$2 = "\xFE";
var times$2 = "\xD7";
var uacute$2 = "\xFA";
var ucirc$2 = "\xFB";
var ugrave$2 = "\xF9";
var uml$2 = "\xA8";
var uuml$2 = "\xFC";
var yacute$2 = "\xFD";
var yen$2 = "\xA5";
var yuml$2 = "\xFF";
var index$5 = {
  AElig: AElig$2,
  AMP: AMP$2,
  Aacute: Aacute$2,
  Acirc: Acirc$2,
  Agrave: Agrave$2,
  Aring: Aring$2,
  Atilde: Atilde$2,
  Auml: Auml$2,
  COPY: COPY$1,
  Ccedil: Ccedil$2,
  ETH: ETH$2,
  Eacute: Eacute$2,
  Ecirc: Ecirc$2,
  Egrave: Egrave$2,
  Euml: Euml$2,
  GT: GT$2,
  Iacute: Iacute$2,
  Icirc: Icirc$2,
  Igrave: Igrave$2,
  Iuml: Iuml$2,
  LT: LT$2,
  Ntilde: Ntilde$2,
  Oacute: Oacute$2,
  Ocirc: Ocirc$2,
  Ograve: Ograve$2,
  Oslash: Oslash$2,
  Otilde: Otilde$2,
  Ouml: Ouml$2,
  QUOT: QUOT$1,
  REG: REG$1,
  THORN: THORN$2,
  Uacute: Uacute$2,
  Ucirc: Ucirc$2,
  Ugrave: Ugrave$2,
  Uuml: Uuml$2,
  Yacute: Yacute$2,
  aacute: aacute$2,
  acirc: acirc$2,
  acute: acute$2,
  aelig: aelig$2,
  agrave: agrave$2,
  amp: amp$2,
  aring: aring$2,
  atilde: atilde$2,
  auml: auml$2,
  brvbar: brvbar$2,
  ccedil: ccedil$2,
  cedil: cedil$2,
  cent: cent$2,
  copy: copy$2,
  curren: curren$2,
  deg: deg$2,
  divide: divide$2,
  eacute: eacute$2,
  ecirc: ecirc$2,
  egrave: egrave$2,
  eth: eth$2,
  euml: euml$2,
  frac12: frac12$2,
  frac14: frac14$2,
  frac34: frac34$2,
  gt: gt$2,
  iacute: iacute$2,
  icirc: icirc$2,
  iexcl: iexcl$2,
  igrave: igrave$2,
  iquest: iquest$2,
  iuml: iuml$2,
  laquo: laquo$2,
  lt: lt$2,
  macr: macr$2,
  micro: micro$2,
  middot: middot$2,
  nbsp: nbsp$2,
  not: not$2,
  ntilde: ntilde$2,
  oacute: oacute$2,
  ocirc: ocirc$2,
  ograve: ograve$2,
  ordf: ordf$2,
  ordm: ordm$2,
  oslash: oslash$2,
  otilde: otilde$2,
  ouml: ouml$2,
  para: para$2,
  plusmn: plusmn$2,
  pound: pound$2,
  quot: quot$2,
  raquo: raquo$2,
  reg: reg$2,
  sect: sect$2,
  shy: shy$2,
  sup1: sup1$2,
  sup2: sup2$2,
  sup3: sup3$2,
  szlig: szlig$2,
  thorn: thorn$2,
  times: times$2,
  uacute: uacute$2,
  ucirc: ucirc$2,
  ugrave: ugrave$2,
  uml: uml$2,
  uuml: uuml$2,
  yacute: yacute$2,
  yen: yen$2,
  yuml: yuml$2
};
var characterEntitiesLegacy = Object.freeze({
  __proto__: null,
  AElig: AElig$2,
  AMP: AMP$2,
  Aacute: Aacute$2,
  Acirc: Acirc$2,
  Agrave: Agrave$2,
  Aring: Aring$2,
  Atilde: Atilde$2,
  Auml: Auml$2,
  COPY: COPY$1,
  Ccedil: Ccedil$2,
  ETH: ETH$2,
  Eacute: Eacute$2,
  Ecirc: Ecirc$2,
  Egrave: Egrave$2,
  Euml: Euml$2,
  GT: GT$2,
  Iacute: Iacute$2,
  Icirc: Icirc$2,
  Igrave: Igrave$2,
  Iuml: Iuml$2,
  LT: LT$2,
  Ntilde: Ntilde$2,
  Oacute: Oacute$2,
  Ocirc: Ocirc$2,
  Ograve: Ograve$2,
  Oslash: Oslash$2,
  Otilde: Otilde$2,
  Ouml: Ouml$2,
  QUOT: QUOT$1,
  REG: REG$1,
  THORN: THORN$2,
  Uacute: Uacute$2,
  Ucirc: Ucirc$2,
  Ugrave: Ugrave$2,
  Uuml: Uuml$2,
  Yacute: Yacute$2,
  aacute: aacute$2,
  acirc: acirc$2,
  acute: acute$2,
  aelig: aelig$2,
  agrave: agrave$2,
  amp: amp$2,
  aring: aring$2,
  atilde: atilde$2,
  auml: auml$2,
  brvbar: brvbar$2,
  ccedil: ccedil$2,
  cedil: cedil$2,
  cent: cent$2,
  copy: copy$2,
  curren: curren$2,
  deg: deg$2,
  divide: divide$2,
  eacute: eacute$2,
  ecirc: ecirc$2,
  egrave: egrave$2,
  eth: eth$2,
  euml: euml$2,
  frac12: frac12$2,
  frac14: frac14$2,
  frac34: frac34$2,
  gt: gt$2,
  iacute: iacute$2,
  icirc: icirc$2,
  iexcl: iexcl$2,
  igrave: igrave$2,
  iquest: iquest$2,
  iuml: iuml$2,
  laquo: laquo$2,
  lt: lt$2,
  macr: macr$2,
  micro: micro$2,
  middot: middot$2,
  nbsp: nbsp$2,
  not: not$2,
  ntilde: ntilde$2,
  oacute: oacute$2,
  ocirc: ocirc$2,
  ograve: ograve$2,
  ordf: ordf$2,
  ordm: ordm$2,
  oslash: oslash$2,
  otilde: otilde$2,
  ouml: ouml$2,
  para: para$2,
  plusmn: plusmn$2,
  pound: pound$2,
  quot: quot$2,
  raquo: raquo$2,
  reg: reg$2,
  sect: sect$2,
  shy: shy$2,
  sup1: sup1$2,
  sup2: sup2$2,
  sup3: sup3$2,
  szlig: szlig$2,
  thorn: thorn$2,
  times: times$2,
  uacute: uacute$2,
  ucirc: ucirc$2,
  ugrave: ugrave$2,
  uml: uml$2,
  uuml: uuml$2,
  yacute: yacute$2,
  yen: yen$2,
  yuml: yuml$2,
  "default": index$5
});
var index$4 = {
  "0": "\uFFFD",
  "128": "\u20AC",
  "130": "\u201A",
  "131": "\u0192",
  "132": "\u201E",
  "133": "\u2026",
  "134": "\u2020",
  "135": "\u2021",
  "136": "\u02C6",
  "137": "\u2030",
  "138": "\u0160",
  "139": "\u2039",
  "140": "\u0152",
  "142": "\u017D",
  "145": "\u2018",
  "146": "\u2019",
  "147": "\u201C",
  "148": "\u201D",
  "149": "\u2022",
  "150": "\u2013",
  "151": "\u2014",
  "152": "\u02DC",
  "153": "\u2122",
  "154": "\u0161",
  "155": "\u203A",
  "156": "\u0153",
  "158": "\u017E",
  "159": "\u0178"
};
var characterReferenceInvalid = Object.freeze({
  __proto__: null,
  "default": index$4
});
var isDecimal = decimal$1;
function decimal$1(character) {
  var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code2 >= 48 && code2 <= 57;
}
var isHexadecimal = hexadecimal;
function hexadecimal(character) {
  var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code2 >= 97 && code2 <= 102 || code2 >= 65 && code2 <= 70 || code2 >= 48 && code2 <= 57;
}
var isAlphabetical = alphabetical;
function alphabetical(character) {
  var code2 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code2 >= 97 && code2 <= 122 || code2 >= 65 && code2 <= 90;
}
var isAlphanumerical = alphanumerical;
function alphanumerical(character) {
  return isAlphabetical(character) || isDecimal(character);
}
var AEli = "\xC6";
var AElig$1 = "\xC6";
var AM = "&";
var AMP$1 = "&";
var Aacut = "\xC1";
var Aacute$1 = "\xC1";
var Abreve = "\u0102";
var Acir = "\xC2";
var Acirc$1 = "\xC2";
var Acy = "\u0410";
var Afr = "\u{1D504}";
var Agrav = "\xC0";
var Agrave$1 = "\xC0";
var Alpha$1 = "\u0391";
var Amacr = "\u0100";
var And = "\u2A53";
var Aogon = "\u0104";
var Aopf = "\u{1D538}";
var ApplyFunction = "\u2061";
var Arin = "\xC5";
var Aring$1 = "\xC5";
var Ascr = "\u{1D49C}";
var Assign = "\u2254";
var Atild = "\xC3";
var Atilde$1 = "\xC3";
var Aum = "\xC4";
var Auml$1 = "\xC4";
var Backslash = "\u2216";
var Barv = "\u2AE7";
var Barwed = "\u2306";
var Bcy = "\u0411";
var Because = "\u2235";
var Bernoullis = "\u212C";
var Beta$1 = "\u0392";
var Bfr = "\u{1D505}";
var Bopf = "\u{1D539}";
var Breve = "\u02D8";
var Bscr = "\u212C";
var Bumpeq = "\u224E";
var CHcy = "\u0427";
var COP = "\xA9";
var COPY = "\xA9";
var Cacute = "\u0106";
var Cap = "\u22D2";
var CapitalDifferentialD = "\u2145";
var Cayleys = "\u212D";
var Ccaron = "\u010C";
var Ccedi = "\xC7";
var Ccedil$1 = "\xC7";
var Ccirc = "\u0108";
var Cconint = "\u2230";
var Cdot = "\u010A";
var Cedilla = "\xB8";
var CenterDot = "\xB7";
var Cfr = "\u212D";
var Chi$1 = "\u03A7";
var CircleDot = "\u2299";
var CircleMinus = "\u2296";
var CirclePlus = "\u2295";
var CircleTimes = "\u2297";
var ClockwiseContourIntegral = "\u2232";
var CloseCurlyDoubleQuote = "\u201D";
var CloseCurlyQuote = "\u2019";
var Colon = "\u2237";
var Colone = "\u2A74";
var Congruent = "\u2261";
var Conint = "\u222F";
var ContourIntegral = "\u222E";
var Copf = "\u2102";
var Coproduct = "\u2210";
var CounterClockwiseContourIntegral = "\u2233";
var Cross = "\u2A2F";
var Cscr = "\u{1D49E}";
var Cup = "\u22D3";
var CupCap = "\u224D";
var DD = "\u2145";
var DDotrahd = "\u2911";
var DJcy = "\u0402";
var DScy = "\u0405";
var DZcy = "\u040F";
var Dagger$1 = "\u2021";
var Darr = "\u21A1";
var Dashv = "\u2AE4";
var Dcaron = "\u010E";
var Dcy = "\u0414";
var Del = "\u2207";
var Delta$1 = "\u0394";
var Dfr = "\u{1D507}";
var DiacriticalAcute = "\xB4";
var DiacriticalDot = "\u02D9";
var DiacriticalDoubleAcute = "\u02DD";
var DiacriticalGrave = "`";
var DiacriticalTilde = "\u02DC";
var Diamond = "\u22C4";
var DifferentialD = "\u2146";
var Dopf = "\u{1D53B}";
var Dot = "\xA8";
var DotDot = "\u20DC";
var DotEqual = "\u2250";
var DoubleContourIntegral = "\u222F";
var DoubleDot = "\xA8";
var DoubleDownArrow = "\u21D3";
var DoubleLeftArrow = "\u21D0";
var DoubleLeftRightArrow = "\u21D4";
var DoubleLeftTee = "\u2AE4";
var DoubleLongLeftArrow = "\u27F8";
var DoubleLongLeftRightArrow = "\u27FA";
var DoubleLongRightArrow = "\u27F9";
var DoubleRightArrow = "\u21D2";
var DoubleRightTee = "\u22A8";
var DoubleUpArrow = "\u21D1";
var DoubleUpDownArrow = "\u21D5";
var DoubleVerticalBar = "\u2225";
var DownArrow = "\u2193";
var DownArrowBar = "\u2913";
var DownArrowUpArrow = "\u21F5";
var DownBreve = "\u0311";
var DownLeftRightVector = "\u2950";
var DownLeftTeeVector = "\u295E";
var DownLeftVector = "\u21BD";
var DownLeftVectorBar = "\u2956";
var DownRightTeeVector = "\u295F";
var DownRightVector = "\u21C1";
var DownRightVectorBar = "\u2957";
var DownTee = "\u22A4";
var DownTeeArrow = "\u21A7";
var Downarrow = "\u21D3";
var Dscr = "\u{1D49F}";
var Dstrok = "\u0110";
var ENG = "\u014A";
var ET = "\xD0";
var ETH$1 = "\xD0";
var Eacut = "\xC9";
var Eacute$1 = "\xC9";
var Ecaron = "\u011A";
var Ecir = "\xCA";
var Ecirc$1 = "\xCA";
var Ecy = "\u042D";
var Edot = "\u0116";
var Efr = "\u{1D508}";
var Egrav = "\xC8";
var Egrave$1 = "\xC8";
var Element2 = "\u2208";
var Emacr = "\u0112";
var EmptySmallSquare = "\u25FB";
var EmptyVerySmallSquare = "\u25AB";
var Eogon = "\u0118";
var Eopf = "\u{1D53C}";
var Epsilon$1 = "\u0395";
var Equal = "\u2A75";
var EqualTilde = "\u2242";
var Equilibrium = "\u21CC";
var Escr = "\u2130";
var Esim = "\u2A73";
var Eta$1 = "\u0397";
var Eum = "\xCB";
var Euml$1 = "\xCB";
var Exists = "\u2203";
var ExponentialE = "\u2147";
var Fcy = "\u0424";
var Ffr = "\u{1D509}";
var FilledSmallSquare = "\u25FC";
var FilledVerySmallSquare = "\u25AA";
var Fopf = "\u{1D53D}";
var ForAll = "\u2200";
var Fouriertrf = "\u2131";
var Fscr = "\u2131";
var GJcy = "\u0403";
var G = ">";
var GT$1 = ">";
var Gamma$1 = "\u0393";
var Gammad = "\u03DC";
var Gbreve = "\u011E";
var Gcedil = "\u0122";
var Gcirc = "\u011C";
var Gcy = "\u0413";
var Gdot = "\u0120";
var Gfr = "\u{1D50A}";
var Gg = "\u22D9";
var Gopf = "\u{1D53E}";
var GreaterEqual = "\u2265";
var GreaterEqualLess = "\u22DB";
var GreaterFullEqual = "\u2267";
var GreaterGreater = "\u2AA2";
var GreaterLess = "\u2277";
var GreaterSlantEqual = "\u2A7E";
var GreaterTilde = "\u2273";
var Gscr = "\u{1D4A2}";
var Gt = "\u226B";
var HARDcy = "\u042A";
var Hacek = "\u02C7";
var Hat = "^";
var Hcirc = "\u0124";
var Hfr = "\u210C";
var HilbertSpace = "\u210B";
var Hopf = "\u210D";
var HorizontalLine = "\u2500";
var Hscr = "\u210B";
var Hstrok = "\u0126";
var HumpDownHump = "\u224E";
var HumpEqual = "\u224F";
var IEcy = "\u0415";
var IJlig = "\u0132";
var IOcy = "\u0401";
var Iacut = "\xCD";
var Iacute$1 = "\xCD";
var Icir = "\xCE";
var Icirc$1 = "\xCE";
var Icy = "\u0418";
var Idot = "\u0130";
var Ifr = "\u2111";
var Igrav = "\xCC";
var Igrave$1 = "\xCC";
var Im = "\u2111";
var Imacr = "\u012A";
var ImaginaryI = "\u2148";
var Implies = "\u21D2";
var Int = "\u222C";
var Integral = "\u222B";
var Intersection = "\u22C2";
var InvisibleComma = "\u2063";
var InvisibleTimes = "\u2062";
var Iogon = "\u012E";
var Iopf = "\u{1D540}";
var Iota$1 = "\u0399";
var Iscr = "\u2110";
var Itilde = "\u0128";
var Iukcy = "\u0406";
var Ium = "\xCF";
var Iuml$1 = "\xCF";
var Jcirc = "\u0134";
var Jcy = "\u0419";
var Jfr = "\u{1D50D}";
var Jopf = "\u{1D541}";
var Jscr = "\u{1D4A5}";
var Jsercy = "\u0408";
var Jukcy = "\u0404";
var KHcy = "\u0425";
var KJcy = "\u040C";
var Kappa$1 = "\u039A";
var Kcedil = "\u0136";
var Kcy = "\u041A";
var Kfr = "\u{1D50E}";
var Kopf = "\u{1D542}";
var Kscr = "\u{1D4A6}";
var LJcy = "\u0409";
var L = "<";
var LT$1 = "<";
var Lacute = "\u0139";
var Lambda$1 = "\u039B";
var Lang = "\u27EA";
var Laplacetrf = "\u2112";
var Larr = "\u219E";
var Lcaron = "\u013D";
var Lcedil = "\u013B";
var Lcy = "\u041B";
var LeftAngleBracket = "\u27E8";
var LeftArrow = "\u2190";
var LeftArrowBar = "\u21E4";
var LeftArrowRightArrow = "\u21C6";
var LeftCeiling = "\u2308";
var LeftDoubleBracket = "\u27E6";
var LeftDownTeeVector = "\u2961";
var LeftDownVector = "\u21C3";
var LeftDownVectorBar = "\u2959";
var LeftFloor = "\u230A";
var LeftRightArrow = "\u2194";
var LeftRightVector = "\u294E";
var LeftTee = "\u22A3";
var LeftTeeArrow = "\u21A4";
var LeftTeeVector = "\u295A";
var LeftTriangle = "\u22B2";
var LeftTriangleBar = "\u29CF";
var LeftTriangleEqual = "\u22B4";
var LeftUpDownVector = "\u2951";
var LeftUpTeeVector = "\u2960";
var LeftUpVector = "\u21BF";
var LeftUpVectorBar = "\u2958";
var LeftVector = "\u21BC";
var LeftVectorBar = "\u2952";
var Leftarrow = "\u21D0";
var Leftrightarrow = "\u21D4";
var LessEqualGreater = "\u22DA";
var LessFullEqual = "\u2266";
var LessGreater = "\u2276";
var LessLess = "\u2AA1";
var LessSlantEqual = "\u2A7D";
var LessTilde = "\u2272";
var Lfr = "\u{1D50F}";
var Ll = "\u22D8";
var Lleftarrow = "\u21DA";
var Lmidot = "\u013F";
var LongLeftArrow = "\u27F5";
var LongLeftRightArrow = "\u27F7";
var LongRightArrow = "\u27F6";
var Longleftarrow = "\u27F8";
var Longleftrightarrow = "\u27FA";
var Longrightarrow = "\u27F9";
var Lopf = "\u{1D543}";
var LowerLeftArrow = "\u2199";
var LowerRightArrow = "\u2198";
var Lscr = "\u2112";
var Lsh = "\u21B0";
var Lstrok = "\u0141";
var Lt = "\u226A";
var Mcy = "\u041C";
var MediumSpace = "\u205F";
var Mellintrf = "\u2133";
var Mfr = "\u{1D510}";
var MinusPlus = "\u2213";
var Mopf = "\u{1D544}";
var Mscr = "\u2133";
var Mu$1 = "\u039C";
var NJcy = "\u040A";
var Nacute = "\u0143";
var Ncaron = "\u0147";
var Ncedil = "\u0145";
var Ncy = "\u041D";
var NegativeMediumSpace = "\u200B";
var NegativeThickSpace = "\u200B";
var NegativeThinSpace = "\u200B";
var NegativeVeryThinSpace = "\u200B";
var NestedGreaterGreater = "\u226B";
var NestedLessLess = "\u226A";
var NewLine = "\n";
var Nfr = "\u{1D511}";
var NoBreak = "\u2060";
var NonBreakingSpace = "\xA0";
var Nopf = "\u2115";
var Not = "\u2AEC";
var NotCongruent = "\u2262";
var NotCupCap = "\u226D";
var NotDoubleVerticalBar = "\u2226";
var NotElement = "\u2209";
var NotEqual = "\u2260";
var NotEqualTilde = "\u2242\u0338";
var NotExists = "\u2204";
var NotGreater = "\u226F";
var NotGreaterEqual = "\u2271";
var NotGreaterFullEqual = "\u2267\u0338";
var NotGreaterGreater = "\u226B\u0338";
var NotGreaterLess = "\u2279";
var NotGreaterSlantEqual = "\u2A7E\u0338";
var NotGreaterTilde = "\u2275";
var NotHumpDownHump = "\u224E\u0338";
var NotHumpEqual = "\u224F\u0338";
var NotLeftTriangle = "\u22EA";
var NotLeftTriangleBar = "\u29CF\u0338";
var NotLeftTriangleEqual = "\u22EC";
var NotLess = "\u226E";
var NotLessEqual = "\u2270";
var NotLessGreater = "\u2278";
var NotLessLess = "\u226A\u0338";
var NotLessSlantEqual = "\u2A7D\u0338";
var NotLessTilde = "\u2274";
var NotNestedGreaterGreater = "\u2AA2\u0338";
var NotNestedLessLess = "\u2AA1\u0338";
var NotPrecedes = "\u2280";
var NotPrecedesEqual = "\u2AAF\u0338";
var NotPrecedesSlantEqual = "\u22E0";
var NotReverseElement = "\u220C";
var NotRightTriangle = "\u22EB";
var NotRightTriangleBar = "\u29D0\u0338";
var NotRightTriangleEqual = "\u22ED";
var NotSquareSubset = "\u228F\u0338";
var NotSquareSubsetEqual = "\u22E2";
var NotSquareSuperset = "\u2290\u0338";
var NotSquareSupersetEqual = "\u22E3";
var NotSubset = "\u2282\u20D2";
var NotSubsetEqual = "\u2288";
var NotSucceeds = "\u2281";
var NotSucceedsEqual = "\u2AB0\u0338";
var NotSucceedsSlantEqual = "\u22E1";
var NotSucceedsTilde = "\u227F\u0338";
var NotSuperset = "\u2283\u20D2";
var NotSupersetEqual = "\u2289";
var NotTilde = "\u2241";
var NotTildeEqual = "\u2244";
var NotTildeFullEqual = "\u2247";
var NotTildeTilde = "\u2249";
var NotVerticalBar = "\u2224";
var Nscr = "\u{1D4A9}";
var Ntild = "\xD1";
var Ntilde$1 = "\xD1";
var Nu$1 = "\u039D";
var OElig$1 = "\u0152";
var Oacut = "\xD3";
var Oacute$1 = "\xD3";
var Ocir = "\xD4";
var Ocirc$1 = "\xD4";
var Ocy = "\u041E";
var Odblac = "\u0150";
var Ofr = "\u{1D512}";
var Ograv = "\xD2";
var Ograve$1 = "\xD2";
var Omacr = "\u014C";
var Omega$1 = "\u03A9";
var Omicron$1 = "\u039F";
var Oopf = "\u{1D546}";
var OpenCurlyDoubleQuote = "\u201C";
var OpenCurlyQuote = "\u2018";
var Or = "\u2A54";
var Oscr = "\u{1D4AA}";
var Oslas = "\xD8";
var Oslash$1 = "\xD8";
var Otild = "\xD5";
var Otilde$1 = "\xD5";
var Otimes = "\u2A37";
var Oum = "\xD6";
var Ouml$1 = "\xD6";
var OverBar = "\u203E";
var OverBrace = "\u23DE";
var OverBracket = "\u23B4";
var OverParenthesis = "\u23DC";
var PartialD = "\u2202";
var Pcy = "\u041F";
var Pfr = "\u{1D513}";
var Phi$1 = "\u03A6";
var Pi$1 = "\u03A0";
var PlusMinus = "\xB1";
var Poincareplane = "\u210C";
var Popf = "\u2119";
var Pr = "\u2ABB";
var Precedes = "\u227A";
var PrecedesEqual = "\u2AAF";
var PrecedesSlantEqual = "\u227C";
var PrecedesTilde = "\u227E";
var Prime$1 = "\u2033";
var Product = "\u220F";
var Proportion = "\u2237";
var Proportional = "\u221D";
var Pscr = "\u{1D4AB}";
var Psi$1 = "\u03A8";
var QUO = '"';
var QUOT = '"';
var Qfr = "\u{1D514}";
var Qopf = "\u211A";
var Qscr = "\u{1D4AC}";
var RBarr = "\u2910";
var RE = "\xAE";
var REG = "\xAE";
var Racute = "\u0154";
var Rang = "\u27EB";
var Rarr = "\u21A0";
var Rarrtl = "\u2916";
var Rcaron = "\u0158";
var Rcedil = "\u0156";
var Rcy = "\u0420";
var Re = "\u211C";
var ReverseElement = "\u220B";
var ReverseEquilibrium = "\u21CB";
var ReverseUpEquilibrium = "\u296F";
var Rfr = "\u211C";
var Rho$1 = "\u03A1";
var RightAngleBracket = "\u27E9";
var RightArrow = "\u2192";
var RightArrowBar = "\u21E5";
var RightArrowLeftArrow = "\u21C4";
var RightCeiling = "\u2309";
var RightDoubleBracket = "\u27E7";
var RightDownTeeVector = "\u295D";
var RightDownVector = "\u21C2";
var RightDownVectorBar = "\u2955";
var RightFloor = "\u230B";
var RightTee = "\u22A2";
var RightTeeArrow = "\u21A6";
var RightTeeVector = "\u295B";
var RightTriangle = "\u22B3";
var RightTriangleBar = "\u29D0";
var RightTriangleEqual = "\u22B5";
var RightUpDownVector = "\u294F";
var RightUpTeeVector = "\u295C";
var RightUpVector = "\u21BE";
var RightUpVectorBar = "\u2954";
var RightVector = "\u21C0";
var RightVectorBar = "\u2953";
var Rightarrow = "\u21D2";
var Ropf = "\u211D";
var RoundImplies = "\u2970";
var Rrightarrow = "\u21DB";
var Rscr = "\u211B";
var Rsh = "\u21B1";
var RuleDelayed = "\u29F4";
var SHCHcy = "\u0429";
var SHcy = "\u0428";
var SOFTcy = "\u042C";
var Sacute = "\u015A";
var Sc = "\u2ABC";
var Scaron$1 = "\u0160";
var Scedil = "\u015E";
var Scirc = "\u015C";
var Scy = "\u0421";
var Sfr = "\u{1D516}";
var ShortDownArrow = "\u2193";
var ShortLeftArrow = "\u2190";
var ShortRightArrow = "\u2192";
var ShortUpArrow = "\u2191";
var Sigma$1 = "\u03A3";
var SmallCircle = "\u2218";
var Sopf = "\u{1D54A}";
var Sqrt = "\u221A";
var Square = "\u25A1";
var SquareIntersection = "\u2293";
var SquareSubset = "\u228F";
var SquareSubsetEqual = "\u2291";
var SquareSuperset = "\u2290";
var SquareSupersetEqual = "\u2292";
var SquareUnion = "\u2294";
var Sscr = "\u{1D4AE}";
var Star = "\u22C6";
var Sub = "\u22D0";
var Subset = "\u22D0";
var SubsetEqual = "\u2286";
var Succeeds = "\u227B";
var SucceedsEqual = "\u2AB0";
var SucceedsSlantEqual = "\u227D";
var SucceedsTilde = "\u227F";
var SuchThat = "\u220B";
var Sum = "\u2211";
var Sup = "\u22D1";
var Superset = "\u2283";
var SupersetEqual = "\u2287";
var Supset = "\u22D1";
var THOR = "\xDE";
var THORN$1 = "\xDE";
var TRADE = "\u2122";
var TSHcy = "\u040B";
var TScy = "\u0426";
var Tab = "	";
var Tau$1 = "\u03A4";
var Tcaron = "\u0164";
var Tcedil = "\u0162";
var Tcy = "\u0422";
var Tfr = "\u{1D517}";
var Therefore = "\u2234";
var Theta$1 = "\u0398";
var ThickSpace = "\u205F\u200A";
var ThinSpace = "\u2009";
var Tilde = "\u223C";
var TildeEqual = "\u2243";
var TildeFullEqual = "\u2245";
var TildeTilde = "\u2248";
var Topf = "\u{1D54B}";
var TripleDot = "\u20DB";
var Tscr = "\u{1D4AF}";
var Tstrok = "\u0166";
var Uacut = "\xDA";
var Uacute$1 = "\xDA";
var Uarr = "\u219F";
var Uarrocir = "\u2949";
var Ubrcy = "\u040E";
var Ubreve = "\u016C";
var Ucir = "\xDB";
var Ucirc$1 = "\xDB";
var Ucy = "\u0423";
var Udblac = "\u0170";
var Ufr = "\u{1D518}";
var Ugrav = "\xD9";
var Ugrave$1 = "\xD9";
var Umacr = "\u016A";
var UnderBar = "_";
var UnderBrace = "\u23DF";
var UnderBracket = "\u23B5";
var UnderParenthesis = "\u23DD";
var Union = "\u22C3";
var UnionPlus = "\u228E";
var Uogon = "\u0172";
var Uopf = "\u{1D54C}";
var UpArrow = "\u2191";
var UpArrowBar = "\u2912";
var UpArrowDownArrow = "\u21C5";
var UpDownArrow = "\u2195";
var UpEquilibrium = "\u296E";
var UpTee = "\u22A5";
var UpTeeArrow = "\u21A5";
var Uparrow = "\u21D1";
var Updownarrow = "\u21D5";
var UpperLeftArrow = "\u2196";
var UpperRightArrow = "\u2197";
var Upsi = "\u03D2";
var Upsilon$1 = "\u03A5";
var Uring = "\u016E";
var Uscr = "\u{1D4B0}";
var Utilde = "\u0168";
var Uum = "\xDC";
var Uuml$1 = "\xDC";
var VDash = "\u22AB";
var Vbar = "\u2AEB";
var Vcy = "\u0412";
var Vdash = "\u22A9";
var Vdashl = "\u2AE6";
var Vee = "\u22C1";
var Verbar = "\u2016";
var Vert = "\u2016";
var VerticalBar = "\u2223";
var VerticalLine = "|";
var VerticalSeparator = "\u2758";
var VerticalTilde = "\u2240";
var VeryThinSpace = "\u200A";
var Vfr = "\u{1D519}";
var Vopf = "\u{1D54D}";
var Vscr = "\u{1D4B1}";
var Vvdash = "\u22AA";
var Wcirc = "\u0174";
var Wedge = "\u22C0";
var Wfr = "\u{1D51A}";
var Wopf = "\u{1D54E}";
var Wscr = "\u{1D4B2}";
var Xfr = "\u{1D51B}";
var Xi$1 = "\u039E";
var Xopf = "\u{1D54F}";
var Xscr = "\u{1D4B3}";
var YAcy = "\u042F";
var YIcy = "\u0407";
var YUcy = "\u042E";
var Yacut = "\xDD";
var Yacute$1 = "\xDD";
var Ycirc = "\u0176";
var Ycy = "\u042B";
var Yfr = "\u{1D51C}";
var Yopf = "\u{1D550}";
var Yscr = "\u{1D4B4}";
var Yuml$1 = "\u0178";
var ZHcy = "\u0416";
var Zacute = "\u0179";
var Zcaron = "\u017D";
var Zcy = "\u0417";
var Zdot = "\u017B";
var ZeroWidthSpace = "\u200B";
var Zeta$1 = "\u0396";
var Zfr = "\u2128";
var Zopf = "\u2124";
var Zscr = "\u{1D4B5}";
var aacut = "\xE1";
var aacute$1 = "\xE1";
var abreve = "\u0103";
var ac = "\u223E";
var acE = "\u223E\u0333";
var acd = "\u223F";
var acir = "\xE2";
var acirc$1 = "\xE2";
var acut = "\xB4";
var acute$1 = "\xB4";
var acy = "\u0430";
var aeli = "\xE6";
var aelig$1 = "\xE6";
var af = "\u2061";
var afr = "\u{1D51E}";
var agrav = "\xE0";
var agrave$1 = "\xE0";
var alefsym$1 = "\u2135";
var aleph = "\u2135";
var alpha$1 = "\u03B1";
var amacr = "\u0101";
var amalg = "\u2A3F";
var am = "&";
var amp$1 = "&";
var and$1 = "\u2227";
var andand = "\u2A55";
var andd = "\u2A5C";
var andslope = "\u2A58";
var andv = "\u2A5A";
var ang$1 = "\u2220";
var ange = "\u29A4";
var angle = "\u2220";
var angmsd = "\u2221";
var angmsdaa = "\u29A8";
var angmsdab = "\u29A9";
var angmsdac = "\u29AA";
var angmsdad = "\u29AB";
var angmsdae = "\u29AC";
var angmsdaf = "\u29AD";
var angmsdag = "\u29AE";
var angmsdah = "\u29AF";
var angrt = "\u221F";
var angrtvb = "\u22BE";
var angrtvbd = "\u299D";
var angsph = "\u2222";
var angst = "\xC5";
var angzarr = "\u237C";
var aogon = "\u0105";
var aopf = "\u{1D552}";
var ap = "\u2248";
var apE = "\u2A70";
var apacir = "\u2A6F";
var ape = "\u224A";
var apid = "\u224B";
var apos = "'";
var approx = "\u2248";
var approxeq = "\u224A";
var arin = "\xE5";
var aring$1 = "\xE5";
var ascr = "\u{1D4B6}";
var ast = "*";
var asymp$1 = "\u2248";
var asympeq = "\u224D";
var atild = "\xE3";
var atilde$1 = "\xE3";
var aum = "\xE4";
var auml$1 = "\xE4";
var awconint = "\u2233";
var awint = "\u2A11";
var bNot = "\u2AED";
var backcong = "\u224C";
var backepsilon = "\u03F6";
var backprime = "\u2035";
var backsim = "\u223D";
var backsimeq = "\u22CD";
var barvee = "\u22BD";
var barwed = "\u2305";
var barwedge = "\u2305";
var bbrk = "\u23B5";
var bbrktbrk = "\u23B6";
var bcong = "\u224C";
var bcy = "\u0431";
var bdquo$1 = "\u201E";
var becaus = "\u2235";
var because = "\u2235";
var bemptyv = "\u29B0";
var bepsi = "\u03F6";
var bernou = "\u212C";
var beta$1 = "\u03B2";
var beth = "\u2136";
var between = "\u226C";
var bfr = "\u{1D51F}";
var bigcap = "\u22C2";
var bigcirc = "\u25EF";
var bigcup = "\u22C3";
var bigodot = "\u2A00";
var bigoplus = "\u2A01";
var bigotimes = "\u2A02";
var bigsqcup = "\u2A06";
var bigstar = "\u2605";
var bigtriangledown = "\u25BD";
var bigtriangleup = "\u25B3";
var biguplus = "\u2A04";
var bigvee = "\u22C1";
var bigwedge = "\u22C0";
var bkarow = "\u290D";
var blacklozenge = "\u29EB";
var blacksquare = "\u25AA";
var blacktriangle = "\u25B4";
var blacktriangledown = "\u25BE";
var blacktriangleleft = "\u25C2";
var blacktriangleright = "\u25B8";
var blank = "\u2423";
var blk12 = "\u2592";
var blk14 = "\u2591";
var blk34 = "\u2593";
var block = "\u2588";
var bne = "=\u20E5";
var bnequiv = "\u2261\u20E5";
var bnot = "\u2310";
var bopf = "\u{1D553}";
var bot = "\u22A5";
var bottom = "\u22A5";
var bowtie = "\u22C8";
var boxDL = "\u2557";
var boxDR = "\u2554";
var boxDl = "\u2556";
var boxDr = "\u2553";
var boxH = "\u2550";
var boxHD = "\u2566";
var boxHU = "\u2569";
var boxHd = "\u2564";
var boxHu = "\u2567";
var boxUL = "\u255D";
var boxUR = "\u255A";
var boxUl = "\u255C";
var boxUr = "\u2559";
var boxV = "\u2551";
var boxVH = "\u256C";
var boxVL = "\u2563";
var boxVR = "\u2560";
var boxVh = "\u256B";
var boxVl = "\u2562";
var boxVr = "\u255F";
var boxbox = "\u29C9";
var boxdL = "\u2555";
var boxdR = "\u2552";
var boxdl = "\u2510";
var boxdr = "\u250C";
var boxh = "\u2500";
var boxhD = "\u2565";
var boxhU = "\u2568";
var boxhd = "\u252C";
var boxhu = "\u2534";
var boxminus = "\u229F";
var boxplus = "\u229E";
var boxtimes = "\u22A0";
var boxuL = "\u255B";
var boxuR = "\u2558";
var boxul = "\u2518";
var boxur = "\u2514";
var boxv = "\u2502";
var boxvH = "\u256A";
var boxvL = "\u2561";
var boxvR = "\u255E";
var boxvh = "\u253C";
var boxvl = "\u2524";
var boxvr = "\u251C";
var bprime = "\u2035";
var breve = "\u02D8";
var brvba = "\xA6";
var brvbar$1 = "\xA6";
var bscr = "\u{1D4B7}";
var bsemi = "\u204F";
var bsim = "\u223D";
var bsime = "\u22CD";
var bsol = "\\";
var bsolb = "\u29C5";
var bsolhsub = "\u27C8";
var bull$1 = "\u2022";
var bullet = "\u2022";
var bump = "\u224E";
var bumpE = "\u2AAE";
var bumpe = "\u224F";
var bumpeq = "\u224F";
var cacute = "\u0107";
var cap$2 = "\u2229";
var capand = "\u2A44";
var capbrcup = "\u2A49";
var capcap = "\u2A4B";
var capcup = "\u2A47";
var capdot = "\u2A40";
var caps = "\u2229\uFE00";
var caret = "\u2041";
var caron = "\u02C7";
var ccaps = "\u2A4D";
var ccaron = "\u010D";
var ccedi = "\xE7";
var ccedil$1 = "\xE7";
var ccirc = "\u0109";
var ccups = "\u2A4C";
var ccupssm = "\u2A50";
var cdot = "\u010B";
var cedi = "\xB8";
var cedil$1 = "\xB8";
var cemptyv = "\u29B2";
var cen = "\xA2";
var cent$1 = "\xA2";
var centerdot = "\xB7";
var cfr = "\u{1D520}";
var chcy = "\u0447";
var check = "\u2713";
var checkmark = "\u2713";
var chi$1 = "\u03C7";
var cir = "\u25CB";
var cirE = "\u29C3";
var circ$1 = "\u02C6";
var circeq = "\u2257";
var circlearrowleft = "\u21BA";
var circlearrowright = "\u21BB";
var circledR = "\xAE";
var circledS = "\u24C8";
var circledast = "\u229B";
var circledcirc = "\u229A";
var circleddash = "\u229D";
var cire = "\u2257";
var cirfnint = "\u2A10";
var cirmid = "\u2AEF";
var cirscir = "\u29C2";
var clubs$1 = "\u2663";
var clubsuit = "\u2663";
var colon$3 = ":";
var colone = "\u2254";
var coloneq = "\u2254";
var comma$2 = ",";
var commat = "@";
var comp = "\u2201";
var compfn = "\u2218";
var complement = "\u2201";
var complexes = "\u2102";
var cong$1 = "\u2245";
var congdot = "\u2A6D";
var conint = "\u222E";
var copf = "\u{1D554}";
var coprod = "\u2210";
var cop = "\xA9";
var copy$1 = "\xA9";
var copysr = "\u2117";
var crarr$1 = "\u21B5";
var cross = "\u2717";
var cscr = "\u{1D4B8}";
var csub = "\u2ACF";
var csube = "\u2AD1";
var csup = "\u2AD0";
var csupe = "\u2AD2";
var ctdot = "\u22EF";
var cudarrl = "\u2938";
var cudarrr = "\u2935";
var cuepr = "\u22DE";
var cuesc = "\u22DF";
var cularr = "\u21B6";
var cularrp = "\u293D";
var cup$1 = "\u222A";
var cupbrcap = "\u2A48";
var cupcap = "\u2A46";
var cupcup = "\u2A4A";
var cupdot = "\u228D";
var cupor = "\u2A45";
var cups = "\u222A\uFE00";
var curarr = "\u21B7";
var curarrm = "\u293C";
var curlyeqprec = "\u22DE";
var curlyeqsucc = "\u22DF";
var curlyvee = "\u22CE";
var curlywedge = "\u22CF";
var curre = "\xA4";
var curren$1 = "\xA4";
var curvearrowleft = "\u21B6";
var curvearrowright = "\u21B7";
var cuvee = "\u22CE";
var cuwed = "\u22CF";
var cwconint = "\u2232";
var cwint = "\u2231";
var cylcty = "\u232D";
var dArr$1 = "\u21D3";
var dHar = "\u2965";
var dagger$1 = "\u2020";
var daleth = "\u2138";
var darr$1 = "\u2193";
var dash$8 = "\u2010";
var dashv = "\u22A3";
var dbkarow = "\u290F";
var dblac = "\u02DD";
var dcaron = "\u010F";
var dcy = "\u0434";
var dd$1 = "\u2146";
var ddagger = "\u2021";
var ddarr = "\u21CA";
var ddotseq = "\u2A77";
var de = "\xB0";
var deg$1 = "\xB0";
var delta$1 = "\u03B4";
var demptyv = "\u29B1";
var dfisht = "\u297F";
var dfr = "\u{1D521}";
var dharl = "\u21C3";
var dharr = "\u21C2";
var diam = "\u22C4";
var diamond = "\u22C4";
var diamondsuit = "\u2666";
var diams$1 = "\u2666";
var die = "\xA8";
var digamma = "\u03DD";
var disin = "\u22F2";
var div = "\xF7";
var divid = "\xF7";
var divide$1 = "\xF7";
var divideontimes = "\u22C7";
var divonx = "\u22C7";
var djcy = "\u0452";
var dlcorn = "\u231E";
var dlcrop = "\u230D";
var dollar = "$";
var dopf = "\u{1D555}";
var dot$4 = "\u02D9";
var doteq = "\u2250";
var doteqdot = "\u2251";
var dotminus = "\u2238";
var dotplus = "\u2214";
var dotsquare = "\u22A1";
var doublebarwedge = "\u2306";
var downarrow = "\u2193";
var downdownarrows = "\u21CA";
var downharpoonleft = "\u21C3";
var downharpoonright = "\u21C2";
var drbkarow = "\u2910";
var drcorn = "\u231F";
var drcrop = "\u230C";
var dscr = "\u{1D4B9}";
var dscy = "\u0455";
var dsol = "\u29F6";
var dstrok = "\u0111";
var dtdot = "\u22F1";
var dtri = "\u25BF";
var dtrif = "\u25BE";
var duarr = "\u21F5";
var duhar = "\u296F";
var dwangle = "\u29A6";
var dzcy = "\u045F";
var dzigrarr = "\u27FF";
var eDDot = "\u2A77";
var eDot = "\u2251";
var eacut = "\xE9";
var eacute$1 = "\xE9";
var easter = "\u2A6E";
var ecaron = "\u011B";
var ecir = "\xEA";
var ecirc$1 = "\xEA";
var ecolon = "\u2255";
var ecy = "\u044D";
var edot = "\u0117";
var ee = "\u2147";
var efDot = "\u2252";
var efr = "\u{1D522}";
var eg = "\u2A9A";
var egrav = "\xE8";
var egrave$1 = "\xE8";
var egs = "\u2A96";
var egsdot = "\u2A98";
var el = "\u2A99";
var elinters = "\u23E7";
var ell = "\u2113";
var els = "\u2A95";
var elsdot = "\u2A97";
var emacr = "\u0113";
var empty$3 = "\u2205";
var emptyset = "\u2205";
var emptyv = "\u2205";
var emsp13 = "\u2004";
var emsp14 = "\u2005";
var emsp$1 = "\u2003";
var eng = "\u014B";
var ensp$1 = "\u2002";
var eogon = "\u0119";
var eopf = "\u{1D556}";
var epar = "\u22D5";
var eparsl = "\u29E3";
var eplus = "\u2A71";
var epsi = "\u03B5";
var epsilon$1 = "\u03B5";
var epsiv = "\u03F5";
var eqcirc = "\u2256";
var eqcolon = "\u2255";
var eqsim = "\u2242";
var eqslantgtr = "\u2A96";
var eqslantless = "\u2A95";
var equals = "=";
var equest = "\u225F";
var equiv$1 = "\u2261";
var equivDD = "\u2A78";
var eqvparsl = "\u29E5";
var erDot = "\u2253";
var erarr = "\u2971";
var escr = "\u212F";
var esdot = "\u2250";
var esim = "\u2242";
var eta$1 = "\u03B7";
var et = "\xF0";
var eth$1 = "\xF0";
var eum = "\xEB";
var euml$1 = "\xEB";
var euro$1 = "\u20AC";
var excl = "!";
var exist$1 = "\u2203";
var expectation = "\u2130";
var exponentiale = "\u2147";
var fallingdotseq = "\u2252";
var fcy = "\u0444";
var female = "\u2640";
var ffilig = "\uFB03";
var fflig = "\uFB00";
var ffllig = "\uFB04";
var ffr = "\u{1D523}";
var filig = "\uFB01";
var fjlig = "fj";
var flat = "\u266D";
var fllig = "\uFB02";
var fltns = "\u25B1";
var fnof$1 = "\u0192";
var fopf = "\u{1D557}";
var forall$1 = "\u2200";
var fork = "\u22D4";
var forkv = "\u2AD9";
var fpartint = "\u2A0D";
var frac1 = "\xBC";
var frac12$1 = "\xBD";
var frac13 = "\u2153";
var frac14$1 = "\xBC";
var frac15 = "\u2155";
var frac16 = "\u2159";
var frac18 = "\u215B";
var frac23 = "\u2154";
var frac25 = "\u2156";
var frac3 = "\xBE";
var frac34$1 = "\xBE";
var frac35 = "\u2157";
var frac38 = "\u215C";
var frac45 = "\u2158";
var frac56 = "\u215A";
var frac58 = "\u215D";
var frac78 = "\u215E";
var frasl$1 = "\u2044";
var frown = "\u2322";
var fscr = "\u{1D4BB}";
var gE = "\u2267";
var gEl = "\u2A8C";
var gacute = "\u01F5";
var gamma$1 = "\u03B3";
var gammad = "\u03DD";
var gap = "\u2A86";
var gbreve = "\u011F";
var gcirc = "\u011D";
var gcy = "\u0433";
var gdot = "\u0121";
var ge$1 = "\u2265";
var gel = "\u22DB";
var geq = "\u2265";
var geqq = "\u2267";
var geqslant = "\u2A7E";
var ges = "\u2A7E";
var gescc = "\u2AA9";
var gesdot = "\u2A80";
var gesdoto = "\u2A82";
var gesdotol = "\u2A84";
var gesl = "\u22DB\uFE00";
var gesles = "\u2A94";
var gfr = "\u{1D524}";
var gg = "\u226B";
var ggg = "\u22D9";
var gimel = "\u2137";
var gjcy = "\u0453";
var gl = "\u2277";
var glE = "\u2A92";
var gla = "\u2AA5";
var glj = "\u2AA4";
var gnE = "\u2269";
var gnap = "\u2A8A";
var gnapprox = "\u2A8A";
var gne = "\u2A88";
var gneq = "\u2A88";
var gneqq = "\u2269";
var gnsim = "\u22E7";
var gopf = "\u{1D558}";
var grave = "`";
var gscr = "\u210A";
var gsim = "\u2273";
var gsime = "\u2A8E";
var gsiml = "\u2A90";
var g = ">";
var gt$1 = ">";
var gtcc = "\u2AA7";
var gtcir = "\u2A7A";
var gtdot = "\u22D7";
var gtlPar = "\u2995";
var gtquest = "\u2A7C";
var gtrapprox = "\u2A86";
var gtrarr = "\u2978";
var gtrdot = "\u22D7";
var gtreqless = "\u22DB";
var gtreqqless = "\u2A8C";
var gtrless = "\u2277";
var gtrsim = "\u2273";
var gvertneqq = "\u2269\uFE00";
var gvnE = "\u2269\uFE00";
var hArr$1 = "\u21D4";
var hairsp = "\u200A";
var half = "\xBD";
var hamilt = "\u210B";
var hardcy = "\u044A";
var harr$1 = "\u2194";
var harrcir = "\u2948";
var harrw = "\u21AD";
var hbar = "\u210F";
var hcirc = "\u0125";
var hearts$1 = "\u2665";
var heartsuit = "\u2665";
var hellip$1 = "\u2026";
var hercon = "\u22B9";
var hfr = "\u{1D525}";
var hksearow = "\u2925";
var hkswarow = "\u2926";
var hoarr = "\u21FF";
var homtht = "\u223B";
var hookleftarrow = "\u21A9";
var hookrightarrow = "\u21AA";
var hopf = "\u{1D559}";
var horbar = "\u2015";
var hscr = "\u{1D4BD}";
var hslash = "\u210F";
var hstrok = "\u0127";
var hybull = "\u2043";
var hyphen = "\u2010";
var iacut = "\xED";
var iacute$1 = "\xED";
var ic = "\u2063";
var icir = "\xEE";
var icirc$1 = "\xEE";
var icy = "\u0438";
var iecy = "\u0435";
var iexc = "\xA1";
var iexcl$1 = "\xA1";
var iff = "\u21D4";
var ifr = "\u{1D526}";
var igrav = "\xEC";
var igrave$1 = "\xEC";
var ii = "\u2148";
var iiiint = "\u2A0C";
var iiint = "\u222D";
var iinfin = "\u29DC";
var iiota = "\u2129";
var ijlig = "\u0133";
var imacr = "\u012B";
var image$3 = "\u2111";
var imagline = "\u2110";
var imagpart = "\u2111";
var imath = "\u0131";
var imof = "\u22B7";
var imped = "\u01B5";
var incare = "\u2105";
var infin$1 = "\u221E";
var infintie = "\u29DD";
var inodot = "\u0131";
var int$1 = "\u222B";
var intcal = "\u22BA";
var integers = "\u2124";
var intercal = "\u22BA";
var intlarhk = "\u2A17";
var intprod = "\u2A3C";
var iocy = "\u0451";
var iogon = "\u012F";
var iopf = "\u{1D55A}";
var iota$1 = "\u03B9";
var iprod = "\u2A3C";
var iques = "\xBF";
var iquest$1 = "\xBF";
var iscr = "\u{1D4BE}";
var isin$1 = "\u2208";
var isinE = "\u22F9";
var isindot = "\u22F5";
var isins = "\u22F4";
var isinsv = "\u22F3";
var isinv = "\u2208";
var it = "\u2062";
var itilde = "\u0129";
var iukcy = "\u0456";
var ium = "\xEF";
var iuml$1 = "\xEF";
var jcirc = "\u0135";
var jcy = "\u0439";
var jfr = "\u{1D527}";
var jmath = "\u0237";
var jopf = "\u{1D55B}";
var jscr = "\u{1D4BF}";
var jsercy = "\u0458";
var jukcy = "\u0454";
var kappa$1 = "\u03BA";
var kappav = "\u03F0";
var kcedil = "\u0137";
var kcy = "\u043A";
var kfr = "\u{1D528}";
var kgreen = "\u0138";
var khcy = "\u0445";
var kjcy = "\u045C";
var kopf = "\u{1D55C}";
var kscr = "\u{1D4C0}";
var lAarr = "\u21DA";
var lArr$1 = "\u21D0";
var lAtail = "\u291B";
var lBarr = "\u290E";
var lE = "\u2266";
var lEg = "\u2A8B";
var lHar = "\u2962";
var lacute = "\u013A";
var laemptyv = "\u29B4";
var lagran = "\u2112";
var lambda$1 = "\u03BB";
var lang$1 = "\u27E8";
var langd = "\u2991";
var langle = "\u27E8";
var lap = "\u2A85";
var laqu = "\xAB";
var laquo$1 = "\xAB";
var larr$1 = "\u2190";
var larrb = "\u21E4";
var larrbfs = "\u291F";
var larrfs = "\u291D";
var larrhk = "\u21A9";
var larrlp = "\u21AB";
var larrpl = "\u2939";
var larrsim = "\u2973";
var larrtl = "\u21A2";
var lat = "\u2AAB";
var latail = "\u2919";
var late = "\u2AAD";
var lates = "\u2AAD\uFE00";
var lbarr = "\u290C";
var lbbrk = "\u2772";
var lbrace = "{";
var lbrack = "[";
var lbrke = "\u298B";
var lbrksld = "\u298F";
var lbrkslu = "\u298D";
var lcaron = "\u013E";
var lcedil = "\u013C";
var lceil$1 = "\u2308";
var lcub = "{";
var lcy = "\u043B";
var ldca = "\u2936";
var ldquo$1 = "\u201C";
var ldquor = "\u201E";
var ldrdhar = "\u2967";
var ldrushar = "\u294B";
var ldsh = "\u21B2";
var le$1 = "\u2264";
var leftarrow = "\u2190";
var leftarrowtail = "\u21A2";
var leftharpoondown = "\u21BD";
var leftharpoonup = "\u21BC";
var leftleftarrows = "\u21C7";
var leftrightarrow = "\u2194";
var leftrightarrows = "\u21C6";
var leftrightharpoons = "\u21CB";
var leftrightsquigarrow = "\u21AD";
var leftthreetimes = "\u22CB";
var leg = "\u22DA";
var leq = "\u2264";
var leqq = "\u2266";
var leqslant = "\u2A7D";
var les = "\u2A7D";
var lescc = "\u2AA8";
var lesdot = "\u2A7F";
var lesdoto = "\u2A81";
var lesdotor = "\u2A83";
var lesg = "\u22DA\uFE00";
var lesges = "\u2A93";
var lessapprox = "\u2A85";
var lessdot = "\u22D6";
var lesseqgtr = "\u22DA";
var lesseqqgtr = "\u2A8B";
var lessgtr = "\u2276";
var lesssim = "\u2272";
var lfisht = "\u297C";
var lfloor$1 = "\u230A";
var lfr = "\u{1D529}";
var lg = "\u2276";
var lgE = "\u2A91";
var lhard = "\u21BD";
var lharu = "\u21BC";
var lharul = "\u296A";
var lhblk = "\u2584";
var ljcy = "\u0459";
var ll = "\u226A";
var llarr = "\u21C7";
var llcorner = "\u231E";
var llhard = "\u296B";
var lltri = "\u25FA";
var lmidot = "\u0140";
var lmoust = "\u23B0";
var lmoustache = "\u23B0";
var lnE = "\u2268";
var lnap = "\u2A89";
var lnapprox = "\u2A89";
var lne = "\u2A87";
var lneq = "\u2A87";
var lneqq = "\u2268";
var lnsim = "\u22E6";
var loang = "\u27EC";
var loarr = "\u21FD";
var lobrk = "\u27E6";
var longleftarrow = "\u27F5";
var longleftrightarrow = "\u27F7";
var longmapsto = "\u27FC";
var longrightarrow = "\u27F6";
var looparrowleft = "\u21AB";
var looparrowright = "\u21AC";
var lopar = "\u2985";
var lopf = "\u{1D55D}";
var loplus = "\u2A2D";
var lotimes = "\u2A34";
var lowast$1 = "\u2217";
var lowbar = "_";
var loz$1 = "\u25CA";
var lozenge = "\u25CA";
var lozf = "\u29EB";
var lpar = "(";
var lparlt = "\u2993";
var lrarr = "\u21C6";
var lrcorner = "\u231F";
var lrhar = "\u21CB";
var lrhard = "\u296D";
var lrm$1 = "\u200E";
var lrtri = "\u22BF";
var lsaquo$1 = "\u2039";
var lscr = "\u{1D4C1}";
var lsh = "\u21B0";
var lsim = "\u2272";
var lsime = "\u2A8D";
var lsimg = "\u2A8F";
var lsqb = "[";
var lsquo$1 = "\u2018";
var lsquor = "\u201A";
var lstrok = "\u0142";
var l = "<";
var lt$1 = "<";
var ltcc = "\u2AA6";
var ltcir = "\u2A79";
var ltdot = "\u22D6";
var lthree = "\u22CB";
var ltimes = "\u22C9";
var ltlarr = "\u2976";
var ltquest = "\u2A7B";
var ltrPar = "\u2996";
var ltri = "\u25C3";
var ltrie = "\u22B4";
var ltrif = "\u25C2";
var lurdshar = "\u294A";
var luruhar = "\u2966";
var lvertneqq = "\u2268\uFE00";
var lvnE = "\u2268\uFE00";
var mDDot = "\u223A";
var mac = "\xAF";
var macr$1 = "\xAF";
var male = "\u2642";
var malt = "\u2720";
var maltese = "\u2720";
var map$1 = "\u21A6";
var mapsto = "\u21A6";
var mapstodown = "\u21A7";
var mapstoleft = "\u21A4";
var mapstoup = "\u21A5";
var marker = "\u25AE";
var mcomma = "\u2A29";
var mcy = "\u043C";
var mdash$1 = "\u2014";
var measuredangle = "\u2221";
var mfr = "\u{1D52A}";
var mho = "\u2127";
var micr = "\xB5";
var micro$1 = "\xB5";
var mid = "\u2223";
var midast = "*";
var midcir = "\u2AF0";
var middo = "\xB7";
var middot$1 = "\xB7";
var minus$1 = "\u2212";
var minusb = "\u229F";
var minusd = "\u2238";
var minusdu = "\u2A2A";
var mlcp = "\u2ADB";
var mldr = "\u2026";
var mnplus = "\u2213";
var models = "\u22A7";
var mopf = "\u{1D55E}";
var mp = "\u2213";
var mscr = "\u{1D4C2}";
var mstpos = "\u223E";
var mu$1 = "\u03BC";
var multimap = "\u22B8";
var mumap = "\u22B8";
var nGg = "\u22D9\u0338";
var nGt = "\u226B\u20D2";
var nGtv = "\u226B\u0338";
var nLeftarrow = "\u21CD";
var nLeftrightarrow = "\u21CE";
var nLl = "\u22D8\u0338";
var nLt = "\u226A\u20D2";
var nLtv = "\u226A\u0338";
var nRightarrow = "\u21CF";
var nVDash = "\u22AF";
var nVdash = "\u22AE";
var nabla$1 = "\u2207";
var nacute = "\u0144";
var nang = "\u2220\u20D2";
var nap = "\u2249";
var napE = "\u2A70\u0338";
var napid = "\u224B\u0338";
var napos = "\u0149";
var napprox = "\u2249";
var natur = "\u266E";
var natural = "\u266E";
var naturals = "\u2115";
var nbs = "\xA0";
var nbsp$1 = "\xA0";
var nbump = "\u224E\u0338";
var nbumpe = "\u224F\u0338";
var ncap = "\u2A43";
var ncaron = "\u0148";
var ncedil = "\u0146";
var ncong = "\u2247";
var ncongdot = "\u2A6D\u0338";
var ncup = "\u2A42";
var ncy = "\u043D";
var ndash$1 = "\u2013";
var ne$1 = "\u2260";
var neArr = "\u21D7";
var nearhk = "\u2924";
var nearr = "\u2197";
var nearrow = "\u2197";
var nedot = "\u2250\u0338";
var nequiv = "\u2262";
var nesear = "\u2928";
var nesim = "\u2242\u0338";
var nexist = "\u2204";
var nexists = "\u2204";
var nfr = "\u{1D52B}";
var ngE = "\u2267\u0338";
var nge = "\u2271";
var ngeq = "\u2271";
var ngeqq = "\u2267\u0338";
var ngeqslant = "\u2A7E\u0338";
var nges = "\u2A7E\u0338";
var ngsim = "\u2275";
var ngt = "\u226F";
var ngtr = "\u226F";
var nhArr = "\u21CE";
var nharr = "\u21AE";
var nhpar = "\u2AF2";
var ni$1 = "\u220B";
var nis = "\u22FC";
var nisd = "\u22FA";
var niv = "\u220B";
var njcy = "\u045A";
var nlArr = "\u21CD";
var nlE = "\u2266\u0338";
var nlarr = "\u219A";
var nldr = "\u2025";
var nle = "\u2270";
var nleftarrow = "\u219A";
var nleftrightarrow = "\u21AE";
var nleq = "\u2270";
var nleqq = "\u2266\u0338";
var nleqslant = "\u2A7D\u0338";
var nles = "\u2A7D\u0338";
var nless = "\u226E";
var nlsim = "\u2274";
var nlt = "\u226E";
var nltri = "\u22EA";
var nltrie = "\u22EC";
var nmid = "\u2224";
var nopf = "\u{1D55F}";
var no = "\xAC";
var not$1 = "\xAC";
var notin$1 = "\u2209";
var notinE = "\u22F9\u0338";
var notindot = "\u22F5\u0338";
var notinva = "\u2209";
var notinvb = "\u22F7";
var notinvc = "\u22F6";
var notni = "\u220C";
var notniva = "\u220C";
var notnivb = "\u22FE";
var notnivc = "\u22FD";
var npar = "\u2226";
var nparallel = "\u2226";
var nparsl = "\u2AFD\u20E5";
var npart = "\u2202\u0338";
var npolint = "\u2A14";
var npr = "\u2280";
var nprcue = "\u22E0";
var npre = "\u2AAF\u0338";
var nprec = "\u2280";
var npreceq = "\u2AAF\u0338";
var nrArr = "\u21CF";
var nrarr = "\u219B";
var nrarrc = "\u2933\u0338";
var nrarrw = "\u219D\u0338";
var nrightarrow = "\u219B";
var nrtri = "\u22EB";
var nrtrie = "\u22ED";
var nsc = "\u2281";
var nsccue = "\u22E1";
var nsce = "\u2AB0\u0338";
var nscr = "\u{1D4C3}";
var nshortmid = "\u2224";
var nshortparallel = "\u2226";
var nsim = "\u2241";
var nsime = "\u2244";
var nsimeq = "\u2244";
var nsmid = "\u2224";
var nspar = "\u2226";
var nsqsube = "\u22E2";
var nsqsupe = "\u22E3";
var nsub$1 = "\u2284";
var nsubE = "\u2AC5\u0338";
var nsube = "\u2288";
var nsubset = "\u2282\u20D2";
var nsubseteq = "\u2288";
var nsubseteqq = "\u2AC5\u0338";
var nsucc = "\u2281";
var nsucceq = "\u2AB0\u0338";
var nsup = "\u2285";
var nsupE = "\u2AC6\u0338";
var nsupe = "\u2289";
var nsupset = "\u2283\u20D2";
var nsupseteq = "\u2289";
var nsupseteqq = "\u2AC6\u0338";
var ntgl = "\u2279";
var ntild = "\xF1";
var ntilde$1 = "\xF1";
var ntlg = "\u2278";
var ntriangleleft = "\u22EA";
var ntrianglelefteq = "\u22EC";
var ntriangleright = "\u22EB";
var ntrianglerighteq = "\u22ED";
var nu$1 = "\u03BD";
var num = "#";
var numero = "\u2116";
var numsp = "\u2007";
var nvDash = "\u22AD";
var nvHarr = "\u2904";
var nvap = "\u224D\u20D2";
var nvdash = "\u22AC";
var nvge = "\u2265\u20D2";
var nvgt = ">\u20D2";
var nvinfin = "\u29DE";
var nvlArr = "\u2902";
var nvle = "\u2264\u20D2";
var nvlt = "<\u20D2";
var nvltrie = "\u22B4\u20D2";
var nvrArr = "\u2903";
var nvrtrie = "\u22B5\u20D2";
var nvsim = "\u223C\u20D2";
var nwArr = "\u21D6";
var nwarhk = "\u2923";
var nwarr = "\u2196";
var nwarrow = "\u2196";
var nwnear = "\u2927";
var oS = "\u24C8";
var oacut = "\xF3";
var oacute$1 = "\xF3";
var oast = "\u229B";
var ocir = "\xF4";
var ocirc$1 = "\xF4";
var ocy = "\u043E";
var odash = "\u229D";
var odblac = "\u0151";
var odiv = "\u2A38";
var odot = "\u2299";
var odsold = "\u29BC";
var oelig$1 = "\u0153";
var ofcir = "\u29BF";
var ofr = "\u{1D52C}";
var ogon = "\u02DB";
var ograv = "\xF2";
var ograve$1 = "\xF2";
var ogt = "\u29C1";
var ohbar = "\u29B5";
var ohm = "\u03A9";
var oint = "\u222E";
var olarr = "\u21BA";
var olcir = "\u29BE";
var olcross = "\u29BB";
var oline$1 = "\u203E";
var olt = "\u29C0";
var omacr = "\u014D";
var omega$1 = "\u03C9";
var omicron$1 = "\u03BF";
var omid = "\u29B6";
var ominus = "\u2296";
var oopf = "\u{1D560}";
var opar = "\u29B7";
var operp = "\u29B9";
var oplus$1 = "\u2295";
var or$1 = "\u2228";
var orarr = "\u21BB";
var ord = "\xBA";
var order = "\u2134";
var orderof = "\u2134";
var ordf$1 = "\xAA";
var ordm$1 = "\xBA";
var origof = "\u22B6";
var oror = "\u2A56";
var orslope = "\u2A57";
var orv = "\u2A5B";
var oscr = "\u2134";
var oslas = "\xF8";
var oslash$1 = "\xF8";
var osol = "\u2298";
var otild = "\xF5";
var otilde$1 = "\xF5";
var otimes$1 = "\u2297";
var otimesas = "\u2A36";
var oum = "\xF6";
var ouml$1 = "\xF6";
var ovbar = "\u233D";
var par = "\xB6";
var para$1 = "\xB6";
var parallel = "\u2225";
var parsim = "\u2AF3";
var parsl = "\u2AFD";
var part$1 = "\u2202";
var pcy = "\u043F";
var percnt = "%";
var period = ".";
var permil$1 = "\u2030";
var perp$1 = "\u22A5";
var pertenk = "\u2031";
var pfr = "\u{1D52D}";
var phi$1 = "\u03C6";
var phiv = "\u03D5";
var phmmat = "\u2133";
var phone = "\u260E";
var pi$1 = "\u03C0";
var pitchfork = "\u22D4";
var piv$1 = "\u03D6";
var planck = "\u210F";
var planckh = "\u210E";
var plankv = "\u210F";
var plus = "+";
var plusacir = "\u2A23";
var plusb = "\u229E";
var pluscir = "\u2A22";
var plusdo = "\u2214";
var plusdu = "\u2A25";
var pluse = "\u2A72";
var plusm = "\xB1";
var plusmn$1 = "\xB1";
var plussim = "\u2A26";
var plustwo = "\u2A27";
var pm = "\xB1";
var pointint = "\u2A15";
var popf = "\u{1D561}";
var poun = "\xA3";
var pound$1 = "\xA3";
var pr = "\u227A";
var prE = "\u2AB3";
var prap = "\u2AB7";
var prcue = "\u227C";
var pre = "\u2AAF";
var prec = "\u227A";
var precapprox = "\u2AB7";
var preccurlyeq = "\u227C";
var preceq = "\u2AAF";
var precnapprox = "\u2AB9";
var precneqq = "\u2AB5";
var precnsim = "\u22E8";
var precsim = "\u227E";
var prime$1 = "\u2032";
var primes = "\u2119";
var prnE = "\u2AB5";
var prnap = "\u2AB9";
var prnsim = "\u22E8";
var prod$1 = "\u220F";
var profalar = "\u232E";
var profline = "\u2312";
var profsurf = "\u2313";
var prop$1 = "\u221D";
var propto = "\u221D";
var prsim = "\u227E";
var prurel = "\u22B0";
var pscr = "\u{1D4C5}";
var psi$1 = "\u03C8";
var puncsp = "\u2008";
var qfr = "\u{1D52E}";
var qint = "\u2A0C";
var qopf = "\u{1D562}";
var qprime = "\u2057";
var qscr = "\u{1D4C6}";
var quaternions = "\u210D";
var quatint = "\u2A16";
var quest = "?";
var questeq = "\u225F";
var quo = '"';
var quot$1 = '"';
var rAarr = "\u21DB";
var rArr$1 = "\u21D2";
var rAtail = "\u291C";
var rBarr = "\u290F";
var rHar = "\u2964";
var race = "\u223D\u0331";
var racute = "\u0155";
var radic$1 = "\u221A";
var raemptyv = "\u29B3";
var rang$1 = "\u27E9";
var rangd = "\u2992";
var range = "\u29A5";
var rangle = "\u27E9";
var raqu = "\xBB";
var raquo$1 = "\xBB";
var rarr$1 = "\u2192";
var rarrap = "\u2975";
var rarrb = "\u21E5";
var rarrbfs = "\u2920";
var rarrc = "\u2933";
var rarrfs = "\u291E";
var rarrhk = "\u21AA";
var rarrlp = "\u21AC";
var rarrpl = "\u2945";
var rarrsim = "\u2974";
var rarrtl = "\u21A3";
var rarrw = "\u219D";
var ratail = "\u291A";
var ratio = "\u2236";
var rationals = "\u211A";
var rbarr = "\u290D";
var rbbrk = "\u2773";
var rbrace = "}";
var rbrack = "]";
var rbrke = "\u298C";
var rbrksld = "\u298E";
var rbrkslu = "\u2990";
var rcaron = "\u0159";
var rcedil = "\u0157";
var rceil$1 = "\u2309";
var rcub = "}";
var rcy = "\u0440";
var rdca = "\u2937";
var rdldhar = "\u2969";
var rdquo$1 = "\u201D";
var rdquor = "\u201D";
var rdsh = "\u21B3";
var real$1 = "\u211C";
var realine = "\u211B";
var realpart = "\u211C";
var reals = "\u211D";
var rect = "\u25AD";
var re$3 = "\xAE";
var reg$1 = "\xAE";
var rfisht = "\u297D";
var rfloor$1 = "\u230B";
var rfr = "\u{1D52F}";
var rhard = "\u21C1";
var rharu = "\u21C0";
var rharul = "\u296C";
var rho$1 = "\u03C1";
var rhov = "\u03F1";
var rightarrow = "\u2192";
var rightarrowtail = "\u21A3";
var rightharpoondown = "\u21C1";
var rightharpoonup = "\u21C0";
var rightleftarrows = "\u21C4";
var rightleftharpoons = "\u21CC";
var rightrightarrows = "\u21C9";
var rightsquigarrow = "\u219D";
var rightthreetimes = "\u22CC";
var ring = "\u02DA";
var risingdotseq = "\u2253";
var rlarr = "\u21C4";
var rlhar = "\u21CC";
var rlm$1 = "\u200F";
var rmoust = "\u23B1";
var rmoustache = "\u23B1";
var rnmid = "\u2AEE";
var roang = "\u27ED";
var roarr = "\u21FE";
var robrk = "\u27E7";
var ropar = "\u2986";
var ropf = "\u{1D563}";
var roplus = "\u2A2E";
var rotimes = "\u2A35";
var rpar = ")";
var rpargt = "\u2994";
var rppolint = "\u2A12";
var rrarr = "\u21C9";
var rsaquo$1 = "\u203A";
var rscr = "\u{1D4C7}";
var rsh = "\u21B1";
var rsqb = "]";
var rsquo$1 = "\u2019";
var rsquor = "\u2019";
var rthree = "\u22CC";
var rtimes = "\u22CA";
var rtri = "\u25B9";
var rtrie = "\u22B5";
var rtrif = "\u25B8";
var rtriltri = "\u29CE";
var ruluhar = "\u2968";
var rx = "\u211E";
var sacute = "\u015B";
var sbquo$1 = "\u201A";
var sc = "\u227B";
var scE = "\u2AB4";
var scap = "\u2AB8";
var scaron$1 = "\u0161";
var sccue = "\u227D";
var sce = "\u2AB0";
var scedil = "\u015F";
var scirc = "\u015D";
var scnE = "\u2AB6";
var scnap = "\u2ABA";
var scnsim = "\u22E9";
var scpolint = "\u2A13";
var scsim = "\u227F";
var scy = "\u0441";
var sdot$1 = "\u22C5";
var sdotb = "\u22A1";
var sdote = "\u2A66";
var seArr = "\u21D8";
var searhk = "\u2925";
var searr = "\u2198";
var searrow = "\u2198";
var sec = "\xA7";
var sect$1 = "\xA7";
var semi = ";";
var seswar = "\u2929";
var setminus = "\u2216";
var setmn = "\u2216";
var sext = "\u2736";
var sfr = "\u{1D530}";
var sfrown = "\u2322";
var sharp = "\u266F";
var shchcy = "\u0449";
var shcy = "\u0448";
var shortmid = "\u2223";
var shortparallel = "\u2225";
var sh = "\xAD";
var shy$1 = "\xAD";
var sigma$1 = "\u03C3";
var sigmaf$1 = "\u03C2";
var sigmav = "\u03C2";
var sim$1 = "\u223C";
var simdot = "\u2A6A";
var sime = "\u2243";
var simeq = "\u2243";
var simg = "\u2A9E";
var simgE = "\u2AA0";
var siml = "\u2A9D";
var simlE = "\u2A9F";
var simne = "\u2246";
var simplus = "\u2A24";
var simrarr = "\u2972";
var slarr = "\u2190";
var smallsetminus = "\u2216";
var smashp = "\u2A33";
var smeparsl = "\u29E4";
var smid = "\u2223";
var smile = "\u2323";
var smt = "\u2AAA";
var smte = "\u2AAC";
var smtes = "\u2AAC\uFE00";
var softcy = "\u044C";
var sol = "/";
var solb = "\u29C4";
var solbar = "\u233F";
var sopf = "\u{1D564}";
var spades$1 = "\u2660";
var spadesuit = "\u2660";
var spar = "\u2225";
var sqcap = "\u2293";
var sqcaps = "\u2293\uFE00";
var sqcup = "\u2294";
var sqcups = "\u2294\uFE00";
var sqsub = "\u228F";
var sqsube = "\u2291";
var sqsubset = "\u228F";
var sqsubseteq = "\u2291";
var sqsup = "\u2290";
var sqsupe = "\u2292";
var sqsupset = "\u2290";
var sqsupseteq = "\u2292";
var squ = "\u25A1";
var square = "\u25A1";
var squarf = "\u25AA";
var squf = "\u25AA";
var srarr = "\u2192";
var sscr = "\u{1D4C8}";
var ssetmn = "\u2216";
var ssmile = "\u2323";
var sstarf = "\u22C6";
var star = "\u2606";
var starf = "\u2605";
var straightepsilon = "\u03F5";
var straightphi = "\u03D5";
var strns = "\xAF";
var sub$1 = "\u2282";
var subE = "\u2AC5";
var subdot = "\u2ABD";
var sube$1 = "\u2286";
var subedot = "\u2AC3";
var submult = "\u2AC1";
var subnE = "\u2ACB";
var subne = "\u228A";
var subplus = "\u2ABF";
var subrarr = "\u2979";
var subset = "\u2282";
var subseteq = "\u2286";
var subseteqq = "\u2AC5";
var subsetneq = "\u228A";
var subsetneqq = "\u2ACB";
var subsim = "\u2AC7";
var subsub = "\u2AD5";
var subsup = "\u2AD3";
var succ = "\u227B";
var succapprox = "\u2AB8";
var succcurlyeq = "\u227D";
var succeq = "\u2AB0";
var succnapprox = "\u2ABA";
var succneqq = "\u2AB6";
var succnsim = "\u22E9";
var succsim = "\u227F";
var sum$1 = "\u2211";
var sung = "\u266A";
var sup$1 = "\u2283";
var sup1$1 = "\xB9";
var sup2$1 = "\xB2";
var sup3$1 = "\xB3";
var supE = "\u2AC6";
var supdot = "\u2ABE";
var supdsub = "\u2AD8";
var supe$1 = "\u2287";
var supedot = "\u2AC4";
var suphsol = "\u27C9";
var suphsub = "\u2AD7";
var suplarr = "\u297B";
var supmult = "\u2AC2";
var supnE = "\u2ACC";
var supne = "\u228B";
var supplus = "\u2AC0";
var supset = "\u2283";
var supseteq = "\u2287";
var supseteqq = "\u2AC6";
var supsetneq = "\u228B";
var supsetneqq = "\u2ACC";
var supsim = "\u2AC8";
var supsub = "\u2AD4";
var supsup = "\u2AD6";
var swArr = "\u21D9";
var swarhk = "\u2926";
var swarr = "\u2199";
var swarrow = "\u2199";
var swnwar = "\u292A";
var szli = "\xDF";
var szlig$1 = "\xDF";
var target = "\u2316";
var tau$1 = "\u03C4";
var tbrk = "\u23B4";
var tcaron = "\u0165";
var tcedil = "\u0163";
var tcy = "\u0442";
var tdot = "\u20DB";
var telrec = "\u2315";
var tfr = "\u{1D531}";
var there4$1 = "\u2234";
var therefore = "\u2234";
var theta$1 = "\u03B8";
var thetasym$1 = "\u03D1";
var thetav = "\u03D1";
var thickapprox = "\u2248";
var thicksim = "\u223C";
var thinsp$1 = "\u2009";
var thkap = "\u2248";
var thksim = "\u223C";
var thor = "\xFE";
var thorn$1 = "\xFE";
var tilde$4 = "\u02DC";
var time = "\xD7";
var times$1 = "\xD7";
var timesb = "\u22A0";
var timesbar = "\u2A31";
var timesd = "\u2A30";
var tint = "\u222D";
var toea = "\u2928";
var top = "\u22A4";
var topbot = "\u2336";
var topcir = "\u2AF1";
var topf = "\u{1D565}";
var topfork = "\u2ADA";
var tosa = "\u2929";
var tprime = "\u2034";
var trade$1 = "\u2122";
var triangle = "\u25B5";
var triangledown = "\u25BF";
var triangleleft = "\u25C3";
var trianglelefteq = "\u22B4";
var triangleq = "\u225C";
var triangleright = "\u25B9";
var trianglerighteq = "\u22B5";
var tridot = "\u25EC";
var trie = "\u225C";
var triminus = "\u2A3A";
var triplus = "\u2A39";
var trisb = "\u29CD";
var tritime = "\u2A3B";
var trpezium = "\u23E2";
var tscr = "\u{1D4C9}";
var tscy = "\u0446";
var tshcy = "\u045B";
var tstrok = "\u0167";
var twixt = "\u226C";
var twoheadleftarrow = "\u219E";
var twoheadrightarrow = "\u21A0";
var uArr$1 = "\u21D1";
var uHar = "\u2963";
var uacut = "\xFA";
var uacute$1 = "\xFA";
var uarr$1 = "\u2191";
var ubrcy = "\u045E";
var ubreve = "\u016D";
var ucir = "\xFB";
var ucirc$1 = "\xFB";
var ucy = "\u0443";
var udarr = "\u21C5";
var udblac = "\u0171";
var udhar = "\u296E";
var ufisht = "\u297E";
var ufr = "\u{1D532}";
var ugrav = "\xF9";
var ugrave$1 = "\xF9";
var uharl = "\u21BF";
var uharr = "\u21BE";
var uhblk = "\u2580";
var ulcorn = "\u231C";
var ulcorner = "\u231C";
var ulcrop = "\u230F";
var ultri = "\u25F8";
var umacr = "\u016B";
var um = "\xA8";
var uml$1 = "\xA8";
var uogon = "\u0173";
var uopf = "\u{1D566}";
var uparrow = "\u2191";
var updownarrow = "\u2195";
var upharpoonleft = "\u21BF";
var upharpoonright = "\u21BE";
var uplus = "\u228E";
var upsi = "\u03C5";
var upsih$1 = "\u03D2";
var upsilon$1 = "\u03C5";
var upuparrows = "\u21C8";
var urcorn = "\u231D";
var urcorner = "\u231D";
var urcrop = "\u230E";
var uring = "\u016F";
var urtri = "\u25F9";
var uscr = "\u{1D4CA}";
var utdot = "\u22F0";
var utilde = "\u0169";
var utri = "\u25B5";
var utrif = "\u25B4";
var uuarr = "\u21C8";
var uum = "\xFC";
var uuml$1 = "\xFC";
var uwangle = "\u29A7";
var vArr = "\u21D5";
var vBar = "\u2AE8";
var vBarv = "\u2AE9";
var vDash = "\u22A8";
var vangrt = "\u299C";
var varepsilon = "\u03F5";
var varkappa = "\u03F0";
var varnothing = "\u2205";
var varphi = "\u03D5";
var varpi = "\u03D6";
var varpropto = "\u221D";
var varr = "\u2195";
var varrho = "\u03F1";
var varsigma = "\u03C2";
var varsubsetneq = "\u228A\uFE00";
var varsubsetneqq = "\u2ACB\uFE00";
var varsupsetneq = "\u228B\uFE00";
var varsupsetneqq = "\u2ACC\uFE00";
var vartheta = "\u03D1";
var vartriangleleft = "\u22B2";
var vartriangleright = "\u22B3";
var vcy = "\u0432";
var vdash = "\u22A2";
var vee = "\u2228";
var veebar = "\u22BB";
var veeeq = "\u225A";
var vellip = "\u22EE";
var verbar = "|";
var vert = "|";
var vfr = "\u{1D533}";
var vltri = "\u22B2";
var vnsub = "\u2282\u20D2";
var vnsup = "\u2283\u20D2";
var vopf = "\u{1D567}";
var vprop = "\u221D";
var vrtri = "\u22B3";
var vscr = "\u{1D4CB}";
var vsubnE = "\u2ACB\uFE00";
var vsubne = "\u228A\uFE00";
var vsupnE = "\u2ACC\uFE00";
var vsupne = "\u228B\uFE00";
var vzigzag = "\u299A";
var wcirc = "\u0175";
var wedbar = "\u2A5F";
var wedge = "\u2227";
var wedgeq = "\u2259";
var weierp$1 = "\u2118";
var wfr = "\u{1D534}";
var wopf = "\u{1D568}";
var wp = "\u2118";
var wr = "\u2240";
var wreath = "\u2240";
var wscr = "\u{1D4CC}";
var xcap = "\u22C2";
var xcirc = "\u25EF";
var xcup = "\u22C3";
var xdtri = "\u25BD";
var xfr = "\u{1D535}";
var xhArr = "\u27FA";
var xharr = "\u27F7";
var xi$1 = "\u03BE";
var xlArr = "\u27F8";
var xlarr = "\u27F5";
var xmap = "\u27FC";
var xnis = "\u22FB";
var xodot = "\u2A00";
var xopf = "\u{1D569}";
var xoplus = "\u2A01";
var xotime = "\u2A02";
var xrArr = "\u27F9";
var xrarr = "\u27F6";
var xscr = "\u{1D4CD}";
var xsqcup = "\u2A06";
var xuplus = "\u2A04";
var xutri = "\u25B3";
var xvee = "\u22C1";
var xwedge = "\u22C0";
var yacut = "\xFD";
var yacute$1 = "\xFD";
var yacy = "\u044F";
var ycirc = "\u0177";
var ycy = "\u044B";
var ye = "\xA5";
var yen$1 = "\xA5";
var yfr = "\u{1D536}";
var yicy = "\u0457";
var yopf = "\u{1D56A}";
var yscr = "\u{1D4CE}";
var yucy = "\u044E";
var yum = "\xFF";
var yuml$1 = "\xFF";
var zacute = "\u017A";
var zcaron = "\u017E";
var zcy = "\u0437";
var zdot = "\u017C";
var zeetrf = "\u2128";
var zeta$1 = "\u03B6";
var zfr = "\u{1D537}";
var zhcy = "\u0436";
var zigrarr = "\u21DD";
var zopf = "\u{1D56B}";
var zscr = "\u{1D4CF}";
var zwj$1 = "\u200D";
var zwnj$1 = "\u200C";
var index$3 = {
  AEli,
  AElig: AElig$1,
  AM,
  AMP: AMP$1,
  Aacut,
  Aacute: Aacute$1,
  Abreve,
  Acir,
  Acirc: Acirc$1,
  Acy,
  Afr,
  Agrav,
  Agrave: Agrave$1,
  Alpha: Alpha$1,
  Amacr,
  And,
  Aogon,
  Aopf,
  ApplyFunction,
  Arin,
  Aring: Aring$1,
  Ascr,
  Assign,
  Atild,
  Atilde: Atilde$1,
  Aum,
  Auml: Auml$1,
  Backslash,
  Barv,
  Barwed,
  Bcy,
  Because,
  Bernoullis,
  Beta: Beta$1,
  Bfr,
  Bopf,
  Breve,
  Bscr,
  Bumpeq,
  CHcy,
  COP,
  COPY,
  Cacute,
  Cap,
  CapitalDifferentialD,
  Cayleys,
  Ccaron,
  Ccedi,
  Ccedil: Ccedil$1,
  Ccirc,
  Cconint,
  Cdot,
  Cedilla,
  CenterDot,
  Cfr,
  Chi: Chi$1,
  CircleDot,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  Colon,
  Colone,
  Congruent,
  Conint,
  ContourIntegral,
  Copf,
  Coproduct,
  CounterClockwiseContourIntegral,
  Cross,
  Cscr,
  Cup,
  CupCap,
  DD,
  DDotrahd,
  DJcy,
  DScy,
  DZcy,
  Dagger: Dagger$1,
  Darr,
  Dashv,
  Dcaron,
  Dcy,
  Del,
  Delta: Delta$1,
  Dfr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  Diamond,
  DifferentialD,
  Dopf,
  Dot,
  DotDot,
  DotEqual,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrow,
  DownArrowBar,
  DownArrowUpArrow,
  DownBreve,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVector,
  DownLeftVectorBar,
  DownRightTeeVector,
  DownRightVector,
  DownRightVectorBar,
  DownTee,
  DownTeeArrow,
  Downarrow,
  Dscr,
  Dstrok,
  ENG,
  ET,
  ETH: ETH$1,
  Eacut,
  Eacute: Eacute$1,
  Ecaron,
  Ecir,
  Ecirc: Ecirc$1,
  Ecy,
  Edot,
  Efr,
  Egrav,
  Egrave: Egrave$1,
  Element: Element2,
  Emacr,
  EmptySmallSquare,
  EmptyVerySmallSquare,
  Eogon,
  Eopf,
  Epsilon: Epsilon$1,
  Equal,
  EqualTilde,
  Equilibrium,
  Escr,
  Esim,
  Eta: Eta$1,
  Eum,
  Euml: Euml$1,
  Exists,
  ExponentialE,
  Fcy,
  Ffr,
  FilledSmallSquare,
  FilledVerySmallSquare,
  Fopf,
  ForAll,
  Fouriertrf,
  Fscr,
  GJcy,
  G,
  GT: GT$1,
  Gamma: Gamma$1,
  Gammad,
  Gbreve,
  Gcedil,
  Gcirc,
  Gcy,
  Gdot,
  Gfr,
  Gg,
  Gopf,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  Gt,
  HARDcy,
  Hacek,
  Hat,
  Hcirc,
  Hfr,
  HilbertSpace,
  Hopf,
  HorizontalLine,
  Hscr,
  Hstrok,
  HumpDownHump,
  HumpEqual,
  IEcy,
  IJlig,
  IOcy,
  Iacut,
  Iacute: Iacute$1,
  Icir,
  Icirc: Icirc$1,
  Icy,
  Idot,
  Ifr,
  Igrav,
  Igrave: Igrave$1,
  Im,
  Imacr,
  ImaginaryI,
  Implies,
  Int,
  Integral,
  Intersection,
  InvisibleComma,
  InvisibleTimes,
  Iogon,
  Iopf,
  Iota: Iota$1,
  Iscr,
  Itilde,
  Iukcy,
  Ium,
  Iuml: Iuml$1,
  Jcirc,
  Jcy,
  Jfr,
  Jopf,
  Jscr,
  Jsercy,
  Jukcy,
  KHcy,
  KJcy,
  Kappa: Kappa$1,
  Kcedil,
  Kcy,
  Kfr,
  Kopf,
  Kscr,
  LJcy,
  L,
  LT: LT$1,
  Lacute,
  Lambda: Lambda$1,
  Lang,
  Laplacetrf,
  Larr,
  Lcaron,
  Lcedil,
  Lcy,
  LeftAngleBracket,
  LeftArrow,
  LeftArrowBar,
  LeftArrowRightArrow,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVector,
  LeftDownVectorBar,
  LeftFloor,
  LeftRightArrow,
  LeftRightVector,
  LeftTee,
  LeftTeeArrow,
  LeftTeeVector,
  LeftTriangle,
  LeftTriangleBar,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVector,
  LeftUpVectorBar,
  LeftVector,
  LeftVectorBar,
  Leftarrow,
  Leftrightarrow,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  LessLess,
  LessSlantEqual,
  LessTilde,
  Lfr,
  Ll,
  Lleftarrow,
  Lmidot,
  LongLeftArrow,
  LongLeftRightArrow,
  LongRightArrow,
  Longleftarrow,
  Longleftrightarrow,
  Longrightarrow,
  Lopf,
  LowerLeftArrow,
  LowerRightArrow,
  Lscr,
  Lsh,
  Lstrok,
  Lt,
  "Map": "\u2905",
  Mcy,
  MediumSpace,
  Mellintrf,
  Mfr,
  MinusPlus,
  Mopf,
  Mscr,
  Mu: Mu$1,
  NJcy,
  Nacute,
  Ncaron,
  Ncedil,
  Ncy,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  Nfr,
  NoBreak,
  NonBreakingSpace,
  Nopf,
  Not,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  NotLeftTriangle,
  NotLeftTriangleBar,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangle,
  NotRightTriangleBar,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  Nscr,
  Ntild,
  Ntilde: Ntilde$1,
  Nu: Nu$1,
  OElig: OElig$1,
  Oacut,
  Oacute: Oacute$1,
  Ocir,
  Ocirc: Ocirc$1,
  Ocy,
  Odblac,
  Ofr,
  Ograv,
  Ograve: Ograve$1,
  Omacr,
  Omega: Omega$1,
  Omicron: Omicron$1,
  Oopf,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  Or,
  Oscr,
  Oslas,
  Oslash: Oslash$1,
  Otild,
  Otilde: Otilde$1,
  Otimes,
  Oum,
  Ouml: Ouml$1,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  PartialD,
  Pcy,
  Pfr,
  Phi: Phi$1,
  Pi: Pi$1,
  PlusMinus,
  Poincareplane,
  Popf,
  Pr,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  Prime: Prime$1,
  Product,
  Proportion,
  Proportional,
  Pscr,
  Psi: Psi$1,
  QUO,
  QUOT,
  Qfr,
  Qopf,
  Qscr,
  RBarr,
  RE,
  REG,
  Racute,
  Rang,
  Rarr,
  Rarrtl,
  Rcaron,
  Rcedil,
  Rcy,
  Re,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  Rfr,
  Rho: Rho$1,
  RightAngleBracket,
  RightArrow,
  RightArrowBar,
  RightArrowLeftArrow,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVector,
  RightDownVectorBar,
  RightFloor,
  RightTee,
  RightTeeArrow,
  RightTeeVector,
  RightTriangle,
  RightTriangleBar,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVector,
  RightUpVectorBar,
  RightVector,
  RightVectorBar,
  Rightarrow,
  Ropf,
  RoundImplies,
  Rrightarrow,
  Rscr,
  Rsh,
  RuleDelayed,
  SHCHcy,
  SHcy,
  SOFTcy,
  Sacute,
  Sc,
  Scaron: Scaron$1,
  Scedil,
  Scirc,
  Scy,
  Sfr,
  ShortDownArrow,
  ShortLeftArrow,
  ShortRightArrow,
  ShortUpArrow,
  Sigma: Sigma$1,
  SmallCircle,
  Sopf,
  Sqrt,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  Sscr,
  Star,
  Sub,
  Subset,
  SubsetEqual,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  SuchThat,
  Sum,
  Sup,
  Superset,
  SupersetEqual,
  Supset,
  THOR,
  THORN: THORN$1,
  TRADE,
  TSHcy,
  TScy,
  Tab,
  Tau: Tau$1,
  Tcaron,
  Tcedil,
  Tcy,
  Tfr,
  Therefore,
  Theta: Theta$1,
  ThickSpace,
  ThinSpace,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  Topf,
  TripleDot,
  Tscr,
  Tstrok,
  Uacut,
  Uacute: Uacute$1,
  Uarr,
  Uarrocir,
  Ubrcy,
  Ubreve,
  Ucir,
  Ucirc: Ucirc$1,
  Ucy,
  Udblac,
  Ufr,
  Ugrav,
  Ugrave: Ugrave$1,
  Umacr,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  Uopf,
  UpArrow,
  UpArrowBar,
  UpArrowDownArrow,
  UpDownArrow,
  UpEquilibrium,
  UpTee,
  UpTeeArrow,
  Uparrow,
  Updownarrow,
  UpperLeftArrow,
  UpperRightArrow,
  Upsi,
  Upsilon: Upsilon$1,
  Uring,
  Uscr,
  Utilde,
  Uum,
  Uuml: Uuml$1,
  VDash,
  Vbar,
  Vcy,
  Vdash,
  Vdashl,
  Vee,
  Verbar,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  Vopf,
  Vscr,
  Vvdash,
  Wcirc,
  Wedge,
  Wfr,
  Wopf,
  Wscr,
  Xfr,
  Xi: Xi$1,
  Xopf,
  Xscr,
  YAcy,
  YIcy,
  YUcy,
  Yacut,
  Yacute: Yacute$1,
  Ycirc,
  Ycy,
  Yfr,
  Yopf,
  Yscr,
  Yuml: Yuml$1,
  ZHcy,
  Zacute,
  Zcaron,
  Zcy,
  Zdot,
  ZeroWidthSpace,
  Zeta: Zeta$1,
  Zfr,
  Zopf,
  Zscr,
  aacut,
  aacute: aacute$1,
  abreve,
  ac,
  acE,
  acd,
  acir,
  acirc: acirc$1,
  acut,
  acute: acute$1,
  acy,
  aeli,
  aelig: aelig$1,
  af,
  afr,
  agrav,
  agrave: agrave$1,
  alefsym: alefsym$1,
  aleph,
  alpha: alpha$1,
  amacr,
  amalg,
  am,
  amp: amp$1,
  and: and$1,
  andand,
  andd,
  andslope,
  andv,
  ang: ang$1,
  ange,
  angle,
  angmsd,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  aogon,
  aopf,
  ap,
  apE,
  apacir,
  ape,
  apid,
  apos,
  approx,
  approxeq,
  arin,
  aring: aring$1,
  ascr,
  ast,
  asymp: asymp$1,
  asympeq,
  atild,
  atilde: atilde$1,
  aum,
  auml: auml$1,
  awconint,
  awint,
  bNot,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  barvee,
  barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  bcy,
  bdquo: bdquo$1,
  becaus,
  because,
  bemptyv,
  bepsi,
  bernou,
  beta: beta$1,
  beth,
  between,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block,
  bne,
  bnequiv,
  bnot,
  bopf,
  bot,
  bottom,
  bowtie,
  boxDL,
  boxDR,
  boxDl,
  boxDr,
  boxH,
  boxHD,
  boxHU,
  boxHd,
  boxHu,
  boxUL,
  boxUR,
  boxUl,
  boxUr,
  boxV,
  boxVH,
  boxVL,
  boxVR,
  boxVh,
  boxVl,
  boxVr,
  boxbox,
  boxdL,
  boxdR,
  boxdl,
  boxdr,
  boxh,
  boxhD,
  boxhU,
  boxhd,
  boxhu,
  boxminus,
  boxplus,
  boxtimes,
  boxuL,
  boxuR,
  boxul,
  boxur,
  boxv,
  boxvH,
  boxvL,
  boxvR,
  boxvh,
  boxvl,
  boxvr,
  bprime,
  breve,
  brvba,
  brvbar: brvbar$1,
  bscr,
  bsemi,
  bsim,
  bsime,
  bsol,
  bsolb,
  bsolhsub,
  bull: bull$1,
  bullet,
  bump,
  bumpE,
  bumpe,
  bumpeq,
  cacute,
  cap: cap$2,
  capand,
  capbrcup,
  capcap,
  capcup,
  capdot,
  caps,
  caret,
  caron,
  ccaps,
  ccaron,
  ccedi,
  ccedil: ccedil$1,
  ccirc,
  ccups,
  ccupssm,
  cdot,
  cedi,
  cedil: cedil$1,
  cemptyv,
  cen,
  cent: cent$1,
  centerdot,
  cfr,
  chcy,
  check,
  checkmark,
  chi: chi$1,
  cir,
  cirE,
  circ: circ$1,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledR,
  circledS,
  circledast,
  circledcirc,
  circleddash,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  clubs: clubs$1,
  clubsuit,
  colon: colon$3,
  colone,
  coloneq,
  comma: comma$2,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong: cong$1,
  congdot,
  conint,
  copf,
  coprod,
  cop,
  copy: copy$1,
  copysr,
  crarr: crarr$1,
  cross,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cup: cup$1,
  cupbrcap,
  cupcap,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curre,
  curren: curren$1,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dArr: dArr$1,
  dHar,
  dagger: dagger$1,
  daleth,
  darr: darr$1,
  dash: dash$8,
  dashv,
  dbkarow,
  dblac,
  dcaron,
  dcy,
  dd: dd$1,
  ddagger,
  ddarr,
  ddotseq,
  de,
  deg: deg$1,
  delta: delta$1,
  demptyv,
  dfisht,
  dfr,
  dharl,
  dharr,
  diam,
  diamond,
  diamondsuit,
  diams: diams$1,
  die,
  digamma,
  disin,
  div,
  divid,
  divide: divide$1,
  divideontimes,
  divonx,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  dopf,
  dot: dot$4,
  doteq,
  doteqdot,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  downarrow,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  drbkarow,
  drcorn,
  drcrop,
  dscr,
  dscy,
  dsol,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  dzcy,
  dzigrarr,
  eDDot,
  eDot,
  eacut,
  eacute: eacute$1,
  easter,
  ecaron,
  ecir,
  ecirc: ecirc$1,
  ecolon,
  ecy,
  edot,
  ee,
  efDot,
  efr,
  eg,
  egrav,
  egrave: egrave$1,
  egs,
  egsdot,
  el,
  elinters,
  ell,
  els,
  elsdot,
  emacr,
  empty: empty$3,
  emptyset,
  emptyv,
  emsp13,
  emsp14,
  emsp: emsp$1,
  eng,
  ensp: ensp$1,
  eogon,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  epsilon: epsilon$1,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  equals,
  equest,
  equiv: equiv$1,
  equivDD,
  eqvparsl,
  erDot,
  erarr,
  escr,
  esdot,
  esim,
  eta: eta$1,
  et,
  eth: eth$1,
  eum,
  euml: euml$1,
  euro: euro$1,
  excl,
  exist: exist$1,
  expectation,
  exponentiale,
  fallingdotseq,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  ffr,
  filig,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof: fnof$1,
  fopf,
  forall: forall$1,
  fork,
  forkv,
  fpartint,
  frac1,
  frac12: frac12$1,
  frac13,
  frac14: frac14$1,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac3,
  frac34: frac34$1,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl: frasl$1,
  frown,
  fscr,
  gE,
  gEl,
  gacute,
  gamma: gamma$1,
  gammad,
  gap,
  gbreve,
  gcirc,
  gcy,
  gdot,
  ge: ge$1,
  gel,
  geq,
  geqq,
  geqslant,
  ges,
  gescc,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  gfr,
  gg,
  ggg,
  gimel,
  gjcy,
  gl,
  glE,
  gla,
  glj,
  gnE,
  gnap,
  gnapprox,
  gne,
  gneq,
  gneqq,
  gnsim,
  gopf,
  grave,
  gscr,
  gsim,
  gsime,
  gsiml,
  g,
  gt: gt$1,
  gtcc,
  gtcir,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  hArr: hArr$1,
  hairsp,
  half,
  hamilt,
  hardcy,
  harr: harr$1,
  harrcir,
  harrw,
  hbar,
  hcirc,
  hearts: hearts$1,
  heartsuit,
  hellip: hellip$1,
  hercon,
  hfr,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  horbar,
  hscr,
  hslash,
  hstrok,
  hybull,
  hyphen,
  iacut,
  iacute: iacute$1,
  ic,
  icir,
  icirc: icirc$1,
  icy,
  iecy,
  iexc,
  iexcl: iexcl$1,
  iff,
  ifr,
  igrav,
  igrave: igrave$1,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  ijlig,
  imacr,
  image: image$3,
  imagline,
  imagpart,
  imath,
  imof,
  imped,
  "in": "\u2208",
  incare,
  infin: infin$1,
  infintie,
  inodot,
  int: int$1,
  intcal,
  integers,
  intercal,
  intlarhk,
  intprod,
  iocy,
  iogon,
  iopf,
  iota: iota$1,
  iprod,
  iques,
  iquest: iquest$1,
  iscr,
  isin: isin$1,
  isinE,
  isindot,
  isins,
  isinsv,
  isinv,
  it,
  itilde,
  iukcy,
  ium,
  iuml: iuml$1,
  jcirc,
  jcy,
  jfr,
  jmath,
  jopf,
  jscr,
  jsercy,
  jukcy,
  kappa: kappa$1,
  kappav,
  kcedil,
  kcy,
  kfr,
  kgreen,
  khcy,
  kjcy,
  kopf,
  kscr,
  lAarr,
  lArr: lArr$1,
  lAtail,
  lBarr,
  lE,
  lEg,
  lHar,
  lacute,
  laemptyv,
  lagran,
  lambda: lambda$1,
  lang: lang$1,
  langd,
  langle,
  lap,
  laqu,
  laquo: laquo$1,
  larr: larr$1,
  larrb,
  larrbfs,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  lat,
  latail,
  late,
  lates,
  lbarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  lcaron,
  lcedil,
  lceil: lceil$1,
  lcub,
  lcy,
  ldca,
  ldquo: ldquo$1,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le: le$1,
  leftarrow,
  leftarrowtail,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  leftthreetimes,
  leg,
  leq,
  leqq,
  leqslant,
  les,
  lescc,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  lessgtr,
  lesssim,
  lfisht,
  lfloor: lfloor$1,
  lfr,
  lg,
  lgE,
  lhard,
  lharu,
  lharul,
  lhblk,
  ljcy,
  ll,
  llarr,
  llcorner,
  llhard,
  lltri,
  lmidot,
  lmoust,
  lmoustache,
  lnE,
  lnap,
  lnapprox,
  lne,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  longleftrightarrow,
  longmapsto,
  longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  lopf,
  loplus,
  lotimes,
  lowast: lowast$1,
  lowbar,
  loz: loz$1,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm: lrm$1,
  lrtri,
  lsaquo: lsaquo$1,
  lscr,
  lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo: lsquo$1,
  lsquor,
  lstrok,
  l,
  lt: lt$1,
  ltcc,
  ltcir,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltrPar,
  ltri,
  ltrie,
  ltrif,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  mDDot,
  mac,
  macr: macr$1,
  male,
  malt,
  maltese,
  map: map$1,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  mcy,
  mdash: mdash$1,
  measuredangle,
  mfr,
  mho,
  micr,
  micro: micro$1,
  mid,
  midast,
  midcir,
  middo,
  middot: middot$1,
  minus: minus$1,
  minusb,
  minusd,
  minusdu,
  mlcp,
  mldr,
  mnplus,
  models,
  mopf,
  mp,
  mscr,
  mstpos,
  mu: mu$1,
  multimap,
  mumap,
  nGg,
  nGt,
  nGtv,
  nLeftarrow,
  nLeftrightarrow,
  nLl,
  nLt,
  nLtv,
  nRightarrow,
  nVDash,
  nVdash,
  nabla: nabla$1,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natur,
  natural,
  naturals,
  nbs,
  nbsp: nbsp$1,
  nbump,
  nbumpe,
  ncap,
  ncaron,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  ncy,
  ndash: ndash$1,
  ne: ne$1,
  neArr,
  nearhk,
  nearr,
  nearrow,
  nedot,
  nequiv,
  nesear,
  nesim,
  nexist,
  nexists,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  ngsim,
  ngt,
  ngtr,
  nhArr,
  nharr,
  nhpar,
  ni: ni$1,
  nis,
  nisd,
  niv,
  njcy,
  nlArr,
  nlE,
  nlarr,
  nldr,
  nle,
  nleftarrow,
  nleftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nlsim,
  nlt,
  nltri,
  nltrie,
  nmid,
  nopf,
  no,
  not: not$1,
  notin: notin$1,
  notinE,
  notindot,
  notinva,
  notinvb,
  notinvc,
  notni,
  notniva,
  notnivb,
  notnivc,
  npar,
  nparallel,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  npre,
  nprec,
  npreceq,
  nrArr,
  nrarr,
  nrarrc,
  nrarrw,
  nrightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub: nsub$1,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  ntild,
  ntilde: ntilde$1,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  nu: nu$1,
  num,
  numero,
  numsp,
  nvDash,
  nvHarr,
  nvap,
  nvdash,
  nvge,
  nvgt,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwArr,
  nwarhk,
  nwarr,
  nwarrow,
  nwnear,
  oS,
  oacut,
  oacute: oacute$1,
  oast,
  ocir,
  ocirc: ocirc$1,
  ocy,
  odash,
  odblac,
  odiv,
  odot,
  odsold,
  oelig: oelig$1,
  ofcir,
  ofr,
  ogon,
  ograv,
  ograve: ograve$1,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline: oline$1,
  olt,
  omacr,
  omega: omega$1,
  omicron: omicron$1,
  omid,
  ominus,
  oopf,
  opar,
  operp,
  oplus: oplus$1,
  or: or$1,
  orarr,
  ord,
  order,
  orderof,
  ordf: ordf$1,
  ordm: ordm$1,
  origof,
  oror,
  orslope,
  orv,
  oscr,
  oslas,
  oslash: oslash$1,
  osol,
  otild,
  otilde: otilde$1,
  otimes: otimes$1,
  otimesas,
  oum,
  ouml: ouml$1,
  ovbar,
  par,
  para: para$1,
  parallel,
  parsim,
  parsl,
  part: part$1,
  pcy,
  percnt,
  period,
  permil: permil$1,
  perp: perp$1,
  pertenk,
  pfr,
  phi: phi$1,
  phiv,
  phmmat,
  phone,
  pi: pi$1,
  pitchfork,
  piv: piv$1,
  planck,
  planckh,
  plankv,
  plus,
  plusacir,
  plusb,
  pluscir,
  plusdo,
  plusdu,
  pluse,
  plusm,
  plusmn: plusmn$1,
  plussim,
  plustwo,
  pm,
  pointint,
  popf,
  poun,
  pound: pound$1,
  pr,
  prE,
  prap,
  prcue,
  pre,
  prec,
  precapprox,
  preccurlyeq,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  precsim,
  prime: prime$1,
  primes,
  prnE,
  prnap,
  prnsim,
  prod: prod$1,
  profalar,
  profline,
  profsurf,
  prop: prop$1,
  propto,
  prsim,
  prurel,
  pscr,
  psi: psi$1,
  puncsp,
  qfr,
  qint,
  qopf,
  qprime,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quo,
  quot: quot$1,
  rAarr,
  rArr: rArr$1,
  rAtail,
  rBarr,
  rHar,
  race,
  racute,
  radic: radic$1,
  raemptyv,
  rang: rang$1,
  rangd,
  range,
  rangle,
  raqu,
  raquo: raquo$1,
  rarr: rarr$1,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  rarrtl,
  rarrw,
  ratail,
  ratio,
  rationals,
  rbarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  rcaron,
  rcedil,
  rceil: rceil$1,
  rcub,
  rcy,
  rdca,
  rdldhar,
  rdquo: rdquo$1,
  rdquor,
  rdsh,
  real: real$1,
  realine,
  realpart,
  reals,
  rect,
  re: re$3,
  reg: reg$1,
  rfisht,
  rfloor: rfloor$1,
  rfr,
  rhard,
  rharu,
  rharul,
  rho: rho$1,
  rhov,
  rightarrow,
  rightarrowtail,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  rightthreetimes,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm: rlm$1,
  rmoust,
  rmoustache,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  roplus,
  rotimes,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  rsaquo: rsaquo$1,
  rscr,
  rsh,
  rsqb,
  rsquo: rsquo$1,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  ruluhar,
  rx,
  sacute,
  sbquo: sbquo$1,
  sc,
  scE,
  scap,
  scaron: scaron$1,
  sccue,
  sce,
  scedil,
  scirc,
  scnE,
  scnap,
  scnsim,
  scpolint,
  scsim,
  scy,
  sdot: sdot$1,
  sdotb,
  sdote,
  seArr,
  searhk,
  searr,
  searrow,
  sec,
  sect: sect$1,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  sfr,
  sfrown,
  sharp,
  shchcy,
  shcy,
  shortmid,
  shortparallel,
  sh,
  shy: shy$1,
  sigma: sigma$1,
  sigmaf: sigmaf$1,
  sigmav,
  sim: sim$1,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  softcy,
  sol,
  solb,
  solbar,
  sopf,
  spades: spades$1,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  squ,
  square,
  squarf,
  squf,
  srarr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub: sub$1,
  subE,
  subdot,
  sube: sube$1,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  subseteq,
  subseteqq,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succ,
  succapprox,
  succcurlyeq,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  sum: sum$1,
  sung,
  sup: sup$1,
  sup1: sup1$1,
  sup2: sup2$1,
  sup3: sup3$1,
  supE,
  supdot,
  supdsub,
  supe: supe$1,
  supedot,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swArr,
  swarhk,
  swarr,
  swarrow,
  swnwar,
  szli,
  szlig: szlig$1,
  target,
  tau: tau$1,
  tbrk,
  tcaron,
  tcedil,
  tcy,
  tdot,
  telrec,
  tfr,
  there4: there4$1,
  therefore,
  theta: theta$1,
  thetasym: thetasym$1,
  thetav,
  thickapprox,
  thicksim,
  thinsp: thinsp$1,
  thkap,
  thksim,
  thor,
  thorn: thorn$1,
  tilde: tilde$4,
  time,
  times: times$1,
  timesb,
  timesbar,
  timesd,
  tint,
  toea,
  top,
  topbot,
  topcir,
  topf,
  topfork,
  tosa,
  tprime,
  trade: trade$1,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  triplus,
  trisb,
  tritime,
  trpezium,
  tscr,
  tscy,
  tshcy,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  uArr: uArr$1,
  uHar,
  uacut,
  uacute: uacute$1,
  uarr: uarr$1,
  ubrcy,
  ubreve,
  ucir,
  ucirc: ucirc$1,
  ucy,
  udarr,
  udblac,
  udhar,
  ufisht,
  ufr,
  ugrav,
  ugrave: ugrave$1,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  umacr,
  um,
  uml: uml$1,
  uogon,
  uopf,
  uparrow,
  updownarrow,
  upharpoonleft,
  upharpoonright,
  uplus,
  upsi,
  upsih: upsih$1,
  upsilon: upsilon$1,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  uring,
  urtri,
  uscr,
  utdot,
  utilde,
  utri,
  utrif,
  uuarr,
  uum,
  uuml: uuml$1,
  uwangle,
  vArr,
  vBar,
  vBarv,
  vDash,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vcy,
  vdash,
  vee,
  veebar,
  veeeq,
  vellip,
  verbar,
  vert,
  vfr,
  vltri,
  vnsub,
  vnsup,
  vopf,
  vprop,
  vrtri,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  vzigzag,
  wcirc,
  wedbar,
  wedge,
  wedgeq,
  weierp: weierp$1,
  wfr,
  wopf,
  wp,
  wr,
  wreath,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  xfr,
  xhArr,
  xharr,
  xi: xi$1,
  xlArr,
  xlarr,
  xmap,
  xnis,
  xodot,
  xopf,
  xoplus,
  xotime,
  xrArr,
  xrarr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  yacut,
  yacute: yacute$1,
  yacy,
  ycirc,
  ycy,
  ye,
  yen: yen$1,
  yfr,
  yicy,
  yopf,
  yscr,
  yucy,
  yum,
  yuml: yuml$1,
  zacute,
  zcaron,
  zcy,
  zdot,
  zeetrf,
  zeta: zeta$1,
  zfr,
  zhcy,
  zigrarr,
  zopf,
  zscr,
  zwj: zwj$1,
  zwnj: zwnj$1
};
var characterEntities$1 = Object.freeze({
  __proto__: null,
  AEli,
  AElig: AElig$1,
  AM,
  AMP: AMP$1,
  Aacut,
  Aacute: Aacute$1,
  Abreve,
  Acir,
  Acirc: Acirc$1,
  Acy,
  Afr,
  Agrav,
  Agrave: Agrave$1,
  Alpha: Alpha$1,
  Amacr,
  And,
  Aogon,
  Aopf,
  ApplyFunction,
  Arin,
  Aring: Aring$1,
  Ascr,
  Assign,
  Atild,
  Atilde: Atilde$1,
  Aum,
  Auml: Auml$1,
  Backslash,
  Barv,
  Barwed,
  Bcy,
  Because,
  Bernoullis,
  Beta: Beta$1,
  Bfr,
  Bopf,
  Breve,
  Bscr,
  Bumpeq,
  CHcy,
  COP,
  COPY,
  Cacute,
  Cap,
  CapitalDifferentialD,
  Cayleys,
  Ccaron,
  Ccedi,
  Ccedil: Ccedil$1,
  Ccirc,
  Cconint,
  Cdot,
  Cedilla,
  CenterDot,
  Cfr,
  Chi: Chi$1,
  CircleDot,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  Colon,
  Colone,
  Congruent,
  Conint,
  ContourIntegral,
  Copf,
  Coproduct,
  CounterClockwiseContourIntegral,
  Cross,
  Cscr,
  Cup,
  CupCap,
  DD,
  DDotrahd,
  DJcy,
  DScy,
  DZcy,
  Dagger: Dagger$1,
  Darr,
  Dashv,
  Dcaron,
  Dcy,
  Del,
  Delta: Delta$1,
  Dfr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  Diamond,
  DifferentialD,
  Dopf,
  Dot,
  DotDot,
  DotEqual,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrow,
  DownArrowBar,
  DownArrowUpArrow,
  DownBreve,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVector,
  DownLeftVectorBar,
  DownRightTeeVector,
  DownRightVector,
  DownRightVectorBar,
  DownTee,
  DownTeeArrow,
  Downarrow,
  Dscr,
  Dstrok,
  ENG,
  ET,
  ETH: ETH$1,
  Eacut,
  Eacute: Eacute$1,
  Ecaron,
  Ecir,
  Ecirc: Ecirc$1,
  Ecy,
  Edot,
  Efr,
  Egrav,
  Egrave: Egrave$1,
  Element: Element2,
  Emacr,
  EmptySmallSquare,
  EmptyVerySmallSquare,
  Eogon,
  Eopf,
  Epsilon: Epsilon$1,
  Equal,
  EqualTilde,
  Equilibrium,
  Escr,
  Esim,
  Eta: Eta$1,
  Eum,
  Euml: Euml$1,
  Exists,
  ExponentialE,
  Fcy,
  Ffr,
  FilledSmallSquare,
  FilledVerySmallSquare,
  Fopf,
  ForAll,
  Fouriertrf,
  Fscr,
  GJcy,
  G,
  GT: GT$1,
  Gamma: Gamma$1,
  Gammad,
  Gbreve,
  Gcedil,
  Gcirc,
  Gcy,
  Gdot,
  Gfr,
  Gg,
  Gopf,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  Gt,
  HARDcy,
  Hacek,
  Hat,
  Hcirc,
  Hfr,
  HilbertSpace,
  Hopf,
  HorizontalLine,
  Hscr,
  Hstrok,
  HumpDownHump,
  HumpEqual,
  IEcy,
  IJlig,
  IOcy,
  Iacut,
  Iacute: Iacute$1,
  Icir,
  Icirc: Icirc$1,
  Icy,
  Idot,
  Ifr,
  Igrav,
  Igrave: Igrave$1,
  Im,
  Imacr,
  ImaginaryI,
  Implies,
  Int,
  Integral,
  Intersection,
  InvisibleComma,
  InvisibleTimes,
  Iogon,
  Iopf,
  Iota: Iota$1,
  Iscr,
  Itilde,
  Iukcy,
  Ium,
  Iuml: Iuml$1,
  Jcirc,
  Jcy,
  Jfr,
  Jopf,
  Jscr,
  Jsercy,
  Jukcy,
  KHcy,
  KJcy,
  Kappa: Kappa$1,
  Kcedil,
  Kcy,
  Kfr,
  Kopf,
  Kscr,
  LJcy,
  L,
  LT: LT$1,
  Lacute,
  Lambda: Lambda$1,
  Lang,
  Laplacetrf,
  Larr,
  Lcaron,
  Lcedil,
  Lcy,
  LeftAngleBracket,
  LeftArrow,
  LeftArrowBar,
  LeftArrowRightArrow,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVector,
  LeftDownVectorBar,
  LeftFloor,
  LeftRightArrow,
  LeftRightVector,
  LeftTee,
  LeftTeeArrow,
  LeftTeeVector,
  LeftTriangle,
  LeftTriangleBar,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVector,
  LeftUpVectorBar,
  LeftVector,
  LeftVectorBar,
  Leftarrow,
  Leftrightarrow,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  LessLess,
  LessSlantEqual,
  LessTilde,
  Lfr,
  Ll,
  Lleftarrow,
  Lmidot,
  LongLeftArrow,
  LongLeftRightArrow,
  LongRightArrow,
  Longleftarrow,
  Longleftrightarrow,
  Longrightarrow,
  Lopf,
  LowerLeftArrow,
  LowerRightArrow,
  Lscr,
  Lsh,
  Lstrok,
  Lt,
  Mcy,
  MediumSpace,
  Mellintrf,
  Mfr,
  MinusPlus,
  Mopf,
  Mscr,
  Mu: Mu$1,
  NJcy,
  Nacute,
  Ncaron,
  Ncedil,
  Ncy,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  Nfr,
  NoBreak,
  NonBreakingSpace,
  Nopf,
  Not,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  NotLeftTriangle,
  NotLeftTriangleBar,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangle,
  NotRightTriangleBar,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  Nscr,
  Ntild,
  Ntilde: Ntilde$1,
  Nu: Nu$1,
  OElig: OElig$1,
  Oacut,
  Oacute: Oacute$1,
  Ocir,
  Ocirc: Ocirc$1,
  Ocy,
  Odblac,
  Ofr,
  Ograv,
  Ograve: Ograve$1,
  Omacr,
  Omega: Omega$1,
  Omicron: Omicron$1,
  Oopf,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  Or,
  Oscr,
  Oslas,
  Oslash: Oslash$1,
  Otild,
  Otilde: Otilde$1,
  Otimes,
  Oum,
  Ouml: Ouml$1,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  PartialD,
  Pcy,
  Pfr,
  Phi: Phi$1,
  Pi: Pi$1,
  PlusMinus,
  Poincareplane,
  Popf,
  Pr,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  Prime: Prime$1,
  Product,
  Proportion,
  Proportional,
  Pscr,
  Psi: Psi$1,
  QUO,
  QUOT,
  Qfr,
  Qopf,
  Qscr,
  RBarr,
  RE,
  REG,
  Racute,
  Rang,
  Rarr,
  Rarrtl,
  Rcaron,
  Rcedil,
  Rcy,
  Re,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  Rfr,
  Rho: Rho$1,
  RightAngleBracket,
  RightArrow,
  RightArrowBar,
  RightArrowLeftArrow,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVector,
  RightDownVectorBar,
  RightFloor,
  RightTee,
  RightTeeArrow,
  RightTeeVector,
  RightTriangle,
  RightTriangleBar,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVector,
  RightUpVectorBar,
  RightVector,
  RightVectorBar,
  Rightarrow,
  Ropf,
  RoundImplies,
  Rrightarrow,
  Rscr,
  Rsh,
  RuleDelayed,
  SHCHcy,
  SHcy,
  SOFTcy,
  Sacute,
  Sc,
  Scaron: Scaron$1,
  Scedil,
  Scirc,
  Scy,
  Sfr,
  ShortDownArrow,
  ShortLeftArrow,
  ShortRightArrow,
  ShortUpArrow,
  Sigma: Sigma$1,
  SmallCircle,
  Sopf,
  Sqrt,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  Sscr,
  Star,
  Sub,
  Subset,
  SubsetEqual,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  SuchThat,
  Sum,
  Sup,
  Superset,
  SupersetEqual,
  Supset,
  THOR,
  THORN: THORN$1,
  TRADE,
  TSHcy,
  TScy,
  Tab,
  Tau: Tau$1,
  Tcaron,
  Tcedil,
  Tcy,
  Tfr,
  Therefore,
  Theta: Theta$1,
  ThickSpace,
  ThinSpace,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  Topf,
  TripleDot,
  Tscr,
  Tstrok,
  Uacut,
  Uacute: Uacute$1,
  Uarr,
  Uarrocir,
  Ubrcy,
  Ubreve,
  Ucir,
  Ucirc: Ucirc$1,
  Ucy,
  Udblac,
  Ufr,
  Ugrav,
  Ugrave: Ugrave$1,
  Umacr,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  Uopf,
  UpArrow,
  UpArrowBar,
  UpArrowDownArrow,
  UpDownArrow,
  UpEquilibrium,
  UpTee,
  UpTeeArrow,
  Uparrow,
  Updownarrow,
  UpperLeftArrow,
  UpperRightArrow,
  Upsi,
  Upsilon: Upsilon$1,
  Uring,
  Uscr,
  Utilde,
  Uum,
  Uuml: Uuml$1,
  VDash,
  Vbar,
  Vcy,
  Vdash,
  Vdashl,
  Vee,
  Verbar,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  Vopf,
  Vscr,
  Vvdash,
  Wcirc,
  Wedge,
  Wfr,
  Wopf,
  Wscr,
  Xfr,
  Xi: Xi$1,
  Xopf,
  Xscr,
  YAcy,
  YIcy,
  YUcy,
  Yacut,
  Yacute: Yacute$1,
  Ycirc,
  Ycy,
  Yfr,
  Yopf,
  Yscr,
  Yuml: Yuml$1,
  ZHcy,
  Zacute,
  Zcaron,
  Zcy,
  Zdot,
  ZeroWidthSpace,
  Zeta: Zeta$1,
  Zfr,
  Zopf,
  Zscr,
  aacut,
  aacute: aacute$1,
  abreve,
  ac,
  acE,
  acd,
  acir,
  acirc: acirc$1,
  acut,
  acute: acute$1,
  acy,
  aeli,
  aelig: aelig$1,
  af,
  afr,
  agrav,
  agrave: agrave$1,
  alefsym: alefsym$1,
  aleph,
  alpha: alpha$1,
  amacr,
  amalg,
  am,
  amp: amp$1,
  and: and$1,
  andand,
  andd,
  andslope,
  andv,
  ang: ang$1,
  ange,
  angle,
  angmsd,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  aogon,
  aopf,
  ap,
  apE,
  apacir,
  ape,
  apid,
  apos,
  approx,
  approxeq,
  arin,
  aring: aring$1,
  ascr,
  ast,
  asymp: asymp$1,
  asympeq,
  atild,
  atilde: atilde$1,
  aum,
  auml: auml$1,
  awconint,
  awint,
  bNot,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  barvee,
  barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  bcy,
  bdquo: bdquo$1,
  becaus,
  because,
  bemptyv,
  bepsi,
  bernou,
  beta: beta$1,
  beth,
  between,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block,
  bne,
  bnequiv,
  bnot,
  bopf,
  bot,
  bottom,
  bowtie,
  boxDL,
  boxDR,
  boxDl,
  boxDr,
  boxH,
  boxHD,
  boxHU,
  boxHd,
  boxHu,
  boxUL,
  boxUR,
  boxUl,
  boxUr,
  boxV,
  boxVH,
  boxVL,
  boxVR,
  boxVh,
  boxVl,
  boxVr,
  boxbox,
  boxdL,
  boxdR,
  boxdl,
  boxdr,
  boxh,
  boxhD,
  boxhU,
  boxhd,
  boxhu,
  boxminus,
  boxplus,
  boxtimes,
  boxuL,
  boxuR,
  boxul,
  boxur,
  boxv,
  boxvH,
  boxvL,
  boxvR,
  boxvh,
  boxvl,
  boxvr,
  bprime,
  breve,
  brvba,
  brvbar: brvbar$1,
  bscr,
  bsemi,
  bsim,
  bsime,
  bsol,
  bsolb,
  bsolhsub,
  bull: bull$1,
  bullet,
  bump,
  bumpE,
  bumpe,
  bumpeq,
  cacute,
  cap: cap$2,
  capand,
  capbrcup,
  capcap,
  capcup,
  capdot,
  caps,
  caret,
  caron,
  ccaps,
  ccaron,
  ccedi,
  ccedil: ccedil$1,
  ccirc,
  ccups,
  ccupssm,
  cdot,
  cedi,
  cedil: cedil$1,
  cemptyv,
  cen,
  cent: cent$1,
  centerdot,
  cfr,
  chcy,
  check,
  checkmark,
  chi: chi$1,
  cir,
  cirE,
  circ: circ$1,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledR,
  circledS,
  circledast,
  circledcirc,
  circleddash,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  clubs: clubs$1,
  clubsuit,
  colon: colon$3,
  colone,
  coloneq,
  comma: comma$2,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong: cong$1,
  congdot,
  conint,
  copf,
  coprod,
  cop,
  copy: copy$1,
  copysr,
  crarr: crarr$1,
  cross,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cup: cup$1,
  cupbrcap,
  cupcap,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curre,
  curren: curren$1,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dArr: dArr$1,
  dHar,
  dagger: dagger$1,
  daleth,
  darr: darr$1,
  dash: dash$8,
  dashv,
  dbkarow,
  dblac,
  dcaron,
  dcy,
  dd: dd$1,
  ddagger,
  ddarr,
  ddotseq,
  de,
  deg: deg$1,
  delta: delta$1,
  demptyv,
  dfisht,
  dfr,
  dharl,
  dharr,
  diam,
  diamond,
  diamondsuit,
  diams: diams$1,
  die,
  digamma,
  disin,
  div,
  divid,
  divide: divide$1,
  divideontimes,
  divonx,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  dopf,
  dot: dot$4,
  doteq,
  doteqdot,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  downarrow,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  drbkarow,
  drcorn,
  drcrop,
  dscr,
  dscy,
  dsol,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  dzcy,
  dzigrarr,
  eDDot,
  eDot,
  eacut,
  eacute: eacute$1,
  easter,
  ecaron,
  ecir,
  ecirc: ecirc$1,
  ecolon,
  ecy,
  edot,
  ee,
  efDot,
  efr,
  eg,
  egrav,
  egrave: egrave$1,
  egs,
  egsdot,
  el,
  elinters,
  ell,
  els,
  elsdot,
  emacr,
  empty: empty$3,
  emptyset,
  emptyv,
  emsp13,
  emsp14,
  emsp: emsp$1,
  eng,
  ensp: ensp$1,
  eogon,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  epsilon: epsilon$1,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  equals,
  equest,
  equiv: equiv$1,
  equivDD,
  eqvparsl,
  erDot,
  erarr,
  escr,
  esdot,
  esim,
  eta: eta$1,
  et,
  eth: eth$1,
  eum,
  euml: euml$1,
  euro: euro$1,
  excl,
  exist: exist$1,
  expectation,
  exponentiale,
  fallingdotseq,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  ffr,
  filig,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof: fnof$1,
  fopf,
  forall: forall$1,
  fork,
  forkv,
  fpartint,
  frac1,
  frac12: frac12$1,
  frac13,
  frac14: frac14$1,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac3,
  frac34: frac34$1,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl: frasl$1,
  frown,
  fscr,
  gE,
  gEl,
  gacute,
  gamma: gamma$1,
  gammad,
  gap,
  gbreve,
  gcirc,
  gcy,
  gdot,
  ge: ge$1,
  gel,
  geq,
  geqq,
  geqslant,
  ges,
  gescc,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  gfr,
  gg,
  ggg,
  gimel,
  gjcy,
  gl,
  glE,
  gla,
  glj,
  gnE,
  gnap,
  gnapprox,
  gne,
  gneq,
  gneqq,
  gnsim,
  gopf,
  grave,
  gscr,
  gsim,
  gsime,
  gsiml,
  g,
  gt: gt$1,
  gtcc,
  gtcir,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  hArr: hArr$1,
  hairsp,
  half,
  hamilt,
  hardcy,
  harr: harr$1,
  harrcir,
  harrw,
  hbar,
  hcirc,
  hearts: hearts$1,
  heartsuit,
  hellip: hellip$1,
  hercon,
  hfr,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  horbar,
  hscr,
  hslash,
  hstrok,
  hybull,
  hyphen,
  iacut,
  iacute: iacute$1,
  ic,
  icir,
  icirc: icirc$1,
  icy,
  iecy,
  iexc,
  iexcl: iexcl$1,
  iff,
  ifr,
  igrav,
  igrave: igrave$1,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  ijlig,
  imacr,
  image: image$3,
  imagline,
  imagpart,
  imath,
  imof,
  imped,
  incare,
  infin: infin$1,
  infintie,
  inodot,
  int: int$1,
  intcal,
  integers,
  intercal,
  intlarhk,
  intprod,
  iocy,
  iogon,
  iopf,
  iota: iota$1,
  iprod,
  iques,
  iquest: iquest$1,
  iscr,
  isin: isin$1,
  isinE,
  isindot,
  isins,
  isinsv,
  isinv,
  it,
  itilde,
  iukcy,
  ium,
  iuml: iuml$1,
  jcirc,
  jcy,
  jfr,
  jmath,
  jopf,
  jscr,
  jsercy,
  jukcy,
  kappa: kappa$1,
  kappav,
  kcedil,
  kcy,
  kfr,
  kgreen,
  khcy,
  kjcy,
  kopf,
  kscr,
  lAarr,
  lArr: lArr$1,
  lAtail,
  lBarr,
  lE,
  lEg,
  lHar,
  lacute,
  laemptyv,
  lagran,
  lambda: lambda$1,
  lang: lang$1,
  langd,
  langle,
  lap,
  laqu,
  laquo: laquo$1,
  larr: larr$1,
  larrb,
  larrbfs,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  lat,
  latail,
  late,
  lates,
  lbarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  lcaron,
  lcedil,
  lceil: lceil$1,
  lcub,
  lcy,
  ldca,
  ldquo: ldquo$1,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le: le$1,
  leftarrow,
  leftarrowtail,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  leftthreetimes,
  leg,
  leq,
  leqq,
  leqslant,
  les,
  lescc,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  lessgtr,
  lesssim,
  lfisht,
  lfloor: lfloor$1,
  lfr,
  lg,
  lgE,
  lhard,
  lharu,
  lharul,
  lhblk,
  ljcy,
  ll,
  llarr,
  llcorner,
  llhard,
  lltri,
  lmidot,
  lmoust,
  lmoustache,
  lnE,
  lnap,
  lnapprox,
  lne,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  longleftrightarrow,
  longmapsto,
  longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  lopf,
  loplus,
  lotimes,
  lowast: lowast$1,
  lowbar,
  loz: loz$1,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm: lrm$1,
  lrtri,
  lsaquo: lsaquo$1,
  lscr,
  lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo: lsquo$1,
  lsquor,
  lstrok,
  l,
  lt: lt$1,
  ltcc,
  ltcir,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltrPar,
  ltri,
  ltrie,
  ltrif,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  mDDot,
  mac,
  macr: macr$1,
  male,
  malt,
  maltese,
  map: map$1,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  mcy,
  mdash: mdash$1,
  measuredangle,
  mfr,
  mho,
  micr,
  micro: micro$1,
  mid,
  midast,
  midcir,
  middo,
  middot: middot$1,
  minus: minus$1,
  minusb,
  minusd,
  minusdu,
  mlcp,
  mldr,
  mnplus,
  models,
  mopf,
  mp,
  mscr,
  mstpos,
  mu: mu$1,
  multimap,
  mumap,
  nGg,
  nGt,
  nGtv,
  nLeftarrow,
  nLeftrightarrow,
  nLl,
  nLt,
  nLtv,
  nRightarrow,
  nVDash,
  nVdash,
  nabla: nabla$1,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natur,
  natural,
  naturals,
  nbs,
  nbsp: nbsp$1,
  nbump,
  nbumpe,
  ncap,
  ncaron,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  ncy,
  ndash: ndash$1,
  ne: ne$1,
  neArr,
  nearhk,
  nearr,
  nearrow,
  nedot,
  nequiv,
  nesear,
  nesim,
  nexist,
  nexists,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  ngsim,
  ngt,
  ngtr,
  nhArr,
  nharr,
  nhpar,
  ni: ni$1,
  nis,
  nisd,
  niv,
  njcy,
  nlArr,
  nlE,
  nlarr,
  nldr,
  nle,
  nleftarrow,
  nleftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nlsim,
  nlt,
  nltri,
  nltrie,
  nmid,
  nopf,
  no,
  not: not$1,
  notin: notin$1,
  notinE,
  notindot,
  notinva,
  notinvb,
  notinvc,
  notni,
  notniva,
  notnivb,
  notnivc,
  npar,
  nparallel,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  npre,
  nprec,
  npreceq,
  nrArr,
  nrarr,
  nrarrc,
  nrarrw,
  nrightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub: nsub$1,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  ntild,
  ntilde: ntilde$1,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  nu: nu$1,
  num,
  numero,
  numsp,
  nvDash,
  nvHarr,
  nvap,
  nvdash,
  nvge,
  nvgt,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwArr,
  nwarhk,
  nwarr,
  nwarrow,
  nwnear,
  oS,
  oacut,
  oacute: oacute$1,
  oast,
  ocir,
  ocirc: ocirc$1,
  ocy,
  odash,
  odblac,
  odiv,
  odot,
  odsold,
  oelig: oelig$1,
  ofcir,
  ofr,
  ogon,
  ograv,
  ograve: ograve$1,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline: oline$1,
  olt,
  omacr,
  omega: omega$1,
  omicron: omicron$1,
  omid,
  ominus,
  oopf,
  opar,
  operp,
  oplus: oplus$1,
  or: or$1,
  orarr,
  ord,
  order,
  orderof,
  ordf: ordf$1,
  ordm: ordm$1,
  origof,
  oror,
  orslope,
  orv,
  oscr,
  oslas,
  oslash: oslash$1,
  osol,
  otild,
  otilde: otilde$1,
  otimes: otimes$1,
  otimesas,
  oum,
  ouml: ouml$1,
  ovbar,
  par,
  para: para$1,
  parallel,
  parsim,
  parsl,
  part: part$1,
  pcy,
  percnt,
  period,
  permil: permil$1,
  perp: perp$1,
  pertenk,
  pfr,
  phi: phi$1,
  phiv,
  phmmat,
  phone,
  pi: pi$1,
  pitchfork,
  piv: piv$1,
  planck,
  planckh,
  plankv,
  plus,
  plusacir,
  plusb,
  pluscir,
  plusdo,
  plusdu,
  pluse,
  plusm,
  plusmn: plusmn$1,
  plussim,
  plustwo,
  pm,
  pointint,
  popf,
  poun,
  pound: pound$1,
  pr,
  prE,
  prap,
  prcue,
  pre,
  prec,
  precapprox,
  preccurlyeq,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  precsim,
  prime: prime$1,
  primes,
  prnE,
  prnap,
  prnsim,
  prod: prod$1,
  profalar,
  profline,
  profsurf,
  prop: prop$1,
  propto,
  prsim,
  prurel,
  pscr,
  psi: psi$1,
  puncsp,
  qfr,
  qint,
  qopf,
  qprime,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quo,
  quot: quot$1,
  rAarr,
  rArr: rArr$1,
  rAtail,
  rBarr,
  rHar,
  race,
  racute,
  radic: radic$1,
  raemptyv,
  rang: rang$1,
  rangd,
  range,
  rangle,
  raqu,
  raquo: raquo$1,
  rarr: rarr$1,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  rarrtl,
  rarrw,
  ratail,
  ratio,
  rationals,
  rbarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  rcaron,
  rcedil,
  rceil: rceil$1,
  rcub,
  rcy,
  rdca,
  rdldhar,
  rdquo: rdquo$1,
  rdquor,
  rdsh,
  real: real$1,
  realine,
  realpart,
  reals,
  rect,
  re: re$3,
  reg: reg$1,
  rfisht,
  rfloor: rfloor$1,
  rfr,
  rhard,
  rharu,
  rharul,
  rho: rho$1,
  rhov,
  rightarrow,
  rightarrowtail,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  rightthreetimes,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm: rlm$1,
  rmoust,
  rmoustache,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  roplus,
  rotimes,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  rsaquo: rsaquo$1,
  rscr,
  rsh,
  rsqb,
  rsquo: rsquo$1,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  ruluhar,
  rx,
  sacute,
  sbquo: sbquo$1,
  sc,
  scE,
  scap,
  scaron: scaron$1,
  sccue,
  sce,
  scedil,
  scirc,
  scnE,
  scnap,
  scnsim,
  scpolint,
  scsim,
  scy,
  sdot: sdot$1,
  sdotb,
  sdote,
  seArr,
  searhk,
  searr,
  searrow,
  sec,
  sect: sect$1,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  sfr,
  sfrown,
  sharp,
  shchcy,
  shcy,
  shortmid,
  shortparallel,
  sh,
  shy: shy$1,
  sigma: sigma$1,
  sigmaf: sigmaf$1,
  sigmav,
  sim: sim$1,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  softcy,
  sol,
  solb,
  solbar,
  sopf,
  spades: spades$1,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  squ,
  square,
  squarf,
  squf,
  srarr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub: sub$1,
  subE,
  subdot,
  sube: sube$1,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  subseteq,
  subseteqq,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succ,
  succapprox,
  succcurlyeq,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  sum: sum$1,
  sung,
  sup: sup$1,
  sup1: sup1$1,
  sup2: sup2$1,
  sup3: sup3$1,
  supE,
  supdot,
  supdsub,
  supe: supe$1,
  supedot,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swArr,
  swarhk,
  swarr,
  swarrow,
  swnwar,
  szli,
  szlig: szlig$1,
  target,
  tau: tau$1,
  tbrk,
  tcaron,
  tcedil,
  tcy,
  tdot,
  telrec,
  tfr,
  there4: there4$1,
  therefore,
  theta: theta$1,
  thetasym: thetasym$1,
  thetav,
  thickapprox,
  thicksim,
  thinsp: thinsp$1,
  thkap,
  thksim,
  thor,
  thorn: thorn$1,
  tilde: tilde$4,
  time,
  times: times$1,
  timesb,
  timesbar,
  timesd,
  tint,
  toea,
  top,
  topbot,
  topcir,
  topf,
  topfork,
  tosa,
  tprime,
  trade: trade$1,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  triplus,
  trisb,
  tritime,
  trpezium,
  tscr,
  tscy,
  tshcy,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  uArr: uArr$1,
  uHar,
  uacut,
  uacute: uacute$1,
  uarr: uarr$1,
  ubrcy,
  ubreve,
  ucir,
  ucirc: ucirc$1,
  ucy,
  udarr,
  udblac,
  udhar,
  ufisht,
  ufr,
  ugrav,
  ugrave: ugrave$1,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  umacr,
  um,
  uml: uml$1,
  uogon,
  uopf,
  uparrow,
  updownarrow,
  upharpoonleft,
  upharpoonright,
  uplus,
  upsi,
  upsih: upsih$1,
  upsilon: upsilon$1,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  uring,
  urtri,
  uscr,
  utdot,
  utilde,
  utri,
  utrif,
  uuarr,
  uum,
  uuml: uuml$1,
  uwangle,
  vArr,
  vBar,
  vBarv,
  vDash,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vcy,
  vdash,
  vee,
  veebar,
  veeeq,
  vellip,
  verbar,
  vert,
  vfr,
  vltri,
  vnsub,
  vnsup,
  vopf,
  vprop,
  vrtri,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  vzigzag,
  wcirc,
  wedbar,
  wedge,
  wedgeq,
  weierp: weierp$1,
  wfr,
  wopf,
  wp,
  wr,
  wreath,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  xfr,
  xhArr,
  xharr,
  xi: xi$1,
  xlArr,
  xlarr,
  xmap,
  xnis,
  xodot,
  xopf,
  xoplus,
  xotime,
  xrArr,
  xrarr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  yacut,
  yacute: yacute$1,
  yacy,
  ycirc,
  ycy,
  ye,
  yen: yen$1,
  yfr,
  yicy,
  yopf,
  yscr,
  yucy,
  yum,
  yuml: yuml$1,
  zacute,
  zcaron,
  zcy,
  zdot,
  zeetrf,
  zeta: zeta$1,
  zfr,
  zhcy,
  zigrarr,
  zopf,
  zscr,
  zwj: zwj$1,
  zwnj: zwnj$1,
  "default": index$3
});
var characterEntities = getCjsExportFromNamespace(characterEntities$1);
var decodeEntity_1 = decodeEntity;
var own$c = {}.hasOwnProperty;
function decodeEntity(characters2) {
  return own$c.call(characterEntities, characters2) ? characterEntities[characters2] : false;
}
var legacy = getCjsExportFromNamespace(characterEntitiesLegacy);
var invalid = getCjsExportFromNamespace(characterReferenceInvalid);
var parseEntities_1 = parseEntities;
var own$b = {}.hasOwnProperty;
var fromCharCode = String.fromCharCode;
var noop2 = Function.prototype;
var defaults$3 = {
  warning: null,
  reference: null,
  text: null,
  warningContext: null,
  referenceContext: null,
  textContext: null,
  position: {},
  additional: null,
  attribute: false,
  nonTerminated: true
};
var tab$e = 9;
var lineFeed$j = 10;
var formFeed = 12;
var space$j = 32;
var ampersand$1 = 38;
var semicolon$1 = 59;
var lessThan$8 = 60;
var equalsTo$2 = 61;
var numberSign$1 = 35;
var uppercaseX = 88;
var lowercaseX$1 = 120;
var replacementCharacter = 65533;
var name$1 = "named";
var hexa = "hexadecimal";
var deci = "decimal";
var bases = {};
bases[hexa] = 16;
bases[deci] = 10;
var tests = {};
tests[name$1] = isAlphanumerical;
tests[deci] = isDecimal;
tests[hexa] = isHexadecimal;
var namedNotTerminated = 1;
var numericNotTerminated = 2;
var namedEmpty = 3;
var numericEmpty = 4;
var namedUnknown = 5;
var numericDisallowed = 6;
var numericProhibited = 7;
var messages = {};
messages[namedNotTerminated] = "Named character references must be terminated by a semicolon";
messages[numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
messages[namedEmpty] = "Named character references cannot be empty";
messages[numericEmpty] = "Numeric character references cannot be empty";
messages[namedUnknown] = "Named character references must be known";
messages[numericDisallowed] = "Numeric character references cannot be disallowed";
messages[numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
function parseEntities(value2, options2) {
  var settings = {};
  var option2;
  var key;
  if (!options2) {
    options2 = {};
  }
  for (key in defaults$3) {
    option2 = options2[key];
    settings[key] = option2 === null || option2 === void 0 ? defaults$3[key] : option2;
  }
  if (settings.position.indent || settings.position.start) {
    settings.indent = settings.position.indent || [];
    settings.position = settings.position.start;
  }
  return parse$7(value2, settings);
}
function parse$7(value2, settings) {
  var additional = settings.additional;
  var nonTerminated = settings.nonTerminated;
  var handleText = settings.text;
  var handleReference = settings.reference;
  var handleWarning = settings.warning;
  var textContext = settings.textContext;
  var referenceContext = settings.referenceContext;
  var warningContext = settings.warningContext;
  var pos = settings.position;
  var indent2 = settings.indent || [];
  var length2 = value2.length;
  var index2 = 0;
  var lines = -1;
  var column = pos.column || 1;
  var line2 = pos.line || 1;
  var queue = "";
  var result = [];
  var entityCharacters;
  var namedEntity;
  var terminated;
  var characters2;
  var character;
  var reference2;
  var following;
  var warning;
  var reason;
  var output;
  var entity;
  var begin;
  var start2;
  var type2;
  var test2;
  var prev;
  var next;
  var diff;
  var end2;
  if (typeof additional === "string") {
    additional = additional.charCodeAt(0);
  }
  prev = now2();
  warning = handleWarning ? parseError : noop2;
  index2--;
  length2++;
  while (++index2 < length2) {
    if (character === lineFeed$j) {
      column = indent2[lines] || 1;
    }
    character = value2.charCodeAt(index2);
    if (character === ampersand$1) {
      following = value2.charCodeAt(index2 + 1);
      if (following === tab$e || following === lineFeed$j || following === formFeed || following === space$j || following === ampersand$1 || following === lessThan$8 || following !== following || additional && following === additional) {
        queue += fromCharCode(character);
        column++;
        continue;
      }
      start2 = index2 + 1;
      begin = start2;
      end2 = start2;
      if (following === numberSign$1) {
        end2 = ++begin;
        following = value2.charCodeAt(end2);
        if (following === uppercaseX || following === lowercaseX$1) {
          type2 = hexa;
          end2 = ++begin;
        } else {
          type2 = deci;
        }
      } else {
        type2 = name$1;
      }
      entityCharacters = "";
      entity = "";
      characters2 = "";
      test2 = tests[type2];
      end2--;
      while (++end2 < length2) {
        following = value2.charCodeAt(end2);
        if (!test2(following)) {
          break;
        }
        characters2 += fromCharCode(following);
        if (type2 === name$1 && own$b.call(legacy, characters2)) {
          entityCharacters = characters2;
          entity = legacy[characters2];
        }
      }
      terminated = value2.charCodeAt(end2) === semicolon$1;
      if (terminated) {
        end2++;
        namedEntity = type2 === name$1 ? decodeEntity_1(characters2) : false;
        if (namedEntity) {
          entityCharacters = characters2;
          entity = namedEntity;
        }
      }
      diff = 1 + end2 - start2;
      if (!terminated && !nonTerminated)
        ;
      else if (!characters2) {
        if (type2 !== name$1) {
          warning(numericEmpty, diff);
        }
      } else if (type2 === name$1) {
        if (terminated && !entity) {
          warning(namedUnknown, 1);
        } else {
          if (entityCharacters !== characters2) {
            end2 = begin + entityCharacters.length;
            diff = 1 + end2 - begin;
            terminated = false;
          }
          if (!terminated) {
            reason = entityCharacters ? namedNotTerminated : namedEmpty;
            if (settings.attribute) {
              following = value2.charCodeAt(end2);
              if (following === equalsTo$2) {
                warning(reason, diff);
                entity = null;
              } else if (isAlphanumerical(following)) {
                entity = null;
              } else {
                warning(reason, diff);
              }
            } else {
              warning(reason, diff);
            }
          }
        }
        reference2 = entity;
      } else {
        if (!terminated) {
          warning(numericNotTerminated, diff);
        }
        reference2 = parseInt(characters2, bases[type2]);
        if (prohibited(reference2)) {
          warning(numericProhibited, diff);
          reference2 = fromCharCode(replacementCharacter);
        } else if (reference2 in invalid) {
          warning(numericDisallowed, diff);
          reference2 = invalid[reference2];
        } else {
          output = "";
          if (disallowed(reference2)) {
            warning(numericDisallowed, diff);
          }
          if (reference2 > 65535) {
            reference2 -= 65536;
            output += fromCharCode(reference2 >>> (10 & 1023) | 55296);
            reference2 = 56320 | reference2 & 1023;
          }
          reference2 = output + fromCharCode(reference2);
        }
      }
      if (reference2) {
        flush();
        prev = now2();
        index2 = end2 - 1;
        column += end2 - start2 + 1;
        result.push(reference2);
        next = now2();
        next.offset++;
        if (handleReference) {
          handleReference.call(
            referenceContext,
            reference2,
            { start: prev, end: next },
            value2.slice(start2 - 1, end2)
          );
        }
        prev = next;
      } else {
        characters2 = value2.slice(start2 - 1, end2);
        queue += characters2;
        column += characters2.length;
        index2 = end2 - 1;
      }
    } else {
      if (character === 10) {
        line2++;
        lines++;
        column = 0;
      }
      if (character === character) {
        queue += fromCharCode(character);
        column++;
      } else {
        flush();
      }
    }
  }
  return result.join("");
  function now2() {
    return {
      line: line2,
      column,
      offset: index2 + (pos.offset || 0)
    };
  }
  function parseError(code2, offset2) {
    var position2 = now2();
    position2.column += offset2;
    position2.offset += offset2;
    handleWarning.call(warningContext, messages[code2], position2, code2);
  }
  function flush() {
    if (queue) {
      result.push(queue);
      if (handleText) {
        handleText.call(textContext, queue, { start: prev, end: now2() });
      }
      queue = "";
    }
  }
}
function prohibited(code2) {
  return code2 >= 55296 && code2 <= 57343 || code2 > 1114111;
}
function disallowed(code2) {
  return code2 >= 1 && code2 <= 8 || code2 === 11 || code2 >= 13 && code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 64976 && code2 <= 65007 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534;
}
var decode = factory$3;
function factory$3(ctx) {
  decoder.raw = decodeRaw;
  return decoder;
  function normalize3(position2) {
    var offsets = ctx.offset;
    var line2 = position2.line;
    var result = [];
    while (++line2) {
      if (!(line2 in offsets)) {
        break;
      }
      result.push((offsets[line2] || 0) + 1);
    }
    return { start: position2, indent: result };
  }
  function decoder(value2, position2, handler) {
    parseEntities_1(value2, {
      position: normalize3(position2),
      warning: handleWarning,
      text: handler,
      reference: handler,
      textContext: ctx,
      referenceContext: ctx
    });
  }
  function decodeRaw(value2, position2, options2) {
    return parseEntities_1(
      value2,
      immutable(options2, { position: normalize3(position2), warning: handleWarning })
    );
  }
  function handleWarning(reason, position2, code2) {
    if (code2 !== 3) {
      ctx.file.message(reason, position2);
    }
  }
}
var tokenizer$1 = factory$2;
function factory$2(type2) {
  return tokenize3;
  function tokenize3(value2, location) {
    var self2 = this;
    var offset2 = self2.offset;
    var tokens = [];
    var methods = self2[type2 + "Methods"];
    var tokenizers = self2[type2 + "Tokenizers"];
    var line2 = location.line;
    var column = location.column;
    var index2;
    var length2;
    var method;
    var name2;
    var matched;
    var valueLength;
    if (!value2) {
      return tokens;
    }
    eat2.now = now2;
    eat2.file = self2.file;
    updatePosition("");
    while (value2) {
      index2 = -1;
      length2 = methods.length;
      matched = false;
      while (++index2 < length2) {
        name2 = methods[index2];
        method = tokenizers[name2];
        if (method && (!method.onlyAtStart || self2.atStart) && (!method.notInList || !self2.inList) && (!method.notInBlock || !self2.inBlock) && (!method.notInLink || !self2.inLink)) {
          valueLength = value2.length;
          method.apply(self2, [eat2, value2]);
          matched = valueLength !== value2.length;
          if (matched) {
            break;
          }
        }
      }
      if (!matched) {
        self2.file.fail(new Error("Infinite loop"), eat2.now());
      }
    }
    self2.eof = now2();
    return tokens;
    function updatePosition(subvalue) {
      var lastIndex = -1;
      var index3 = subvalue.indexOf("\n");
      while (index3 !== -1) {
        line2++;
        lastIndex = index3;
        index3 = subvalue.indexOf("\n", index3 + 1);
      }
      if (lastIndex === -1) {
        column += subvalue.length;
      } else {
        column = subvalue.length - lastIndex;
      }
      if (line2 in offset2) {
        if (lastIndex !== -1) {
          column += offset2[line2];
        } else if (column <= offset2[line2]) {
          column = offset2[line2] + 1;
        }
      }
    }
    function getOffset() {
      var indentation2 = [];
      var pos = line2 + 1;
      return function() {
        var last = line2 + 1;
        while (pos < last) {
          indentation2.push((offset2[pos] || 0) + 1);
          pos++;
        }
        return indentation2;
      };
    }
    function now2() {
      var pos = { line: line2, column };
      pos.offset = self2.toOffset(pos);
      return pos;
    }
    function Position3(start2) {
      this.start = start2;
      this.end = now2();
    }
    function validateEat(subvalue) {
      if (value2.slice(0, subvalue.length) !== subvalue) {
        self2.file.fail(
          new Error(
            "Incorrectly eaten value: please report this warning on https://git.io/vg5Ft"
          ),
          now2()
        );
      }
    }
    function position2() {
      var before2 = now2();
      return update;
      function update(node2, indent2) {
        var previous = node2.position;
        var start2 = previous ? previous.start : before2;
        var combined = [];
        var n2 = previous && previous.end.line;
        var l2 = before2.line;
        node2.position = new Position3(start2);
        if (previous && indent2 && previous.indent) {
          combined = previous.indent;
          if (n2 < l2) {
            while (++n2 < l2) {
              combined.push((offset2[n2] || 0) + 1);
            }
            combined.push(before2.column);
          }
          indent2 = combined.concat(indent2);
        }
        node2.position.indent = indent2 || [];
        return node2;
      }
    }
    function add(node2, parent) {
      var children = parent ? parent.children : tokens;
      var previous = children[children.length - 1];
      var fn;
      if (previous && node2.type === previous.type && (node2.type === "text" || node2.type === "blockquote") && mergeable(previous) && mergeable(node2)) {
        fn = node2.type === "text" ? mergeText : mergeBlockquote;
        node2 = fn.call(self2, previous, node2);
      }
      if (node2 !== previous) {
        children.push(node2);
      }
      if (self2.atStart && tokens.length !== 0) {
        self2.exitStart();
      }
      return node2;
    }
    function eat2(subvalue) {
      var indent2 = getOffset();
      var pos = position2();
      var current2 = now2();
      validateEat(subvalue);
      apply.reset = reset2;
      reset2.test = test2;
      apply.test = test2;
      value2 = value2.slice(subvalue.length);
      updatePosition(subvalue);
      indent2 = indent2();
      return apply;
      function apply(node2, parent) {
        return pos(add(pos(node2), parent), indent2);
      }
      function reset2() {
        var node2 = apply.apply(null, arguments);
        line2 = current2.line;
        column = current2.column;
        value2 = subvalue + value2;
        return node2;
      }
      function test2() {
        var result = pos({});
        line2 = current2.line;
        column = current2.column;
        value2 = subvalue + value2;
        return result.position;
      }
    }
  }
}
function mergeable(node2) {
  var start2;
  var end2;
  if (node2.type !== "text" || !node2.position) {
    return true;
  }
  start2 = node2.position.start;
  end2 = node2.position.end;
  return start2.line !== end2.line || end2.column - start2.column === node2.value.length;
}
function mergeText(previous, node2) {
  previous.value += node2.value;
  return previous;
}
function mergeBlockquote(previous, node2) {
  if (this.options.commonmark || this.options.gfm) {
    return node2;
  }
  previous.children = previous.children.concat(node2.children);
  return previous;
}
var markdownEscapes = escapes$1;
var defaults$2 = [
  "\\",
  "`",
  "*",
  "{",
  "}",
  "[",
  "]",
  "(",
  ")",
  "#",
  "+",
  "-",
  ".",
  "!",
  "_",
  ">"
];
var gfm = defaults$2.concat(["~", "|"]);
var commonmark = gfm.concat([
  "\n",
  '"',
  "$",
  "%",
  "&",
  "'",
  ",",
  "/",
  ":",
  ";",
  "<",
  "=",
  "?",
  "@",
  "^"
]);
escapes$1.default = defaults$2;
escapes$1.gfm = gfm;
escapes$1.commonmark = commonmark;
function escapes$1(options2) {
  var settings = options2 || {};
  if (settings.commonmark) {
    return commonmark;
  }
  return settings.gfm ? gfm : defaults$2;
}
var blockElements = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "meta",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "pre",
  "section",
  "source",
  "title",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var defaults$1 = {
  position: true,
  gfm: true,
  commonmark: false,
  pedantic: false,
  blocks: blockElements
};
var setOptions_1 = setOptions;
function setOptions(options2) {
  var self2 = this;
  var current2 = self2.options;
  var key;
  var value2;
  if (options2 == null) {
    options2 = {};
  } else if (typeof options2 === "object") {
    options2 = immutable(options2);
  } else {
    throw new Error("Invalid value `" + options2 + "` for setting `options`");
  }
  for (key in defaults$1) {
    value2 = options2[key];
    if (value2 == null) {
      value2 = current2[key];
    }
    if (key !== "blocks" && typeof value2 !== "boolean" || key === "blocks" && typeof value2 !== "object") {
      throw new Error(
        "Invalid value `" + value2 + "` for setting `options." + key + "`"
      );
    }
    options2[key] = value2;
  }
  self2.options = options2;
  self2.escape = markdownEscapes(options2);
  return self2;
}
var convert_1 = convert$1;
function convert$1(test2) {
  if (test2 == null) {
    return ok$1;
  }
  if (typeof test2 === "string") {
    return typeFactory$1(test2);
  }
  if (typeof test2 === "object") {
    return "length" in test2 ? anyFactory$1(test2) : allFactory(test2);
  }
  if (typeof test2 === "function") {
    return test2;
  }
  throw new Error("Expected function, string, or object as test");
}
function allFactory(test2) {
  return all2;
  function all2(node2) {
    var key;
    for (key in test2) {
      if (node2[key] !== test2[key])
        return false;
    }
    return true;
  }
}
function anyFactory$1(tests2) {
  var checks2 = [];
  var index2 = -1;
  while (++index2 < tests2.length) {
    checks2[index2] = convert$1(tests2[index2]);
  }
  return any;
  function any() {
    var index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, arguments)) {
        return true;
      }
    }
    return false;
  }
}
function typeFactory$1(test2) {
  return type2;
  function type2(node2) {
    return Boolean(node2 && node2.type === test2);
  }
}
function ok$1() {
  return true;
}
var color_1 = color;
function color(d) {
  return "\x1B[33m" + d + "\x1B[39m";
}
var unistUtilVisitParents = visitParents;
var CONTINUE$1 = true;
var SKIP$1 = "skip";
var EXIT$1 = false;
visitParents.CONTINUE = CONTINUE$1;
visitParents.SKIP = SKIP$1;
visitParents.EXIT = EXIT$1;
function visitParents(tree, test2, visitor, reverse) {
  var step;
  var is2;
  if (typeof test2 === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test2;
    test2 = null;
  }
  is2 = convert_1(test2);
  step = reverse ? -1 : 1;
  factory2(tree, null, [])();
  function factory2(node2, index2, parents) {
    var value2 = typeof node2 === "object" && node2 !== null ? node2 : {};
    var name2;
    if (typeof value2.type === "string") {
      name2 = typeof value2.tagName === "string" ? value2.tagName : typeof value2.name === "string" ? value2.name : void 0;
      visit2.displayName = "node (" + color_1(value2.type + (name2 ? "<" + name2 + ">" : "")) + ")";
    }
    return visit2;
    function visit2() {
      var grandparents = parents.concat(node2);
      var result = [];
      var subresult;
      var offset2;
      if (!test2 || is2(node2, index2, parents[parents.length - 1] || null)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT$1) {
          return result;
        }
      }
      if (node2.children && result[0] !== SKIP$1) {
        offset2 = (reverse ? node2.children.length : -1) + step;
        while (offset2 > -1 && offset2 < node2.children.length) {
          subresult = factory2(node2.children[offset2], offset2, grandparents)();
          if (subresult[0] === EXIT$1) {
            return subresult;
          }
          offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step;
        }
      }
      return result;
    }
  }
}
function toResult(value2) {
  if (value2 !== null && typeof value2 === "object" && "length" in value2) {
    return value2;
  }
  if (typeof value2 === "number") {
    return [CONTINUE$1, value2];
  }
  return [value2];
}
var unistUtilVisit = visit;
var CONTINUE = unistUtilVisitParents.CONTINUE;
var SKIP = unistUtilVisitParents.SKIP;
var EXIT = unistUtilVisitParents.EXIT;
visit.CONTINUE = CONTINUE;
visit.SKIP = SKIP;
visit.EXIT = EXIT;
function visit(tree, test2, visitor, reverse) {
  if (typeof test2 === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test2;
    test2 = null;
  }
  unistUtilVisitParents(tree, test2, overload, reverse);
  function overload(node2, parents) {
    var parent = parents[parents.length - 1];
    var index2 = parent ? parent.children.indexOf(node2) : null;
    return visitor(node2, index2, parent);
  }
}
var unistUtilRemovePosition = removePosition;
function removePosition(node2, force) {
  unistUtilVisit(node2, force ? hard : soft);
  return node2;
}
function hard(node2) {
  delete node2.position;
}
function soft(node2) {
  node2.position = void 0;
}
var parse_1$2 = parse$6;
var lineFeed$i = "\n";
var lineBreaksExpression = /\r\n|\r/g;
function parse$6() {
  var self2 = this;
  var value2 = String(self2.file);
  var start2 = { line: 1, column: 1, offset: 0 };
  var content = immutable(start2);
  var node2;
  value2 = value2.replace(lineBreaksExpression, lineFeed$i);
  if (value2.charCodeAt(0) === 65279) {
    value2 = value2.slice(1);
    content.column++;
    content.offset++;
  }
  node2 = {
    type: "root",
    children: self2.tokenizeBlock(value2, content),
    position: { start: start2, end: self2.eof || immutable(start2) }
  };
  if (!self2.options.position) {
    unistUtilRemovePosition(node2, true);
  }
  return node2;
}
var reBlankLine = /^[ \t]*(\n|$)/;
var blankLine_1 = blankLine;
function blankLine(eat2, value2, silent) {
  var match;
  var subvalue = "";
  var index2 = 0;
  var length2 = value2.length;
  while (index2 < length2) {
    match = reBlankLine.exec(value2.slice(index2));
    if (match == null) {
      break;
    }
    index2 += match[0].length;
    subvalue += match[0];
  }
  if (subvalue === "") {
    return;
  }
  if (silent) {
    return true;
  }
  eat2(subvalue);
}
var res = "";
var cache;
var repeatString = repeat$1;
function repeat$1(str2, num2) {
  if (typeof str2 !== "string") {
    throw new TypeError("expected a string");
  }
  if (num2 === 1)
    return str2;
  if (num2 === 2)
    return str2 + str2;
  var max = str2.length * num2;
  if (cache !== str2 || typeof cache === "undefined") {
    cache = str2;
    res = "";
  } else if (res.length >= max) {
    return res.substr(0, max);
  }
  while (max > res.length && num2 > 1) {
    if (num2 & 1) {
      res += str2;
    }
    num2 >>= 1;
    str2 += str2;
  }
  res += str2;
  res = res.substr(0, max);
  return res;
}
var trimTrailingLines_1 = trimTrailingLines;
var line = "\n";
function trimTrailingLines(value2) {
  var val = String(value2);
  var index2 = val.length;
  while (val.charAt(--index2) === line) {
  }
  return val.slice(0, index2 + 1);
}
var codeIndented = indentedCode$1;
var lineFeed$h = "\n";
var tab$d = "	";
var space$i = " ";
var tabSize$4 = 4;
var codeIndent = repeatString(space$i, tabSize$4);
function indentedCode$1(eat2, value2, silent) {
  var index2 = -1;
  var length2 = value2.length;
  var subvalue = "";
  var content = "";
  var subvalueQueue = "";
  var contentQueue = "";
  var character;
  var blankQueue;
  var indent2;
  while (++index2 < length2) {
    character = value2.charAt(index2);
    if (indent2) {
      indent2 = false;
      subvalue += subvalueQueue;
      content += contentQueue;
      subvalueQueue = "";
      contentQueue = "";
      if (character === lineFeed$h) {
        subvalueQueue = character;
        contentQueue = character;
      } else {
        subvalue += character;
        content += character;
        while (++index2 < length2) {
          character = value2.charAt(index2);
          if (!character || character === lineFeed$h) {
            contentQueue = character;
            subvalueQueue = character;
            break;
          }
          subvalue += character;
          content += character;
        }
      }
    } else if (character === space$i && value2.charAt(index2 + 1) === character && value2.charAt(index2 + 2) === character && value2.charAt(index2 + 3) === character) {
      subvalueQueue += codeIndent;
      index2 += 3;
      indent2 = true;
    } else if (character === tab$d) {
      subvalueQueue += character;
      indent2 = true;
    } else {
      blankQueue = "";
      while (character === tab$d || character === space$i) {
        blankQueue += character;
        character = value2.charAt(++index2);
      }
      if (character !== lineFeed$h) {
        break;
      }
      subvalueQueue += blankQueue + character;
      contentQueue += character;
    }
  }
  if (content) {
    if (silent) {
      return true;
    }
    return eat2(subvalue)({
      type: "code",
      lang: null,
      meta: null,
      value: trimTrailingLines_1(content)
    });
  }
}
var codeFenced = fencedCode;
var lineFeed$g = "\n";
var tab$c = "	";
var space$h = " ";
var tilde$3 = "~";
var graveAccent$2 = "`";
var minFenceCount = 3;
var tabSize$3 = 4;
function fencedCode(eat2, value2, silent) {
  var self2 = this;
  var gfm2 = self2.options.gfm;
  var length2 = value2.length + 1;
  var index2 = 0;
  var subvalue = "";
  var fenceCount;
  var marker2;
  var character;
  var flag;
  var lang3;
  var meta2;
  var queue;
  var content;
  var exdentedContent;
  var closing2;
  var exdentedClosing;
  var indent2;
  var now2;
  if (!gfm2) {
    return;
  }
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (character !== space$h && character !== tab$c) {
      break;
    }
    subvalue += character;
    index2++;
  }
  indent2 = index2;
  character = value2.charAt(index2);
  if (character !== tilde$3 && character !== graveAccent$2) {
    return;
  }
  index2++;
  marker2 = character;
  fenceCount = 1;
  subvalue += character;
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (character !== marker2) {
      break;
    }
    subvalue += character;
    fenceCount++;
    index2++;
  }
  if (fenceCount < minFenceCount) {
    return;
  }
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (character !== space$h && character !== tab$c) {
      break;
    }
    subvalue += character;
    index2++;
  }
  flag = "";
  queue = "";
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (character === lineFeed$g || marker2 === graveAccent$2 && character === marker2) {
      break;
    }
    if (character === space$h || character === tab$c) {
      queue += character;
    } else {
      flag += queue + character;
      queue = "";
    }
    index2++;
  }
  character = value2.charAt(index2);
  if (character && character !== lineFeed$g) {
    return;
  }
  if (silent) {
    return true;
  }
  now2 = eat2.now();
  now2.column += subvalue.length;
  now2.offset += subvalue.length;
  subvalue += flag;
  flag = self2.decode.raw(self2.unescape(flag), now2);
  if (queue) {
    subvalue += queue;
  }
  queue = "";
  closing2 = "";
  exdentedClosing = "";
  content = "";
  exdentedContent = "";
  var skip = true;
  while (index2 < length2) {
    character = value2.charAt(index2);
    content += closing2;
    exdentedContent += exdentedClosing;
    closing2 = "";
    exdentedClosing = "";
    if (character !== lineFeed$g) {
      content += character;
      exdentedClosing += character;
      index2++;
      continue;
    }
    if (skip) {
      subvalue += character;
      skip = false;
    } else {
      closing2 += character;
      exdentedClosing += character;
    }
    queue = "";
    index2++;
    while (index2 < length2) {
      character = value2.charAt(index2);
      if (character !== space$h) {
        break;
      }
      queue += character;
      index2++;
    }
    closing2 += queue;
    exdentedClosing += queue.slice(indent2);
    if (queue.length >= tabSize$3) {
      continue;
    }
    queue = "";
    while (index2 < length2) {
      character = value2.charAt(index2);
      if (character !== marker2) {
        break;
      }
      queue += character;
      index2++;
    }
    closing2 += queue;
    exdentedClosing += queue;
    if (queue.length < fenceCount) {
      continue;
    }
    queue = "";
    while (index2 < length2) {
      character = value2.charAt(index2);
      if (character !== space$h && character !== tab$c) {
        break;
      }
      closing2 += character;
      exdentedClosing += character;
      index2++;
    }
    if (!character || character === lineFeed$g) {
      break;
    }
  }
  subvalue += content + closing2;
  index2 = -1;
  length2 = flag.length;
  while (++index2 < length2) {
    character = flag.charAt(index2);
    if (character === space$h || character === tab$c) {
      if (!lang3) {
        lang3 = flag.slice(0, index2);
      }
    } else if (lang3) {
      meta2 = flag.slice(index2);
      break;
    }
  }
  return eat2(subvalue)({
    type: "code",
    lang: lang3 || flag || null,
    meta: meta2 || null,
    value: exdentedContent
  });
}
var trim_1 = createCommonjsModule2(function(module, exports) {
  exports = module.exports = trim2;
  function trim2(str2) {
    return str2.replace(/^\s*|\s*$/g, "");
  }
  exports.left = function(str2) {
    return str2.replace(/^\s*/, "");
  };
  exports.right = function(str2) {
    return str2.replace(/\s*$/, "");
  };
});
trim_1.left;
trim_1.right;
var interrupt_1 = interrupt;
function interrupt(interruptors, tokenizers, ctx, parameters) {
  var length2 = interruptors.length;
  var index2 = -1;
  var interruptor;
  var config;
  while (++index2 < length2) {
    interruptor = interruptors[index2];
    config = interruptor[1] || {};
    if (config.pedantic !== void 0 && config.pedantic !== ctx.options.pedantic) {
      continue;
    }
    if (config.commonmark !== void 0 && config.commonmark !== ctx.options.commonmark) {
      continue;
    }
    if (tokenizers[interruptor[0]].apply(ctx, parameters)) {
      return true;
    }
  }
  return false;
}
var blockquote_1$1 = blockquote$1;
var lineFeed$f = "\n";
var tab$b = "	";
var space$g = " ";
var greaterThan$4 = ">";
function blockquote$1(eat2, value2, silent) {
  var self2 = this;
  var offsets = self2.offset;
  var tokenizers = self2.blockTokenizers;
  var interruptors = self2.interruptBlockquote;
  var now2 = eat2.now();
  var currentLine = now2.line;
  var length2 = value2.length;
  var values2 = [];
  var contents = [];
  var indents = [];
  var add;
  var index2 = 0;
  var character;
  var rest;
  var nextIndex2;
  var content;
  var line2;
  var startIndex;
  var prefixed;
  var exit;
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (character !== space$g && character !== tab$b) {
      break;
    }
    index2++;
  }
  if (value2.charAt(index2) !== greaterThan$4) {
    return;
  }
  if (silent) {
    return true;
  }
  index2 = 0;
  while (index2 < length2) {
    nextIndex2 = value2.indexOf(lineFeed$f, index2);
    startIndex = index2;
    prefixed = false;
    if (nextIndex2 === -1) {
      nextIndex2 = length2;
    }
    while (index2 < length2) {
      character = value2.charAt(index2);
      if (character !== space$g && character !== tab$b) {
        break;
      }
      index2++;
    }
    if (value2.charAt(index2) === greaterThan$4) {
      index2++;
      prefixed = true;
      if (value2.charAt(index2) === space$g) {
        index2++;
      }
    } else {
      index2 = startIndex;
    }
    content = value2.slice(index2, nextIndex2);
    if (!prefixed && !trim_1(content)) {
      index2 = startIndex;
      break;
    }
    if (!prefixed) {
      rest = value2.slice(index2);
      if (interrupt_1(interruptors, tokenizers, self2, [eat2, rest, true])) {
        break;
      }
    }
    line2 = startIndex === index2 ? content : value2.slice(startIndex, nextIndex2);
    indents.push(index2 - startIndex);
    values2.push(line2);
    contents.push(content);
    index2 = nextIndex2 + 1;
  }
  index2 = -1;
  length2 = indents.length;
  add = eat2(values2.join(lineFeed$f));
  while (++index2 < length2) {
    offsets[currentLine] = (offsets[currentLine] || 0) + indents[index2];
    currentLine++;
  }
  exit = self2.enterBlock();
  contents = self2.tokenizeBlock(contents.join(lineFeed$f), now2);
  exit();
  return add({ type: "blockquote", children: contents });
}
var headingAtx = atxHeading;
var lineFeed$e = "\n";
var tab$a = "	";
var space$f = " ";
var numberSign = "#";
var maxFenceCount = 6;
function atxHeading(eat2, value2, silent) {
  var self2 = this;
  var pedantic = self2.options.pedantic;
  var length2 = value2.length + 1;
  var index2 = -1;
  var now2 = eat2.now();
  var subvalue = "";
  var content = "";
  var character;
  var queue;
  var depth;
  while (++index2 < length2) {
    character = value2.charAt(index2);
    if (character !== space$f && character !== tab$a) {
      index2--;
      break;
    }
    subvalue += character;
  }
  depth = 0;
  while (++index2 <= length2) {
    character = value2.charAt(index2);
    if (character !== numberSign) {
      index2--;
      break;
    }
    subvalue += character;
    depth++;
  }
  if (depth > maxFenceCount) {
    return;
  }
  if (!depth || !pedantic && value2.charAt(index2 + 1) === numberSign) {
    return;
  }
  length2 = value2.length + 1;
  queue = "";
  while (++index2 < length2) {
    character = value2.charAt(index2);
    if (character !== space$f && character !== tab$a) {
      index2--;
      break;
    }
    queue += character;
  }
  if (!pedantic && queue.length === 0 && character && character !== lineFeed$e) {
    return;
  }
  if (silent) {
    return true;
  }
  subvalue += queue;
  queue = "";
  content = "";
  while (++index2 < length2) {
    character = value2.charAt(index2);
    if (!character || character === lineFeed$e) {
      break;
    }
    if (character !== space$f && character !== tab$a && character !== numberSign) {
      content += queue + character;
      queue = "";
      continue;
    }
    while (character === space$f || character === tab$a) {
      queue += character;
      character = value2.charAt(++index2);
    }
    if (!pedantic && content && !queue && character === numberSign) {
      content += character;
      continue;
    }
    while (character === numberSign) {
      queue += character;
      character = value2.charAt(++index2);
    }
    while (character === space$f || character === tab$a) {
      queue += character;
      character = value2.charAt(++index2);
    }
    index2--;
  }
  now2.column += subvalue.length;
  now2.offset += subvalue.length;
  subvalue += content + queue;
  return eat2(subvalue)({
    type: "heading",
    depth,
    children: self2.tokenizeInline(content, now2)
  });
}
var thematicBreak_1$1 = thematicBreak$1;
var tab$9 = "	";
var lineFeed$d = "\n";
var space$e = " ";
var asterisk$4 = "*";
var dash$7 = "-";
var underscore$6 = "_";
var maxCount = 3;
function thematicBreak$1(eat2, value2, silent) {
  var index2 = -1;
  var length2 = value2.length + 1;
  var subvalue = "";
  var character;
  var marker2;
  var markerCount;
  var queue;
  while (++index2 < length2) {
    character = value2.charAt(index2);
    if (character !== tab$9 && character !== space$e) {
      break;
    }
    subvalue += character;
  }
  if (character !== asterisk$4 && character !== dash$7 && character !== underscore$6) {
    return;
  }
  marker2 = character;
  subvalue += character;
  markerCount = 1;
  queue = "";
  while (++index2 < length2) {
    character = value2.charAt(index2);
    if (character === marker2) {
      markerCount++;
      subvalue += queue + marker2;
      queue = "";
    } else if (character === space$e) {
      queue += character;
    } else if (markerCount >= maxCount && (!character || character === lineFeed$d)) {
      subvalue += queue;
      if (silent) {
        return true;
      }
      return eat2(subvalue)({ type: "thematicBreak" });
    } else {
      return;
    }
  }
}
var getIndentation = indentation$1;
var tab$8 = "	";
var space$d = " ";
var spaceSize = 1;
var tabSize$2 = 4;
function indentation$1(value2) {
  var index2 = 0;
  var indent2 = 0;
  var character = value2.charAt(index2);
  var stops = {};
  var size;
  var lastIndent = 0;
  while (character === tab$8 || character === space$d) {
    size = character === tab$8 ? tabSize$2 : spaceSize;
    indent2 += size;
    if (size > 1) {
      indent2 = Math.floor(indent2 / size) * size;
    }
    while (lastIndent < indent2) {
      stops[++lastIndent] = index2;
    }
    character = value2.charAt(++index2);
  }
  return { indent: indent2, stops };
}
var removeIndentation = indentation;
var lineFeed$c = "\n";
var space$c = " ";
var exclamationMark$4 = "!";
function indentation(value2, maximum) {
  var values2 = value2.split(lineFeed$c);
  var position2 = values2.length + 1;
  var minIndent = Infinity;
  var matrix = [];
  var index2;
  var indentation2;
  var stops;
  values2.unshift(repeatString(space$c, maximum) + exclamationMark$4);
  while (position2--) {
    indentation2 = getIndentation(values2[position2]);
    matrix[position2] = indentation2.stops;
    if (trim_1(values2[position2]).length === 0) {
      continue;
    }
    if (indentation2.indent) {
      if (indentation2.indent > 0 && indentation2.indent < minIndent) {
        minIndent = indentation2.indent;
      }
    } else {
      minIndent = Infinity;
      break;
    }
  }
  if (minIndent !== Infinity) {
    position2 = values2.length;
    while (position2--) {
      stops = matrix[position2];
      index2 = minIndent;
      while (index2 && !(index2 in stops)) {
        index2--;
      }
      values2[position2] = values2[position2].slice(stops[index2] + 1);
    }
  }
  values2.shift();
  return values2.join(lineFeed$c);
}
var list_1$1 = list$12;
var asterisk$3 = "*";
var underscore$5 = "_";
var plusSign$2 = "+";
var dash$6 = "-";
var dot$3 = ".";
var space$b = " ";
var lineFeed$b = "\n";
var tab$7 = "	";
var rightParenthesis$3 = ")";
var lowercaseX = "x";
var tabSize$1 = 4;
var looseListItemExpression = /\n\n(?!\s*$)/;
var taskItemExpression = /^\[([ X\tx])][ \t]/;
var bulletExpression = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
var pedanticBulletExpression = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
var initialIndentExpression = /^( {1,4}|\t)?/gm;
function list$12(eat2, value2, silent) {
  var self2 = this;
  var commonmark2 = self2.options.commonmark;
  var pedantic = self2.options.pedantic;
  var tokenizers = self2.blockTokenizers;
  var interuptors = self2.interruptList;
  var index2 = 0;
  var length2 = value2.length;
  var start2 = null;
  var size;
  var queue;
  var ordered;
  var character;
  var marker2;
  var nextIndex2;
  var startIndex;
  var prefixed;
  var currentMarker;
  var content;
  var line2;
  var previousEmpty;
  var empty3;
  var items;
  var allLines;
  var emptyLines;
  var item;
  var enterTop;
  var exitBlockquote;
  var spread = false;
  var node2;
  var now2;
  var end2;
  var indented;
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (character !== tab$7 && character !== space$b) {
      break;
    }
    index2++;
  }
  character = value2.charAt(index2);
  if (character === asterisk$3 || character === plusSign$2 || character === dash$6) {
    marker2 = character;
    ordered = false;
  } else {
    ordered = true;
    queue = "";
    while (index2 < length2) {
      character = value2.charAt(index2);
      if (!isDecimal(character)) {
        break;
      }
      queue += character;
      index2++;
    }
    character = value2.charAt(index2);
    if (!queue || !(character === dot$3 || commonmark2 && character === rightParenthesis$3)) {
      return;
    }
    if (silent && queue !== "1") {
      return;
    }
    start2 = parseInt(queue, 10);
    marker2 = character;
  }
  character = value2.charAt(++index2);
  if (character !== space$b && character !== tab$7 && (pedantic || character !== lineFeed$b && character !== "")) {
    return;
  }
  if (silent) {
    return true;
  }
  index2 = 0;
  items = [];
  allLines = [];
  emptyLines = [];
  while (index2 < length2) {
    nextIndex2 = value2.indexOf(lineFeed$b, index2);
    startIndex = index2;
    prefixed = false;
    indented = false;
    if (nextIndex2 === -1) {
      nextIndex2 = length2;
    }
    size = 0;
    while (index2 < length2) {
      character = value2.charAt(index2);
      if (character === tab$7) {
        size += tabSize$1 - size % tabSize$1;
      } else if (character === space$b) {
        size++;
      } else {
        break;
      }
      index2++;
    }
    if (item && size >= item.indent) {
      indented = true;
    }
    character = value2.charAt(index2);
    currentMarker = null;
    if (!indented) {
      if (character === asterisk$3 || character === plusSign$2 || character === dash$6) {
        currentMarker = character;
        index2++;
        size++;
      } else {
        queue = "";
        while (index2 < length2) {
          character = value2.charAt(index2);
          if (!isDecimal(character)) {
            break;
          }
          queue += character;
          index2++;
        }
        character = value2.charAt(index2);
        index2++;
        if (queue && (character === dot$3 || commonmark2 && character === rightParenthesis$3)) {
          currentMarker = character;
          size += queue.length + 1;
        }
      }
      if (currentMarker) {
        character = value2.charAt(index2);
        if (character === tab$7) {
          size += tabSize$1 - size % tabSize$1;
          index2++;
        } else if (character === space$b) {
          end2 = index2 + tabSize$1;
          while (index2 < end2) {
            if (value2.charAt(index2) !== space$b) {
              break;
            }
            index2++;
            size++;
          }
          if (index2 === end2 && value2.charAt(index2) === space$b) {
            index2 -= tabSize$1 - 1;
            size -= tabSize$1 - 1;
          }
        } else if (character !== lineFeed$b && character !== "") {
          currentMarker = null;
        }
      }
    }
    if (currentMarker) {
      if (!pedantic && marker2 !== currentMarker) {
        break;
      }
      prefixed = true;
    } else {
      if (!commonmark2 && !indented && value2.charAt(startIndex) === space$b) {
        indented = true;
      } else if (commonmark2 && item) {
        indented = size >= item.indent || size > tabSize$1;
      }
      prefixed = false;
      index2 = startIndex;
    }
    line2 = value2.slice(startIndex, nextIndex2);
    content = startIndex === index2 ? line2 : value2.slice(index2, nextIndex2);
    if (currentMarker === asterisk$3 || currentMarker === underscore$5 || currentMarker === dash$6) {
      if (tokenizers.thematicBreak.call(self2, eat2, line2, true)) {
        break;
      }
    }
    previousEmpty = empty3;
    empty3 = !prefixed && !trim_1(content).length;
    if (indented && item) {
      item.value = item.value.concat(emptyLines, line2);
      allLines = allLines.concat(emptyLines, line2);
      emptyLines = [];
    } else if (prefixed) {
      if (emptyLines.length !== 0) {
        spread = true;
        item.value.push("");
        item.trail = emptyLines.concat();
      }
      item = {
        value: [line2],
        indent: size,
        trail: []
      };
      items.push(item);
      allLines = allLines.concat(emptyLines, line2);
      emptyLines = [];
    } else if (empty3) {
      if (previousEmpty && !commonmark2) {
        break;
      }
      emptyLines.push(line2);
    } else {
      if (previousEmpty) {
        break;
      }
      if (interrupt_1(interuptors, tokenizers, self2, [eat2, line2, true])) {
        break;
      }
      item.value = item.value.concat(emptyLines, line2);
      allLines = allLines.concat(emptyLines, line2);
      emptyLines = [];
    }
    index2 = nextIndex2 + 1;
  }
  node2 = eat2(allLines.join(lineFeed$b)).reset({
    type: "list",
    ordered,
    start: start2,
    spread,
    children: []
  });
  enterTop = self2.enterList();
  exitBlockquote = self2.enterBlock();
  index2 = -1;
  length2 = items.length;
  while (++index2 < length2) {
    item = items[index2].value.join(lineFeed$b);
    now2 = eat2.now();
    eat2(item)(listItem$2(self2, item, now2), node2);
    item = items[index2].trail.join(lineFeed$b);
    if (index2 !== length2 - 1) {
      item += lineFeed$b;
    }
    eat2(item);
  }
  enterTop();
  exitBlockquote();
  return node2;
}
function listItem$2(ctx, value2, position2) {
  var offsets = ctx.offset;
  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;
  var checked = null;
  var task;
  var indent2;
  value2 = fn.apply(null, arguments);
  if (ctx.options.gfm) {
    task = value2.match(taskItemExpression);
    if (task) {
      indent2 = task[0].length;
      checked = task[1].toLowerCase() === lowercaseX;
      offsets[position2.line] += indent2;
      value2 = value2.slice(indent2);
    }
  }
  return {
    type: "listItem",
    spread: looseListItemExpression.test(value2),
    checked,
    children: ctx.tokenizeBlock(value2, position2)
  };
}
function pedanticListItem(ctx, value2, position2) {
  var offsets = ctx.offset;
  var line2 = position2.line;
  value2 = value2.replace(pedanticBulletExpression, replacer);
  line2 = position2.line;
  return value2.replace(initialIndentExpression, replacer);
  function replacer($0) {
    offsets[line2] = (offsets[line2] || 0) + $0.length;
    line2++;
    return "";
  }
}
function normalListItem(ctx, value2, position2) {
  var offsets = ctx.offset;
  var line2 = position2.line;
  var max;
  var bullet2;
  var rest;
  var lines;
  var trimmedLines;
  var index2;
  var length2;
  value2 = value2.replace(bulletExpression, replacer);
  lines = value2.split(lineFeed$b);
  trimmedLines = removeIndentation(value2, getIndentation(max).indent).split(lineFeed$b);
  trimmedLines[0] = rest;
  offsets[line2] = (offsets[line2] || 0) + bullet2.length;
  line2++;
  index2 = 0;
  length2 = lines.length;
  while (++index2 < length2) {
    offsets[line2] = (offsets[line2] || 0) + lines[index2].length - trimmedLines[index2].length;
    line2++;
  }
  return trimmedLines.join(lineFeed$b);
  function replacer($0, $1, $2, $3, $4) {
    bullet2 = $1 + $2 + $3;
    rest = $4;
    if (Number($2) < 10 && bullet2.length % 2 === 1) {
      $2 = space$b + $2;
    }
    max = $1 + repeatString(space$b, $2.length) + $3;
    return max + rest;
  }
}
var headingSetext = setextHeading;
var lineFeed$a = "\n";
var tab$6 = "	";
var space$a = " ";
var equalsTo$1 = "=";
var dash$5 = "-";
var maxIndent = 3;
var equalsToDepth = 1;
var dashDepth = 2;
function setextHeading(eat2, value2, silent) {
  var self2 = this;
  var now2 = eat2.now();
  var length2 = value2.length;
  var index2 = -1;
  var subvalue = "";
  var content;
  var queue;
  var character;
  var marker2;
  var depth;
  while (++index2 < length2) {
    character = value2.charAt(index2);
    if (character !== space$a || index2 >= maxIndent) {
      index2--;
      break;
    }
    subvalue += character;
  }
  content = "";
  queue = "";
  while (++index2 < length2) {
    character = value2.charAt(index2);
    if (character === lineFeed$a) {
      index2--;
      break;
    }
    if (character === space$a || character === tab$6) {
      queue += character;
    } else {
      content += queue + character;
      queue = "";
    }
  }
  now2.column += subvalue.length;
  now2.offset += subvalue.length;
  subvalue += content + queue;
  character = value2.charAt(++index2);
  marker2 = value2.charAt(++index2);
  if (character !== lineFeed$a || marker2 !== equalsTo$1 && marker2 !== dash$5) {
    return;
  }
  subvalue += character;
  queue = marker2;
  depth = marker2 === equalsTo$1 ? equalsToDepth : dashDepth;
  while (++index2 < length2) {
    character = value2.charAt(index2);
    if (character !== marker2) {
      if (character !== lineFeed$a) {
        return;
      }
      index2--;
      break;
    }
    queue += character;
  }
  if (silent) {
    return true;
  }
  return eat2(subvalue + queue)({
    type: "heading",
    depth,
    children: self2.tokenizeInline(content, now2)
  });
}
var attributeName$2 = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted$2 = "[^\"'=<>`\\u0000-\\u0020]+";
var singleQuoted$2 = "'[^']*'";
var doubleQuoted$2 = '"[^"]*"';
var attributeValue$2 = "(?:" + unquoted$2 + "|" + singleQuoted$2 + "|" + doubleQuoted$2 + ")";
var attribute$2 = "(?:\\s+" + attributeName$2 + "(?:\\s*=\\s*" + attributeValue$2 + ")?)";
var openTag$1 = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute$2 + "*\\s*\\/?>";
var closeTag$1 = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var comment$1 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var processing = "<[?].*?[?]>";
var declaration = "<![A-Za-z]+\\s+[^>]*>";
var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var openCloseTag$2 = new RegExp("^(?:" + openTag$1 + "|" + closeTag$1 + ")");
var tag$2 = new RegExp(
  "^(?:" + openTag$1 + "|" + closeTag$1 + "|" + comment$1 + "|" + processing + "|" + declaration + "|" + cdata + ")"
);
var html$4 = {
  openCloseTag: openCloseTag$2,
  tag: tag$2
};
var openCloseTag$1 = html$4.openCloseTag;
var htmlBlock = blockHtml$1;
var tab$5 = "	";
var space$9 = " ";
var lineFeed$9 = "\n";
var lessThan$7 = "<";
var rawOpenExpression$1 = /^<(script|pre|style)(?=(\s|>|$))/i;
var rawCloseExpression$1 = /<\/(script|pre|style)>/i;
var commentOpenExpression$1 = /^<!--/;
var commentCloseExpression$1 = /-->/;
var instructionOpenExpression$1 = /^<\?/;
var instructionCloseExpression$1 = /\?>/;
var directiveOpenExpression$1 = /^<![A-Za-z]/;
var directiveCloseExpression$1 = />/;
var cdataOpenExpression$1 = /^<!\[CDATA\[/;
var cdataCloseExpression$1 = /]]>/;
var elementCloseExpression$1 = /^$/;
var otherElementOpenExpression$1 = new RegExp(openCloseTag$1.source + "\\s*$");
function blockHtml$1(eat2, value2, silent) {
  var self2 = this;
  var blocks = self2.options.blocks.join("|");
  var elementOpenExpression = new RegExp(
    "^</?(" + blocks + ")(?=(\\s|/?>|$))",
    "i"
  );
  var length2 = value2.length;
  var index2 = 0;
  var next;
  var line2;
  var offset2;
  var character;
  var count;
  var sequence2;
  var subvalue;
  var sequences = [
    [rawOpenExpression$1, rawCloseExpression$1, true],
    [commentOpenExpression$1, commentCloseExpression$1, true],
    [instructionOpenExpression$1, instructionCloseExpression$1, true],
    [directiveOpenExpression$1, directiveCloseExpression$1, true],
    [cdataOpenExpression$1, cdataCloseExpression$1, true],
    [elementOpenExpression, elementCloseExpression$1, true],
    [otherElementOpenExpression$1, elementCloseExpression$1, false]
  ];
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (character !== tab$5 && character !== space$9) {
      break;
    }
    index2++;
  }
  if (value2.charAt(index2) !== lessThan$7) {
    return;
  }
  next = value2.indexOf(lineFeed$9, index2 + 1);
  next = next === -1 ? length2 : next;
  line2 = value2.slice(index2, next);
  offset2 = -1;
  count = sequences.length;
  while (++offset2 < count) {
    if (sequences[offset2][0].test(line2)) {
      sequence2 = sequences[offset2];
      break;
    }
  }
  if (!sequence2) {
    return;
  }
  if (silent) {
    return sequence2[2];
  }
  index2 = next;
  if (!sequence2[1].test(line2)) {
    while (index2 < length2) {
      next = value2.indexOf(lineFeed$9, index2 + 1);
      next = next === -1 ? length2 : next;
      line2 = value2.slice(index2 + 1, next);
      if (sequence2[1].test(line2)) {
        if (line2) {
          index2 = next;
        }
        break;
      }
      index2 = next;
    }
  }
  subvalue = value2.slice(0, index2);
  return eat2(subvalue)({ type: "html", value: subvalue });
}
var isWhitespaceCharacter = whitespace$1;
var fromCode$1 = String.fromCharCode;
var re$2 = /\s/;
function whitespace$1(character) {
  return re$2.test(
    typeof character === "number" ? fromCode$1(character) : character.charAt(0)
  );
}
var collapseWhiteSpace = collapse;
function collapse(value2) {
  return String(value2).replace(/\s+/g, " ");
}
var normalize_1$1 = normalize$1;
function normalize$1(value2) {
  return collapseWhiteSpace(value2).toLowerCase();
}
var definition_1 = definition;
var quotationMark$2 = '"';
var apostrophe$3 = "'";
var backslash$6 = "\\";
var lineFeed$8 = "\n";
var tab$4 = "	";
var space$8 = " ";
var leftSquareBracket$2 = "[";
var rightSquareBracket$2 = "]";
var leftParenthesis$1 = "(";
var rightParenthesis$2 = ")";
var colon$2 = ":";
var lessThan$6 = "<";
var greaterThan$3 = ">";
function definition(eat2, value2, silent) {
  var self2 = this;
  var commonmark2 = self2.options.commonmark;
  var index2 = 0;
  var length2 = value2.length;
  var subvalue = "";
  var beforeURL;
  var beforeTitle;
  var queue;
  var character;
  var test2;
  var identifier;
  var url2;
  var title;
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (character !== space$8 && character !== tab$4) {
      break;
    }
    subvalue += character;
    index2++;
  }
  character = value2.charAt(index2);
  if (character !== leftSquareBracket$2) {
    return;
  }
  index2++;
  subvalue += character;
  queue = "";
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (character === rightSquareBracket$2) {
      break;
    } else if (character === backslash$6) {
      queue += character;
      index2++;
      character = value2.charAt(index2);
    }
    queue += character;
    index2++;
  }
  if (!queue || value2.charAt(index2) !== rightSquareBracket$2 || value2.charAt(index2 + 1) !== colon$2) {
    return;
  }
  identifier = queue;
  subvalue += queue + rightSquareBracket$2 + colon$2;
  index2 = subvalue.length;
  queue = "";
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (character !== tab$4 && character !== space$8 && character !== lineFeed$8) {
      break;
    }
    subvalue += character;
    index2++;
  }
  character = value2.charAt(index2);
  queue = "";
  beforeURL = subvalue;
  if (character === lessThan$6) {
    index2++;
    while (index2 < length2) {
      character = value2.charAt(index2);
      if (!isEnclosedURLCharacter(character)) {
        break;
      }
      queue += character;
      index2++;
    }
    character = value2.charAt(index2);
    if (character === isEnclosedURLCharacter.delimiter) {
      subvalue += lessThan$6 + queue + character;
      index2++;
    } else {
      if (commonmark2) {
        return;
      }
      index2 -= queue.length + 1;
      queue = "";
    }
  }
  if (!queue) {
    while (index2 < length2) {
      character = value2.charAt(index2);
      if (!isUnclosedURLCharacter(character)) {
        break;
      }
      queue += character;
      index2++;
    }
    subvalue += queue;
  }
  if (!queue) {
    return;
  }
  url2 = queue;
  queue = "";
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (character !== tab$4 && character !== space$8 && character !== lineFeed$8) {
      break;
    }
    queue += character;
    index2++;
  }
  character = value2.charAt(index2);
  test2 = null;
  if (character === quotationMark$2) {
    test2 = quotationMark$2;
  } else if (character === apostrophe$3) {
    test2 = apostrophe$3;
  } else if (character === leftParenthesis$1) {
    test2 = rightParenthesis$2;
  }
  if (!test2) {
    queue = "";
    index2 = subvalue.length;
  } else if (queue) {
    subvalue += queue + character;
    index2 = subvalue.length;
    queue = "";
    while (index2 < length2) {
      character = value2.charAt(index2);
      if (character === test2) {
        break;
      }
      if (character === lineFeed$8) {
        index2++;
        character = value2.charAt(index2);
        if (character === lineFeed$8 || character === test2) {
          return;
        }
        queue += lineFeed$8;
      }
      queue += character;
      index2++;
    }
    character = value2.charAt(index2);
    if (character !== test2) {
      return;
    }
    beforeTitle = subvalue;
    subvalue += queue + character;
    index2++;
    title = queue;
    queue = "";
  } else {
    return;
  }
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (character !== tab$4 && character !== space$8) {
      break;
    }
    subvalue += character;
    index2++;
  }
  character = value2.charAt(index2);
  if (!character || character === lineFeed$8) {
    if (silent) {
      return true;
    }
    beforeURL = eat2(beforeURL).test().end;
    url2 = self2.decode.raw(self2.unescape(url2), beforeURL, { nonTerminated: false });
    if (title) {
      beforeTitle = eat2(beforeTitle).test().end;
      title = self2.decode.raw(self2.unescape(title), beforeTitle);
    }
    return eat2(subvalue)({
      type: "definition",
      identifier: normalize_1$1(identifier),
      label: identifier,
      title: title || null,
      url: url2
    });
  }
}
function isEnclosedURLCharacter(character) {
  return character !== greaterThan$3 && character !== leftSquareBracket$2 && character !== rightSquareBracket$2;
}
isEnclosedURLCharacter.delimiter = greaterThan$3;
function isUnclosedURLCharacter(character) {
  return character !== leftSquareBracket$2 && character !== rightSquareBracket$2 && !isWhitespaceCharacter(character);
}
var table_1$1 = table$1;
var tab$3 = "	";
var lineFeed$7 = "\n";
var space$7 = " ";
var dash$4 = "-";
var colon$1 = ":";
var backslash$5 = "\\";
var verticalBar = "|";
var minColumns = 1;
var minRows = 2;
var left = "left";
var center = "center";
var right = "right";
function table$1(eat2, value2, silent) {
  var self2 = this;
  var index2;
  var alignments;
  var alignment;
  var subvalue;
  var row;
  var length2;
  var lines;
  var queue;
  var character;
  var hasDash;
  var align;
  var cell;
  var preamble;
  var now2;
  var position2;
  var lineCount;
  var line2;
  var rows;
  var table2;
  var lineIndex;
  var pipeIndex;
  var first2;
  if (!self2.options.gfm) {
    return;
  }
  index2 = 0;
  lineCount = 0;
  length2 = value2.length + 1;
  lines = [];
  while (index2 < length2) {
    lineIndex = value2.indexOf(lineFeed$7, index2);
    pipeIndex = value2.indexOf(verticalBar, index2 + 1);
    if (lineIndex === -1) {
      lineIndex = value2.length;
    }
    if (pipeIndex === -1 || pipeIndex > lineIndex) {
      if (lineCount < minRows) {
        return;
      }
      break;
    }
    lines.push(value2.slice(index2, lineIndex));
    lineCount++;
    index2 = lineIndex + 1;
  }
  subvalue = lines.join(lineFeed$7);
  alignments = lines.splice(1, 1)[0] || [];
  index2 = 0;
  length2 = alignments.length;
  lineCount--;
  alignment = false;
  align = [];
  while (index2 < length2) {
    character = alignments.charAt(index2);
    if (character === verticalBar) {
      hasDash = null;
      if (alignment === false) {
        if (first2 === false) {
          return;
        }
      } else {
        align.push(alignment);
        alignment = false;
      }
      first2 = false;
    } else if (character === dash$4) {
      hasDash = true;
      alignment = alignment || null;
    } else if (character === colon$1) {
      if (alignment === left) {
        alignment = center;
      } else if (hasDash && alignment === null) {
        alignment = right;
      } else {
        alignment = left;
      }
    } else if (!isWhitespaceCharacter(character)) {
      return;
    }
    index2++;
  }
  if (alignment !== false) {
    align.push(alignment);
  }
  if (align.length < minColumns) {
    return;
  }
  if (silent) {
    return true;
  }
  position2 = -1;
  rows = [];
  table2 = eat2(subvalue).reset({ type: "table", align, children: rows });
  while (++position2 < lineCount) {
    line2 = lines[position2];
    row = { type: "tableRow", children: [] };
    if (position2) {
      eat2(lineFeed$7);
    }
    eat2(line2).reset(row, table2);
    length2 = line2.length + 1;
    index2 = 0;
    queue = "";
    cell = "";
    preamble = true;
    while (index2 < length2) {
      character = line2.charAt(index2);
      if (character === tab$3 || character === space$7) {
        if (cell) {
          queue += character;
        } else {
          eat2(character);
        }
        index2++;
        continue;
      }
      if (character === "" || character === verticalBar) {
        if (preamble) {
          eat2(character);
        } else {
          if ((cell || character) && !preamble) {
            subvalue = cell;
            if (queue.length > 1) {
              if (character) {
                subvalue += queue.slice(0, -1);
                queue = queue.charAt(queue.length - 1);
              } else {
                subvalue += queue;
                queue = "";
              }
            }
            now2 = eat2.now();
            eat2(subvalue)(
              { type: "tableCell", children: self2.tokenizeInline(cell, now2) },
              row
            );
          }
          eat2(queue + character);
          queue = "";
          cell = "";
        }
      } else {
        if (queue) {
          cell += queue;
          queue = "";
        }
        cell += character;
        if (character === backslash$5 && index2 !== length2 - 2) {
          cell += line2.charAt(index2 + 1);
          index2++;
        }
      }
      preamble = false;
      index2++;
    }
    if (!position2) {
      eat2(lineFeed$7 + alignments);
    }
  }
  return table2;
}
var paragraph_1$1 = paragraph$1;
var tab$2 = "	";
var lineFeed$6 = "\n";
var space$6 = " ";
var tabSize = 4;
function paragraph$1(eat2, value2, silent) {
  var self2 = this;
  var settings = self2.options;
  var commonmark2 = settings.commonmark;
  var tokenizers = self2.blockTokenizers;
  var interruptors = self2.interruptParagraph;
  var index2 = value2.indexOf(lineFeed$6);
  var length2 = value2.length;
  var position2;
  var subvalue;
  var character;
  var size;
  var now2;
  while (index2 < length2) {
    if (index2 === -1) {
      index2 = length2;
      break;
    }
    if (value2.charAt(index2 + 1) === lineFeed$6) {
      break;
    }
    if (commonmark2) {
      size = 0;
      position2 = index2 + 1;
      while (position2 < length2) {
        character = value2.charAt(position2);
        if (character === tab$2) {
          size = tabSize;
          break;
        } else if (character === space$6) {
          size++;
        } else {
          break;
        }
        position2++;
      }
      if (size >= tabSize && character !== lineFeed$6) {
        index2 = value2.indexOf(lineFeed$6, index2 + 1);
        continue;
      }
    }
    subvalue = value2.slice(index2 + 1);
    if (interrupt_1(interruptors, tokenizers, self2, [eat2, subvalue, true])) {
      break;
    }
    position2 = index2;
    index2 = value2.indexOf(lineFeed$6, index2 + 1);
    if (index2 !== -1 && trim_1(value2.slice(position2, index2)) === "") {
      index2 = position2;
      break;
    }
  }
  subvalue = value2.slice(0, index2);
  if (silent) {
    return true;
  }
  now2 = eat2.now();
  subvalue = trimTrailingLines_1(subvalue);
  return eat2(subvalue)({
    type: "paragraph",
    children: self2.tokenizeInline(subvalue, now2)
  });
}
var _escape$1 = locate$9;
function locate$9(value2, fromIndex) {
  return value2.indexOf("\\", fromIndex);
}
var _escape = escape$1;
escape$1.locator = _escape$1;
var lineFeed$5 = "\n";
var backslash$4 = "\\";
function escape$1(eat2, value2, silent) {
  var self2 = this;
  var character;
  var node2;
  if (value2.charAt(0) === backslash$4) {
    character = value2.charAt(1);
    if (self2.escape.indexOf(character) !== -1) {
      if (silent) {
        return true;
      }
      if (character === lineFeed$5) {
        node2 = { type: "break" };
      } else {
        node2 = { type: "text", value: character };
      }
      return eat2(backslash$4 + character)(node2);
    }
  }
}
var tag$1 = locate$8;
function locate$8(value2, fromIndex) {
  return value2.indexOf("<", fromIndex);
}
var autoLink_1 = autoLink;
autoLink.locator = tag$1;
autoLink.notInLink = true;
var lessThan$5 = "<";
var greaterThan$2 = ">";
var atSign$1 = "@";
var slash$3 = "/";
var mailto = "mailto:";
var mailtoLength = mailto.length;
function autoLink(eat2, value2, silent) {
  var self2 = this;
  var subvalue = "";
  var length2 = value2.length;
  var index2 = 0;
  var queue = "";
  var hasAtCharacter = false;
  var link2 = "";
  var character;
  var now2;
  var content;
  var tokenizers;
  var exit;
  if (value2.charAt(0) !== lessThan$5) {
    return;
  }
  index2++;
  subvalue = lessThan$5;
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (isWhitespaceCharacter(character) || character === greaterThan$2 || character === atSign$1 || character === ":" && value2.charAt(index2 + 1) === slash$3) {
      break;
    }
    queue += character;
    index2++;
  }
  if (!queue) {
    return;
  }
  link2 += queue;
  queue = "";
  character = value2.charAt(index2);
  link2 += character;
  index2++;
  if (character === atSign$1) {
    hasAtCharacter = true;
  } else {
    if (character !== ":" || value2.charAt(index2 + 1) !== slash$3) {
      return;
    }
    link2 += slash$3;
    index2++;
  }
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (isWhitespaceCharacter(character) || character === greaterThan$2) {
      break;
    }
    queue += character;
    index2++;
  }
  character = value2.charAt(index2);
  if (!queue || character !== greaterThan$2) {
    return;
  }
  if (silent) {
    return true;
  }
  link2 += queue;
  content = link2;
  subvalue += link2 + character;
  now2 = eat2.now();
  now2.column++;
  now2.offset++;
  if (hasAtCharacter) {
    if (link2.slice(0, mailtoLength).toLowerCase() === mailto) {
      content = content.slice(mailtoLength);
      now2.column += mailtoLength;
      now2.offset += mailtoLength;
    } else {
      link2 = mailto + link2;
    }
  }
  tokenizers = self2.inlineTokenizers;
  self2.inlineTokenizers = { text: tokenizers.text };
  exit = self2.enterLink();
  content = self2.tokenizeInline(content, now2);
  self2.inlineTokenizers = tokenizers;
  exit();
  return eat2(subvalue)({
    type: "link",
    title: null,
    url: parseEntities_1(link2, { nonTerminated: false }),
    children: content
  });
}
var ccount_1 = ccount;
function ccount(value2, character) {
  var val = String(value2);
  var count = 0;
  var index2;
  if (typeof character !== "string" || character.length !== 1) {
    throw new Error("Expected character");
  }
  index2 = val.indexOf(character);
  while (index2 !== -1) {
    count++;
    index2 = val.indexOf(character, index2 + 1);
  }
  return count;
}
var url$1 = locate$7;
var values = ["www.", "http://", "https://"];
function locate$7(value2, fromIndex) {
  var min = -1;
  var index2;
  var length2;
  var position2;
  if (!this.options.gfm) {
    return min;
  }
  length2 = values.length;
  index2 = -1;
  while (++index2 < length2) {
    position2 = value2.indexOf(values[index2], fromIndex);
    if (position2 !== -1 && (min === -1 || position2 < min)) {
      min = position2;
    }
  }
  return min;
}
var url_1 = url;
url.locator = url$1;
url.notInLink = true;
var exclamationMark$3 = 33;
var ampersand = 38;
var rightParenthesis$1 = 41;
var asterisk$2 = 42;
var comma$1 = 44;
var dash$3 = 45;
var dot$2 = 46;
var colon = 58;
var semicolon = 59;
var questionMark$1 = 63;
var lessThan$4 = 60;
var underscore$4 = 95;
var tilde$2 = 126;
var leftParenthesisCharacter = "(";
var rightParenthesisCharacter = ")";
function url(eat2, value2, silent) {
  var self2 = this;
  var gfm2 = self2.options.gfm;
  var tokenizers = self2.inlineTokenizers;
  var length2 = value2.length;
  var previousDot = -1;
  var protocolless = false;
  var dots;
  var lastTwoPartsStart;
  var start2;
  var index2;
  var pathStart;
  var path2;
  var code2;
  var end2;
  var leftCount;
  var rightCount;
  var content;
  var children;
  var url2;
  var exit;
  if (!gfm2) {
    return;
  }
  if (value2.slice(0, 4) === "www.") {
    protocolless = true;
    index2 = 4;
  } else if (value2.slice(0, 7).toLowerCase() === "http://") {
    index2 = 7;
  } else if (value2.slice(0, 8).toLowerCase() === "https://") {
    index2 = 8;
  } else {
    return;
  }
  previousDot = index2 - 1;
  start2 = index2;
  dots = [];
  while (index2 < length2) {
    code2 = value2.charCodeAt(index2);
    if (code2 === dot$2) {
      if (previousDot === index2 - 1) {
        break;
      }
      dots.push(index2);
      previousDot = index2;
      index2++;
      continue;
    }
    if (isDecimal(code2) || isAlphabetical(code2) || code2 === dash$3 || code2 === underscore$4) {
      index2++;
      continue;
    }
    break;
  }
  if (code2 === dot$2) {
    dots.pop();
    index2--;
  }
  if (dots[0] === void 0) {
    return;
  }
  lastTwoPartsStart = dots.length < 2 ? start2 : dots[dots.length - 2] + 1;
  if (value2.slice(lastTwoPartsStart, index2).indexOf("_") !== -1) {
    return;
  }
  if (silent) {
    return true;
  }
  end2 = index2;
  pathStart = index2;
  while (index2 < length2) {
    code2 = value2.charCodeAt(index2);
    if (isWhitespaceCharacter(code2) || code2 === lessThan$4) {
      break;
    }
    index2++;
    if (code2 === exclamationMark$3 || code2 === asterisk$2 || code2 === comma$1 || code2 === dot$2 || code2 === colon || code2 === questionMark$1 || code2 === underscore$4 || code2 === tilde$2)
      ;
    else {
      end2 = index2;
    }
  }
  index2 = end2;
  if (value2.charCodeAt(index2 - 1) === rightParenthesis$1) {
    path2 = value2.slice(pathStart, index2);
    leftCount = ccount_1(path2, leftParenthesisCharacter);
    rightCount = ccount_1(path2, rightParenthesisCharacter);
    while (rightCount > leftCount) {
      index2 = pathStart + path2.lastIndexOf(rightParenthesisCharacter);
      path2 = value2.slice(pathStart, index2);
      rightCount--;
    }
  }
  if (value2.charCodeAt(index2 - 1) === semicolon) {
    index2--;
    if (isAlphabetical(value2.charCodeAt(index2 - 1))) {
      end2 = index2 - 2;
      while (isAlphabetical(value2.charCodeAt(end2))) {
        end2--;
      }
      if (value2.charCodeAt(end2) === ampersand) {
        index2 = end2;
      }
    }
  }
  content = value2.slice(0, index2);
  url2 = parseEntities_1(content, { nonTerminated: false });
  if (protocolless) {
    url2 = "http://" + url2;
  }
  exit = self2.enterLink();
  self2.inlineTokenizers = { text: tokenizers.text };
  children = self2.tokenizeInline(content, eat2.now());
  self2.inlineTokenizers = tokenizers;
  exit();
  return eat2(content)({ type: "link", title: null, url: url2, children });
}
var plusSign$1 = 43;
var dash$2 = 45;
var dot$1 = 46;
var underscore$3 = 95;
var email$1 = locate$6;
function locate$6(value2, fromIndex) {
  var self2 = this;
  var at2;
  var position2;
  if (!this.options.gfm) {
    return -1;
  }
  at2 = value2.indexOf("@", fromIndex);
  if (at2 === -1) {
    return -1;
  }
  position2 = at2;
  if (position2 === fromIndex || !isGfmAtext(value2.charCodeAt(position2 - 1))) {
    return locate$6.call(self2, value2, at2 + 1);
  }
  while (position2 > fromIndex && isGfmAtext(value2.charCodeAt(position2 - 1))) {
    position2--;
  }
  return position2;
}
function isGfmAtext(code2) {
  return isDecimal(code2) || isAlphabetical(code2) || code2 === plusSign$1 || code2 === dash$2 || code2 === dot$1 || code2 === underscore$3;
}
var email_1 = email;
email.locator = email$1;
email.notInLink = true;
var plusSign = 43;
var dash$1 = 45;
var dot = 46;
var atSign = 64;
var underscore$2 = 95;
function email(eat2, value2, silent) {
  var self2 = this;
  var gfm2 = self2.options.gfm;
  var tokenizers = self2.inlineTokenizers;
  var index2 = 0;
  var length2 = value2.length;
  var firstDot = -1;
  var code2;
  var content;
  var children;
  var exit;
  if (!gfm2) {
    return;
  }
  code2 = value2.charCodeAt(index2);
  while (isDecimal(code2) || isAlphabetical(code2) || code2 === plusSign || code2 === dash$1 || code2 === dot || code2 === underscore$2) {
    code2 = value2.charCodeAt(++index2);
  }
  if (index2 === 0) {
    return;
  }
  if (code2 !== atSign) {
    return;
  }
  index2++;
  while (index2 < length2) {
    code2 = value2.charCodeAt(index2);
    if (isDecimal(code2) || isAlphabetical(code2) || code2 === dash$1 || code2 === dot || code2 === underscore$2) {
      index2++;
      if (firstDot === -1 && code2 === dot) {
        firstDot = index2;
      }
      continue;
    }
    break;
  }
  if (firstDot === -1 || firstDot === index2 || code2 === dash$1 || code2 === underscore$2) {
    return;
  }
  if (code2 === dot) {
    index2--;
  }
  content = value2.slice(0, index2);
  if (silent) {
    return true;
  }
  exit = self2.enterLink();
  self2.inlineTokenizers = { text: tokenizers.text };
  children = self2.tokenizeInline(content, eat2.now());
  self2.inlineTokenizers = tokenizers;
  exit();
  return eat2(content)({
    type: "link",
    title: null,
    url: "mailto:" + parseEntities_1(content, { nonTerminated: false }),
    children
  });
}
var tag2 = html$4.tag;
var htmlInline = inlineHTML;
inlineHTML.locator = tag$1;
var lessThan$3 = "<";
var questionMark = "?";
var exclamationMark$2 = "!";
var slash$2 = "/";
var htmlLinkOpenExpression = /^<a /i;
var htmlLinkCloseExpression = /^<\/a>/i;
function inlineHTML(eat2, value2, silent) {
  var self2 = this;
  var length2 = value2.length;
  var character;
  var subvalue;
  if (value2.charAt(0) !== lessThan$3 || length2 < 3) {
    return;
  }
  character = value2.charAt(1);
  if (!isAlphabetical(character) && character !== questionMark && character !== exclamationMark$2 && character !== slash$2) {
    return;
  }
  subvalue = value2.match(tag2);
  if (!subvalue) {
    return;
  }
  if (silent) {
    return true;
  }
  subvalue = subvalue[0];
  if (!self2.inLink && htmlLinkOpenExpression.test(subvalue)) {
    self2.inLink = true;
  } else if (self2.inLink && htmlLinkCloseExpression.test(subvalue)) {
    self2.inLink = false;
  }
  return eat2(subvalue)({ type: "html", value: subvalue });
}
var link$3 = locate$5;
function locate$5(value2, fromIndex) {
  var link2 = value2.indexOf("[", fromIndex);
  var image2 = value2.indexOf("![", fromIndex);
  if (image2 === -1) {
    return link2;
  }
  return link2 < image2 ? link2 : image2;
}
var link_1$1 = link$2;
link$2.locator = link$3;
var lineFeed$4 = "\n";
var exclamationMark$1 = "!";
var quotationMark$1 = '"';
var apostrophe$2 = "'";
var leftParenthesis = "(";
var rightParenthesis = ")";
var lessThan$2 = "<";
var greaterThan$1 = ">";
var leftSquareBracket$1 = "[";
var backslash$3 = "\\";
var rightSquareBracket$1 = "]";
var graveAccent$1 = "`";
function link$2(eat2, value2, silent) {
  var self2 = this;
  var subvalue = "";
  var index2 = 0;
  var character = value2.charAt(0);
  var pedantic = self2.options.pedantic;
  var commonmark2 = self2.options.commonmark;
  var gfm2 = self2.options.gfm;
  var closed;
  var count;
  var opening2;
  var beforeURL;
  var beforeTitle;
  var subqueue;
  var hasMarker;
  var isImage;
  var content;
  var marker2;
  var length2;
  var title;
  var depth;
  var queue;
  var url2;
  var now2;
  var exit;
  var node2;
  if (character === exclamationMark$1) {
    isImage = true;
    subvalue = character;
    character = value2.charAt(++index2);
  }
  if (character !== leftSquareBracket$1) {
    return;
  }
  if (!isImage && self2.inLink) {
    return;
  }
  subvalue += character;
  queue = "";
  index2++;
  length2 = value2.length;
  now2 = eat2.now();
  depth = 0;
  now2.column += index2;
  now2.offset += index2;
  while (index2 < length2) {
    character = value2.charAt(index2);
    subqueue = character;
    if (character === graveAccent$1) {
      count = 1;
      while (value2.charAt(index2 + 1) === graveAccent$1) {
        subqueue += character;
        index2++;
        count++;
      }
      if (!opening2) {
        opening2 = count;
      } else if (count >= opening2) {
        opening2 = 0;
      }
    } else if (character === backslash$3) {
      index2++;
      subqueue += value2.charAt(index2);
    } else if ((!opening2 || gfm2) && character === leftSquareBracket$1) {
      depth++;
    } else if ((!opening2 || gfm2) && character === rightSquareBracket$1) {
      if (depth) {
        depth--;
      } else {
        if (value2.charAt(index2 + 1) !== leftParenthesis) {
          return;
        }
        subqueue += leftParenthesis;
        closed = true;
        index2++;
        break;
      }
    }
    queue += subqueue;
    subqueue = "";
    index2++;
  }
  if (!closed) {
    return;
  }
  content = queue;
  subvalue += queue + subqueue;
  index2++;
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (!isWhitespaceCharacter(character)) {
      break;
    }
    subvalue += character;
    index2++;
  }
  character = value2.charAt(index2);
  queue = "";
  beforeURL = subvalue;
  if (character === lessThan$2) {
    index2++;
    beforeURL += lessThan$2;
    while (index2 < length2) {
      character = value2.charAt(index2);
      if (character === greaterThan$1) {
        break;
      }
      if (commonmark2 && character === lineFeed$4) {
        return;
      }
      queue += character;
      index2++;
    }
    if (value2.charAt(index2) !== greaterThan$1) {
      return;
    }
    subvalue += lessThan$2 + queue + greaterThan$1;
    url2 = queue;
    index2++;
  } else {
    character = null;
    subqueue = "";
    while (index2 < length2) {
      character = value2.charAt(index2);
      if (subqueue && (character === quotationMark$1 || character === apostrophe$2 || commonmark2 && character === leftParenthesis)) {
        break;
      }
      if (isWhitespaceCharacter(character)) {
        if (!pedantic) {
          break;
        }
        subqueue += character;
      } else {
        if (character === leftParenthesis) {
          depth++;
        } else if (character === rightParenthesis) {
          if (depth === 0) {
            break;
          }
          depth--;
        }
        queue += subqueue;
        subqueue = "";
        if (character === backslash$3) {
          queue += backslash$3;
          character = value2.charAt(++index2);
        }
        queue += character;
      }
      index2++;
    }
    subvalue += queue;
    url2 = queue;
    index2 = subvalue.length;
  }
  queue = "";
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (!isWhitespaceCharacter(character)) {
      break;
    }
    queue += character;
    index2++;
  }
  character = value2.charAt(index2);
  subvalue += queue;
  if (queue && (character === quotationMark$1 || character === apostrophe$2 || commonmark2 && character === leftParenthesis)) {
    index2++;
    subvalue += character;
    queue = "";
    marker2 = character === leftParenthesis ? rightParenthesis : character;
    beforeTitle = subvalue;
    if (commonmark2) {
      while (index2 < length2) {
        character = value2.charAt(index2);
        if (character === marker2) {
          break;
        }
        if (character === backslash$3) {
          queue += backslash$3;
          character = value2.charAt(++index2);
        }
        index2++;
        queue += character;
      }
      character = value2.charAt(index2);
      if (character !== marker2) {
        return;
      }
      title = queue;
      subvalue += queue + character;
      index2++;
      while (index2 < length2) {
        character = value2.charAt(index2);
        if (!isWhitespaceCharacter(character)) {
          break;
        }
        subvalue += character;
        index2++;
      }
    } else {
      subqueue = "";
      while (index2 < length2) {
        character = value2.charAt(index2);
        if (character === marker2) {
          if (hasMarker) {
            queue += marker2 + subqueue;
            subqueue = "";
          }
          hasMarker = true;
        } else if (!hasMarker) {
          queue += character;
        } else if (character === rightParenthesis) {
          subvalue += queue + marker2 + subqueue;
          title = queue;
          break;
        } else if (isWhitespaceCharacter(character)) {
          subqueue += character;
        } else {
          queue += marker2 + subqueue + character;
          subqueue = "";
          hasMarker = false;
        }
        index2++;
      }
    }
  }
  if (value2.charAt(index2) !== rightParenthesis) {
    return;
  }
  if (silent) {
    return true;
  }
  subvalue += rightParenthesis;
  url2 = self2.decode.raw(self2.unescape(url2), eat2(beforeURL).test().end, {
    nonTerminated: false
  });
  if (title) {
    beforeTitle = eat2(beforeTitle).test().end;
    title = self2.decode.raw(self2.unescape(title), beforeTitle);
  }
  node2 = {
    type: isImage ? "image" : "link",
    title: title || null,
    url: url2
  };
  if (isImage) {
    node2.alt = self2.decode.raw(self2.unescape(content), now2) || null;
  } else {
    exit = self2.enterLink();
    node2.children = self2.tokenizeInline(content, now2);
    exit();
  }
  return eat2(subvalue)(node2);
}
var reference_1 = reference;
reference.locator = link$3;
var link$1 = "link";
var image$2 = "image";
var shortcut = "shortcut";
var collapsed = "collapsed";
var full = "full";
var exclamationMark = "!";
var leftSquareBracket = "[";
var backslash$2 = "\\";
var rightSquareBracket = "]";
function reference(eat2, value2, silent) {
  var self2 = this;
  var commonmark2 = self2.options.commonmark;
  var character = value2.charAt(0);
  var index2 = 0;
  var length2 = value2.length;
  var subvalue = "";
  var intro = "";
  var type2 = link$1;
  var referenceType = shortcut;
  var content;
  var identifier;
  var now2;
  var node2;
  var exit;
  var queue;
  var bracketed;
  var depth;
  if (character === exclamationMark) {
    type2 = image$2;
    intro = character;
    character = value2.charAt(++index2);
  }
  if (character !== leftSquareBracket) {
    return;
  }
  index2++;
  intro += character;
  queue = "";
  depth = 0;
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (character === leftSquareBracket) {
      bracketed = true;
      depth++;
    } else if (character === rightSquareBracket) {
      if (!depth) {
        break;
      }
      depth--;
    }
    if (character === backslash$2) {
      queue += backslash$2;
      character = value2.charAt(++index2);
    }
    queue += character;
    index2++;
  }
  subvalue = queue;
  content = queue;
  character = value2.charAt(index2);
  if (character !== rightSquareBracket) {
    return;
  }
  index2++;
  subvalue += character;
  queue = "";
  if (!commonmark2) {
    while (index2 < length2) {
      character = value2.charAt(index2);
      if (!isWhitespaceCharacter(character)) {
        break;
      }
      queue += character;
      index2++;
    }
  }
  character = value2.charAt(index2);
  if (character === leftSquareBracket) {
    identifier = "";
    queue += character;
    index2++;
    while (index2 < length2) {
      character = value2.charAt(index2);
      if (character === leftSquareBracket || character === rightSquareBracket) {
        break;
      }
      if (character === backslash$2) {
        identifier += backslash$2;
        character = value2.charAt(++index2);
      }
      identifier += character;
      index2++;
    }
    character = value2.charAt(index2);
    if (character === rightSquareBracket) {
      referenceType = identifier ? full : collapsed;
      queue += identifier + character;
      index2++;
    } else {
      identifier = "";
    }
    subvalue += queue;
    queue = "";
  } else {
    if (!content) {
      return;
    }
    identifier = content;
  }
  if (referenceType !== full && bracketed) {
    return;
  }
  subvalue = intro + subvalue;
  if (type2 === link$1 && self2.inLink) {
    return null;
  }
  if (silent) {
    return true;
  }
  now2 = eat2.now();
  now2.column += intro.length;
  now2.offset += intro.length;
  identifier = referenceType === full ? identifier : content;
  node2 = {
    type: type2 + "Reference",
    identifier: normalize_1$1(identifier),
    label: identifier,
    referenceType
  };
  if (type2 === link$1) {
    exit = self2.enterLink();
    node2.children = self2.tokenizeInline(content, now2);
    exit();
  } else {
    node2.alt = self2.decode.raw(self2.unescape(content), now2) || null;
  }
  return eat2(subvalue)(node2);
}
var strong$2 = locate$4;
function locate$4(value2, fromIndex) {
  var asterisk2 = value2.indexOf("**", fromIndex);
  var underscore2 = value2.indexOf("__", fromIndex);
  if (underscore2 === -1) {
    return asterisk2;
  }
  if (asterisk2 === -1) {
    return underscore2;
  }
  return underscore2 < asterisk2 ? underscore2 : asterisk2;
}
var strong_1$1 = strong$1;
strong$1.locator = strong$2;
var backslash$1 = "\\";
var asterisk$1 = "*";
var underscore$1 = "_";
function strong$1(eat2, value2, silent) {
  var self2 = this;
  var index2 = 0;
  var character = value2.charAt(index2);
  var now2;
  var pedantic;
  var marker2;
  var queue;
  var subvalue;
  var length2;
  var previous;
  if (character !== asterisk$1 && character !== underscore$1 || value2.charAt(++index2) !== character) {
    return;
  }
  pedantic = self2.options.pedantic;
  marker2 = character;
  subvalue = marker2 + marker2;
  length2 = value2.length;
  index2++;
  queue = "";
  character = "";
  if (pedantic && isWhitespaceCharacter(value2.charAt(index2))) {
    return;
  }
  while (index2 < length2) {
    previous = character;
    character = value2.charAt(index2);
    if (character === marker2 && value2.charAt(index2 + 1) === marker2 && (!pedantic || !isWhitespaceCharacter(previous))) {
      character = value2.charAt(index2 + 2);
      if (character !== marker2) {
        if (!trim_1(queue)) {
          return;
        }
        if (silent) {
          return true;
        }
        now2 = eat2.now();
        now2.column += 2;
        now2.offset += 2;
        return eat2(subvalue + queue + subvalue)({
          type: "strong",
          children: self2.tokenizeInline(queue, now2)
        });
      }
    }
    if (!pedantic && character === backslash$1) {
      queue += character;
      character = value2.charAt(++index2);
    }
    queue += character;
    index2++;
  }
}
var isWordCharacter = wordCharacter;
var fromCode = String.fromCharCode;
var re$1 = /\w/;
function wordCharacter(character) {
  return re$1.test(
    typeof character === "number" ? fromCode(character) : character.charAt(0)
  );
}
var emphasis$2 = locate$3;
function locate$3(value2, fromIndex) {
  var asterisk2 = value2.indexOf("*", fromIndex);
  var underscore2 = value2.indexOf("_", fromIndex);
  if (underscore2 === -1) {
    return asterisk2;
  }
  if (asterisk2 === -1) {
    return underscore2;
  }
  return underscore2 < asterisk2 ? underscore2 : asterisk2;
}
var emphasis_1$1 = emphasis$1;
emphasis$1.locator = emphasis$2;
var asterisk = "*";
var underscore = "_";
var backslash = "\\";
function emphasis$1(eat2, value2, silent) {
  var self2 = this;
  var index2 = 0;
  var character = value2.charAt(index2);
  var now2;
  var pedantic;
  var marker2;
  var queue;
  var subvalue;
  var length2;
  var previous;
  if (character !== asterisk && character !== underscore) {
    return;
  }
  pedantic = self2.options.pedantic;
  subvalue = character;
  marker2 = character;
  length2 = value2.length;
  index2++;
  queue = "";
  character = "";
  if (pedantic && isWhitespaceCharacter(value2.charAt(index2))) {
    return;
  }
  while (index2 < length2) {
    previous = character;
    character = value2.charAt(index2);
    if (character === marker2 && (!pedantic || !isWhitespaceCharacter(previous))) {
      character = value2.charAt(++index2);
      if (character !== marker2) {
        if (!trim_1(queue) || previous === marker2) {
          return;
        }
        if (!pedantic && marker2 === underscore && isWordCharacter(character)) {
          queue += marker2;
          continue;
        }
        if (silent) {
          return true;
        }
        now2 = eat2.now();
        now2.column++;
        now2.offset++;
        return eat2(subvalue + queue + marker2)({
          type: "emphasis",
          children: self2.tokenizeInline(queue, now2)
        });
      }
      queue += marker2;
    }
    if (!pedantic && character === backslash) {
      queue += character;
      character = value2.charAt(++index2);
    }
    queue += character;
    index2++;
  }
}
var _delete$2 = locate$2;
function locate$2(value2, fromIndex) {
  return value2.indexOf("~~", fromIndex);
}
var _delete$1 = strikethrough$1;
strikethrough$1.locator = _delete$2;
var tilde$1 = "~";
var fence$1 = "~~";
function strikethrough$1(eat2, value2, silent) {
  var self2 = this;
  var character = "";
  var previous = "";
  var preceding = "";
  var subvalue = "";
  var index2;
  var length2;
  var now2;
  if (!self2.options.gfm || value2.charAt(0) !== tilde$1 || value2.charAt(1) !== tilde$1 || isWhitespaceCharacter(value2.charAt(2))) {
    return;
  }
  index2 = 1;
  length2 = value2.length;
  now2 = eat2.now();
  now2.column += 2;
  now2.offset += 2;
  while (++index2 < length2) {
    character = value2.charAt(index2);
    if (character === tilde$1 && previous === tilde$1 && (!preceding || !isWhitespaceCharacter(preceding))) {
      if (silent) {
        return true;
      }
      return eat2(fence$1 + subvalue + fence$1)({
        type: "delete",
        children: self2.tokenizeInline(subvalue, now2)
      });
    }
    subvalue += previous;
    preceding = previous;
    previous = character;
  }
}
var codeInline$1 = locate$1;
function locate$1(value2, fromIndex) {
  return value2.indexOf("`", fromIndex);
}
var codeInline = inlineCode$1;
inlineCode$1.locator = codeInline$1;
var lineFeed$3 = 10;
var space$5 = 32;
var graveAccent = 96;
function inlineCode$1(eat2, value2, silent) {
  var length2 = value2.length;
  var index2 = 0;
  var openingFenceEnd;
  var closingFenceStart;
  var closingFenceEnd;
  var code2;
  var next;
  var found;
  while (index2 < length2) {
    if (value2.charCodeAt(index2) !== graveAccent) {
      break;
    }
    index2++;
  }
  if (index2 === 0 || index2 === length2) {
    return;
  }
  openingFenceEnd = index2;
  next = value2.charCodeAt(index2);
  while (index2 < length2) {
    code2 = next;
    next = value2.charCodeAt(index2 + 1);
    if (code2 === graveAccent) {
      if (closingFenceStart === void 0) {
        closingFenceStart = index2;
      }
      closingFenceEnd = index2 + 1;
      if (next !== graveAccent && closingFenceEnd - closingFenceStart === openingFenceEnd) {
        found = true;
        break;
      }
    } else if (closingFenceStart !== void 0) {
      closingFenceStart = void 0;
      closingFenceEnd = void 0;
    }
    index2++;
  }
  if (!found) {
    return;
  }
  if (silent) {
    return true;
  }
  index2 = openingFenceEnd;
  length2 = closingFenceStart;
  code2 = value2.charCodeAt(index2);
  next = value2.charCodeAt(length2 - 1);
  found = false;
  if (length2 - index2 > 2 && (code2 === space$5 || code2 === lineFeed$3) && (next === space$5 || next === lineFeed$3)) {
    index2++;
    length2--;
    while (index2 < length2) {
      code2 = value2.charCodeAt(index2);
      if (code2 !== space$5 && code2 !== lineFeed$3) {
        found = true;
        break;
      }
      index2++;
    }
    if (found === true) {
      openingFenceEnd++;
      closingFenceStart--;
    }
  }
  return eat2(value2.slice(0, closingFenceEnd))({
    type: "inlineCode",
    value: value2.slice(openingFenceEnd, closingFenceStart)
  });
}
var _break$2 = locate2;
function locate2(value2, fromIndex) {
  var index2 = value2.indexOf("\n", fromIndex);
  while (index2 > fromIndex) {
    if (value2.charAt(index2 - 1) !== " ") {
      break;
    }
    index2--;
  }
  return index2;
}
var _break$1 = hardBreak$1;
hardBreak$1.locator = _break$2;
var space$4 = " ";
var lineFeed$2 = "\n";
var minBreakLength = 2;
function hardBreak$1(eat2, value2, silent) {
  var length2 = value2.length;
  var index2 = -1;
  var queue = "";
  var character;
  while (++index2 < length2) {
    character = value2.charAt(index2);
    if (character === lineFeed$2) {
      if (index2 < minBreakLength) {
        return;
      }
      if (silent) {
        return true;
      }
      queue += character;
      return eat2(queue)({ type: "break" });
    }
    if (character !== space$4) {
      return;
    }
    queue += character;
  }
}
var text_1$2 = text$3;
function text$3(eat2, value2, silent) {
  var self2 = this;
  var methods;
  var tokenizers;
  var index2;
  var length2;
  var subvalue;
  var position2;
  var tokenizer4;
  var name2;
  var min;
  var now2;
  if (silent) {
    return true;
  }
  methods = self2.inlineMethods;
  length2 = methods.length;
  tokenizers = self2.inlineTokenizers;
  index2 = -1;
  min = value2.length;
  while (++index2 < length2) {
    name2 = methods[index2];
    if (name2 === "text" || !tokenizers[name2]) {
      continue;
    }
    tokenizer4 = tokenizers[name2].locator;
    if (!tokenizer4) {
      eat2.file.fail("Missing locator: `" + name2 + "`");
    }
    position2 = tokenizer4.call(self2, value2, 1);
    if (position2 !== -1 && position2 < min) {
      min = position2;
    }
  }
  subvalue = value2.slice(0, min);
  now2 = eat2.now();
  self2.decode(subvalue, now2, handler);
  function handler(content, position3, source) {
    eat2(source || content)({ type: "text", value: content });
  }
}
var parser$12 = Parser3;
function Parser3(doc, file) {
  this.file = file;
  this.offset = {};
  this.options = immutable(this.options);
  this.setOptions({});
  this.inList = false;
  this.inBlock = false;
  this.inLink = false;
  this.atStart = true;
  this.toOffset = vfileLocation(file).toOffset;
  this.unescape = _unescape(this, "escape");
  this.decode = decode(this);
}
var proto$3 = Parser3.prototype;
proto$3.setOptions = setOptions_1;
proto$3.parse = parse_1$2;
proto$3.options = defaults$1;
proto$3.exitStart = stateToggle("atStart", true);
proto$3.enterList = stateToggle("inList", false);
proto$3.enterLink = stateToggle("inLink", false);
proto$3.enterBlock = stateToggle("inBlock", false);
proto$3.interruptParagraph = [
  ["thematicBreak"],
  ["list"],
  ["atxHeading"],
  ["fencedCode"],
  ["blockquote"],
  ["html"],
  ["setextHeading", { commonmark: false }],
  ["definition", { commonmark: false }]
];
proto$3.interruptList = [
  ["atxHeading", { pedantic: false }],
  ["fencedCode", { pedantic: false }],
  ["thematicBreak", { pedantic: false }],
  ["definition", { commonmark: false }]
];
proto$3.interruptBlockquote = [
  ["indentedCode", { commonmark: true }],
  ["fencedCode", { commonmark: true }],
  ["atxHeading", { commonmark: true }],
  ["setextHeading", { commonmark: true }],
  ["thematicBreak", { commonmark: true }],
  ["html", { commonmark: true }],
  ["list", { commonmark: true }],
  ["definition", { commonmark: false }]
];
proto$3.blockTokenizers = {
  blankLine: blankLine_1,
  indentedCode: codeIndented,
  fencedCode: codeFenced,
  blockquote: blockquote_1$1,
  atxHeading: headingAtx,
  thematicBreak: thematicBreak_1$1,
  list: list_1$1,
  setextHeading: headingSetext,
  html: htmlBlock,
  definition: definition_1,
  table: table_1$1,
  paragraph: paragraph_1$1
};
proto$3.inlineTokenizers = {
  escape: _escape,
  autoLink: autoLink_1,
  url: url_1,
  email: email_1,
  html: htmlInline,
  link: link_1$1,
  reference: reference_1,
  strong: strong_1$1,
  emphasis: emphasis_1$1,
  deletion: _delete$1,
  code: codeInline,
  break: _break$1,
  text: text_1$2
};
proto$3.blockMethods = keys$1(proto$3.blockTokenizers);
proto$3.inlineMethods = keys$1(proto$3.inlineTokenizers);
proto$3.tokenizeBlock = tokenizer$1("block");
proto$3.tokenizeInline = tokenizer$1("inline");
proto$3.tokenizeFactory = tokenizer$1;
function keys$1(value2) {
  var result = [];
  var key;
  for (key in value2) {
    result.push(key);
  }
  return result;
}
var remarkParse = parse$5;
parse$5.Parser = parser$12;
function parse$5(options2) {
  var settings = this.data("settings");
  var Local = unherit_1(parser$12);
  Local.prototype.options = immutable(Local.prototype.options, settings, options2);
  this.Parser = Local;
}
var mdastUtilDefinitions$1 = getDefinitionFactory$1;
var own$a = {}.hasOwnProperty;
function getDefinitionFactory$1(node2, options2) {
  return getterFactory$1(gather$1(node2, options2));
}
function gather$1(node2, options2) {
  var cache2 = {};
  if (!node2 || !node2.type) {
    throw new Error("mdast-util-definitions expected node");
  }
  unistUtilVisit(node2, "definition", options2 && options2.commonmark ? commonmark2 : normal);
  return cache2;
  function commonmark2(definition2) {
    var id2 = normalise$1(definition2.identifier);
    if (!own$a.call(cache2, id2)) {
      cache2[id2] = definition2;
    }
  }
  function normal(definition2) {
    cache2[normalise$1(definition2.identifier)] = definition2;
  }
}
function getterFactory$1(cache2) {
  return getter;
  function getter(identifier) {
    var id2 = identifier && normalise$1(identifier);
    return id2 && own$a.call(cache2, id2) ? cache2[id2] : null;
  }
}
function normalise$1(identifier) {
  return identifier.toUpperCase();
}
var parse_1$1 = parse$4;
var stringify_1$1 = stringify$3;
var empty$2 = "";
var space$3 = " ";
var whiteSpace$1 = /[ \t\n\r\f]+/g;
function parse$4(value2) {
  var input = String(value2 || empty$2).trim();
  return input === empty$2 ? [] : input.split(whiteSpace$1);
}
function stringify$3(values2) {
  return values2.join(space$3).trim();
}
var spaceSeparatedTokens = {
  parse: parse_1$1,
  stringify: stringify_1$1
};
var isAbsoluteUrl = (url2) => {
  if (typeof url2 !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof url2}\``);
  }
  if (/^[a-zA-Z]:\\/.test(url2)) {
    return false;
  }
  return /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(url2);
};
var spaceSeparated$4 = spaceSeparatedTokens.parse;
var remarkExternalLinks = externalLinks;
var defaultTarget = "_blank";
var defaultRel = ["nofollow", "noopener", "noreferrer"];
var defaultProtocols = ["http", "https"];
function externalLinks(options2) {
  var settings = options2 || {};
  var target2 = settings.target;
  var rel = settings.rel;
  var protocols = settings.protocols || defaultProtocols;
  var content = settings.content;
  var contentProperties = settings.contentProperties || {};
  if (typeof rel === "string") {
    rel = spaceSeparated$4(rel);
  }
  if (content && typeof content === "object" && !("length" in content)) {
    content = [content];
  }
  return transform2;
  function transform2(tree) {
    var definition2 = mdastUtilDefinitions$1(tree);
    unistUtilVisit(tree, ["link", "linkReference"], visitor);
    function visitor(node2) {
      var ctx = node2.type === "link" ? node2 : definition2(node2.identifier);
      var protocol;
      var data3;
      var props;
      if (!ctx)
        return;
      protocol = ctx.url.slice(0, ctx.url.indexOf(":"));
      if (isAbsoluteUrl(ctx.url) && protocols.indexOf(protocol) !== -1) {
        data3 = node2.data || (node2.data = {});
        props = data3.hProperties || (data3.hProperties = {});
        if (target2 !== false) {
          props.target = target2 || defaultTarget;
        }
        if (rel !== false) {
          props.rel = (rel || defaultRel).concat();
        }
        if (content) {
          node2.children.push({
            type: "fragment",
            children: [],
            data: {
              hName: "span",
              hProperties: extend$2(true, contentProperties),
              hChildren: extend$2(true, content)
            }
          });
        }
      }
    }
  }
}
var format = createCommonjsModule2(function(module) {
  (function() {
    var namespace;
    {
      namespace = module.exports = format2;
    }
    namespace.format = format2;
    namespace.vsprintf = vsprintf;
    if (typeof console !== "undefined" && typeof console.log === "function") {
      namespace.printf = printf;
    }
    function printf() {
      console.log(format2.apply(null, arguments));
    }
    function vsprintf(fmt, replacements) {
      return format2.apply(null, [fmt].concat(replacements));
    }
    function format2(fmt) {
      var argIndex = 1, args = [].slice.call(arguments), i = 0, n2 = fmt.length, result = "", c2, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
        return args[argIndex++];
      }, slurpNumber = function() {
        var digits = "";
        while (/\d/.test(fmt[i])) {
          digits += fmt[i++];
          c2 = fmt[i];
        }
        return digits.length > 0 ? parseInt(digits) : null;
      };
      for (; i < n2; ++i) {
        c2 = fmt[i];
        if (escaped) {
          escaped = false;
          if (c2 == ".") {
            leadingZero = false;
            c2 = fmt[++i];
          } else if (c2 == "0" && fmt[i + 1] == ".") {
            leadingZero = true;
            i += 2;
            c2 = fmt[i];
          } else {
            leadingZero = true;
          }
          precision = slurpNumber();
          switch (c2) {
            case "b":
              result += parseInt(nextArg(), 10).toString(2);
              break;
            case "c":
              arg = nextArg();
              if (typeof arg === "string" || arg instanceof String)
                result += arg;
              else
                result += String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
              result += parseInt(nextArg(), 10);
              break;
            case "f":
              tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
              result += leadingZero ? tmp : tmp.replace(/^0/, "");
              break;
            case "j":
              result += JSON.stringify(nextArg());
              break;
            case "o":
              result += "0" + parseInt(nextArg(), 10).toString(8);
              break;
            case "s":
              result += nextArg();
              break;
            case "x":
              result += "0x" + parseInt(nextArg(), 10).toString(16);
              break;
            case "X":
              result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
              break;
            default:
              result += c2;
              break;
          }
        } else if (c2 === "%") {
          escaped = true;
        } else {
          result += c2;
        }
      }
      return result;
    }
  })();
});
var fault = create$3(Error);
var fault_1 = fault;
fault.eval = create$3(EvalError);
fault.range = create$3(RangeError);
fault.reference = create$3(ReferenceError);
fault.syntax = create$3(SyntaxError);
fault.type = create$3(TypeError);
fault.uri = create$3(URIError);
fault.create = create$3;
function create$3(EConstructor) {
  FormattedError.displayName = EConstructor.displayName || EConstructor.name;
  return FormattedError;
  function FormattedError(format$1) {
    if (format$1) {
      format$1 = format.apply(null, arguments);
    }
    return new EConstructor(format$1);
  }
}
var matters_1 = matters;
var own$9 = {}.hasOwnProperty;
var markers = {
  yaml: "-",
  toml: "+"
};
function matters(options2) {
  var results = [];
  var index2 = -1;
  var length2;
  if (typeof options2 === "string" || !("length" in options2)) {
    options2 = [options2];
  }
  length2 = options2.length;
  while (++index2 < length2) {
    results[index2] = matter(options2[index2]);
  }
  return results;
}
function matter(option2) {
  var result = option2;
  if (typeof result === "string") {
    if (!own$9.call(markers, result)) {
      throw fault_1("Missing matter definition for `%s`", result);
    }
    result = { type: result, marker: markers[result] };
  } else if (typeof result !== "object") {
    throw fault_1("Expected matter to be an object, not `%j`", result);
  }
  if (!own$9.call(result, "type")) {
    throw fault_1("Missing `type` in matter `%j`", result);
  }
  if (!own$9.call(result, "fence") && !own$9.call(result, "marker")) {
    throw fault_1("Missing `marker` or `fence` in matter `%j`", result);
  }
  return result;
}
var fence_1 = fence;
function fence(matter2, prop2) {
  var marker2;
  if (matter2.marker) {
    marker2 = pick(matter2.marker, prop2);
    return marker2 + marker2 + marker2;
  }
  return pick(matter2.fence, prop2);
}
function pick(schema2, prop2) {
  return typeof schema2 === "string" ? schema2 : schema2[prop2];
}
var parse$32 = create$2;
function create$2(matter2) {
  var name2 = matter2.type + "FrontMatter";
  var open = fence_1(matter2, "open");
  var close = fence_1(matter2, "close");
  var newline2 = "\n";
  var anywhere = matter2.anywhere;
  frontmatter2.displayName = name2;
  frontmatter2.onlyAtStart = typeof anywhere === "boolean" ? !anywhere : true;
  return [name2, frontmatter2];
  function frontmatter2(eat2, value2, silent) {
    var index2 = open.length;
    var offset2;
    if (value2.slice(0, index2) !== open || value2.charAt(index2) !== newline2) {
      return;
    }
    offset2 = value2.indexOf(close, index2);
    while (offset2 !== -1 && value2.charAt(offset2 - 1) !== newline2) {
      index2 = offset2 + close.length;
      offset2 = value2.indexOf(close, index2);
    }
    if (offset2 !== -1) {
      if (silent) {
        return true;
      }
      return eat2(value2.slice(0, offset2 + close.length))({
        type: matter2.type,
        value: value2.slice(open.length + 1, offset2 - 1)
      });
    }
  }
}
var compile = create$1;
function create$1(matter2) {
  var type2 = matter2.type;
  var open = fence_1(matter2, "open");
  var close = fence_1(matter2, "close");
  frontmatter2.displayName = type2 + "FrontMatter";
  return [type2, frontmatter2];
  function frontmatter2(node2) {
    return open + (node2.value ? "\n" + node2.value : "") + "\n" + close;
  }
}
var remarkFrontmatter = frontmatter;
function frontmatter(options2) {
  var parser3 = this.Parser;
  var compiler2 = this.Compiler;
  var config = matters_1(options2 || ["yaml"]);
  if (isRemarkParser(parser3)) {
    attachParser(parser3, config);
  }
  if (isRemarkCompiler(compiler2)) {
    attachCompiler(compiler2, config);
  }
}
function attachParser(parser3, matters2) {
  var proto2 = parser3.prototype;
  var tokenizers = wrap$1(parse$32, matters2);
  var names2 = [];
  var key;
  for (key in tokenizers) {
    names2.push(key);
  }
  proto2.blockMethods = names2.concat(proto2.blockMethods);
  proto2.blockTokenizers = Object.assign({}, tokenizers, proto2.blockTokenizers);
}
function attachCompiler(compiler2, matters2) {
  var proto2 = compiler2.prototype;
  proto2.visitors = Object.assign({}, wrap$1(compile, matters2), proto2.visitors);
}
function wrap$1(func, matters2) {
  var result = {};
  var length2 = matters2.length;
  var index2 = -1;
  var tuple;
  while (++index2 < length2) {
    tuple = func(matters2[index2]);
    result[tuple[0]] = tuple[1];
  }
  return result;
}
function isRemarkParser(parser3) {
  return Boolean(parser3 && parser3.prototype && parser3.prototype.blockTokenizers);
}
function isRemarkCompiler(compiler2) {
  return Boolean(compiler2 && compiler2.prototype && compiler2.prototype.visitors);
}
var unistBuilder = u;
function u(type2, props, value2) {
  var node2;
  if ((value2 === null || value2 === void 0) && (typeof props !== "object" || Array.isArray(props))) {
    value2 = props;
    props = {};
  }
  node2 = Object.assign({ type: String(type2) }, props);
  if (Array.isArray(value2)) {
    node2.children = value2;
  } else if (value2 !== null && value2 !== void 0) {
    node2.value = String(value2);
  }
  return node2;
}
var start = factory$1("start");
var end = factory$1("end");
var unistUtilPosition = position;
position.start = start;
position.end = end;
function position(node2) {
  return { start: start(node2), end: end(node2) };
}
function factory$1(type2) {
  point2.displayName = type2;
  return point2;
  function point2(node2) {
    var point3 = node2 && node2.position && node2.position[type2] || {};
    return {
      line: point3.line || null,
      column: point3.column || null,
      offset: isNaN(point3.offset) ? null : point3.offset
    };
  }
}
var unistUtilGenerated = generated;
function generated(node2) {
  var position2 = optional(optional(node2).position);
  var start2 = optional(position2.start);
  var end2 = optional(position2.end);
  return !start2.line || !start2.column || !end2.line || !end2.column;
}
function optional(value2) {
  return value2 && typeof value2 === "object" ? value2 : {};
}
var mdastUtilDefinitions = getDefinitionFactory;
var own$8 = {}.hasOwnProperty;
function getDefinitionFactory(node2, options2) {
  return getterFactory(gather(node2, options2));
}
function gather(node2, options2) {
  var cache2 = {};
  if (!node2 || !node2.type) {
    throw new Error("mdast-util-definitions expected node");
  }
  unistUtilVisit(node2, "definition", options2 && options2.commonmark ? commonmark2 : normal);
  return cache2;
  function commonmark2(definition2) {
    var id2 = normalise(definition2.identifier);
    if (!own$8.call(cache2, id2)) {
      cache2[id2] = definition2;
    }
  }
  function normal(definition2) {
    cache2[normalise(definition2.identifier)] = definition2;
  }
}
function getterFactory(cache2) {
  return getter;
  function getter(identifier) {
    var id2 = identifier && normalise(identifier);
    return id2 && own$8.call(cache2, id2) ? cache2[id2] : null;
  }
}
function normalise(identifier) {
  return identifier.toUpperCase();
}
var all_1$1 = all$2;
function all$2(h, parent) {
  var nodes = parent.children || [];
  var length2 = nodes.length;
  var values2 = [];
  var index2 = -1;
  var result;
  var head2;
  while (++index2 < length2) {
    result = one_1$1(h, nodes[index2], parent);
    if (result) {
      if (index2 && nodes[index2 - 1].type === "break") {
        if (result.value) {
          result.value = result.value.replace(/^\s+/, "");
        }
        head2 = result.children && result.children[0];
        if (head2 && head2.value) {
          head2.value = head2.value.replace(/^\s+/, "");
        }
      }
      values2 = values2.concat(result);
    }
  }
  return values2;
}
var one_1$1 = one$2;
var own$7 = {}.hasOwnProperty;
function unknown(h, node2) {
  if (text$2(node2)) {
    return h.augment(node2, unistBuilder("text", node2.value));
  }
  return h(node2, "div", all_1$1(h, node2));
}
function one$2(h, node2, parent) {
  var type2 = node2 && node2.type;
  var fn = own$7.call(h.handlers, type2) ? h.handlers[type2] : h.unknownHandler;
  if (!type2) {
    throw new Error("Expected node, got `" + node2 + "`");
  }
  return (typeof fn === "function" ? fn : unknown)(h, node2, parent);
}
function text$2(node2) {
  var data3 = node2.data || {};
  if (own$7.call(data3, "hName") || own$7.call(data3, "hProperties") || own$7.call(data3, "hChildren")) {
    return false;
  }
  return "value" in node2;
}
var thematicBreak_1 = thematicBreak;
function thematicBreak(h, node2) {
  return h(node2, "hr");
}
var wrap_1 = wrap;
function wrap(nodes, loose) {
  var result = [];
  var index2 = -1;
  var length2 = nodes.length;
  if (loose) {
    result.push(unistBuilder("text", "\n"));
  }
  while (++index2 < length2) {
    if (index2) {
      result.push(unistBuilder("text", "\n"));
    }
    result.push(nodes[index2]);
  }
  if (loose && nodes.length !== 0) {
    result.push(unistBuilder("text", "\n"));
  }
  return result;
}
var list_1 = list;
function list(h, node2) {
  var props = {};
  var name2 = node2.ordered ? "ol" : "ul";
  var items;
  var index2 = -1;
  var length2;
  if (typeof node2.start === "number" && node2.start !== 1) {
    props.start = node2.start;
  }
  items = all_1$1(h, node2);
  length2 = items.length;
  while (++index2 < length2) {
    if (items[index2].properties.className && items[index2].properties.className.indexOf("task-list-item") !== -1) {
      props.className = ["contains-task-list"];
      break;
    }
  }
  return h(node2, name2, props, wrap_1(items, true));
}
var footer = generateFootnotes;
function generateFootnotes(h) {
  var footnoteById = h.footnoteById;
  var footnoteOrder = h.footnoteOrder;
  var length2 = footnoteOrder.length;
  var index2 = -1;
  var listItems = [];
  var def;
  var backReference;
  var content;
  var tail;
  while (++index2 < length2) {
    def = footnoteById[footnoteOrder[index2].toUpperCase()];
    if (!def) {
      continue;
    }
    content = def.children.concat();
    tail = content[content.length - 1];
    backReference = {
      type: "link",
      url: "#fnref-" + def.identifier,
      data: { hProperties: { className: ["footnote-backref"] } },
      children: [{ type: "text", value: "\u21A9" }]
    };
    if (!tail || tail.type !== "paragraph") {
      tail = { type: "paragraph", children: [] };
      content.push(tail);
    }
    tail.children.push(backReference);
    listItems.push({
      type: "listItem",
      data: { hProperties: { id: "fn-" + def.identifier } },
      children: content,
      position: def.position
    });
  }
  if (listItems.length === 0) {
    return null;
  }
  return h(
    null,
    "div",
    { className: ["footnotes"] },
    wrap_1(
      [
        thematicBreak_1(h),
        list_1(h, { type: "list", ordered: true, children: listItems })
      ],
      true
    )
  );
}
var blockquote_1 = blockquote;
function blockquote(h, node2) {
  return h(node2, "blockquote", wrap_1(all_1$1(h, node2), true));
}
var _break = hardBreak;
function hardBreak(h, node2) {
  return [h(node2, "br"), unistBuilder("text", "\n")];
}
var detab_1 = detab;
var tab$1 = 9;
var lineFeed$1 = 10;
var carriageReturn = 13;
function detab(value2, size) {
  var string = typeof value2 === "string";
  var length2 = string && value2.length;
  var start2 = 0;
  var index2 = -1;
  var column = -1;
  var tabSize2 = size || 4;
  var results = [];
  var code2;
  var add;
  if (!string) {
    throw new Error("detab expected string");
  }
  while (++index2 < length2) {
    code2 = value2.charCodeAt(index2);
    if (code2 === tab$1) {
      add = tabSize2 - (column + 1) % tabSize2;
      column += add;
      results.push(value2.slice(start2, index2) + repeatString(" ", add));
      start2 = index2 + 1;
    } else if (code2 === lineFeed$1 || code2 === carriageReturn) {
      column = -1;
    } else {
      column++;
    }
  }
  results.push(value2.slice(start2));
  return results.join("");
}
var code_1 = code;
function code(h, node2) {
  var value2 = node2.value ? detab_1(node2.value + "\n") : "";
  var lang3 = node2.lang && node2.lang.match(/^[^ \t]+(?=[ \t]|$)/);
  var props = {};
  if (lang3) {
    props.className = ["language-" + lang3];
  }
  return h(node2.position, "pre", [h(node2, "code", props, [unistBuilder("text", value2)])]);
}
var _delete = strikethrough;
function strikethrough(h, node2) {
  return h(node2, "del", all_1$1(h, node2));
}
var emphasis_1 = emphasis;
function emphasis(h, node2) {
  return h(node2, "em", all_1$1(h, node2));
}
var footnoteReference_1 = footnoteReference;
function footnoteReference(h, node2) {
  var footnoteOrder = h.footnoteOrder;
  var identifier = String(node2.identifier);
  if (footnoteOrder.indexOf(identifier) === -1) {
    footnoteOrder.push(identifier);
  }
  return h(node2.position, "sup", { id: "fnref-" + identifier }, [
    h(node2, "a", { href: "#fn-" + identifier, className: ["footnote-ref"] }, [
      unistBuilder("text", node2.label || identifier)
    ])
  ]);
}
var footnote_1 = footnote;
function footnote(h, node2) {
  var footnoteById = h.footnoteById;
  var footnoteOrder = h.footnoteOrder;
  var identifier = 1;
  while (identifier in footnoteById) {
    identifier++;
  }
  identifier = String(identifier);
  footnoteOrder.push(identifier);
  footnoteById[identifier] = {
    type: "footnoteDefinition",
    identifier,
    children: [{ type: "paragraph", children: node2.children }],
    position: node2.position
  };
  return footnoteReference_1(h, {
    type: "footnoteReference",
    identifier,
    position: node2.position
  });
}
var heading_1 = heading;
function heading(h, node2) {
  return h(node2, "h" + node2.depth, all_1$1(h, node2));
}
var html_1$1 = html$3;
function html$3(h, node2) {
  return h.dangerous ? h.augment(node2, unistBuilder("raw", node2.value)) : null;
}
var encodeCache = {};
function getEncodeCache(exclude) {
  var i, ch, cache2 = encodeCache[exclude];
  if (cache2) {
    return cache2;
  }
  cache2 = encodeCache[exclude] = [];
  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache2.push(ch);
    } else {
      cache2.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (i = 0; i < exclude.length; i++) {
    cache2[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache2;
}
function encode$1(string, exclude, keepEscaped) {
  var i, l2, code2, nextCode, cache2, result = "";
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode$1.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  cache2 = getEncodeCache(exclude);
  for (i = 0, l2 = string.length; i < l2; i++) {
    code2 = string.charCodeAt(i);
    if (keepEscaped && code2 === 37 && i + 2 < l2) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code2 < 128) {
      result += cache2[code2];
      continue;
    }
    if (code2 >= 55296 && code2 <= 57343) {
      if (code2 >= 55296 && code2 <= 56319 && i + 1 < l2) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string[i]);
  }
  return result;
}
encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode$1.componentChars = "-_.!~*'()";
var encode_1 = encode$1;
var revert_1 = revert;
function revert(h, node2) {
  var subtype = node2.referenceType;
  var suffix = "]";
  var contents;
  var head2;
  var tail;
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return unistBuilder("text", "![" + node2.alt + suffix);
  }
  contents = all_1$1(h, node2);
  head2 = contents[0];
  if (head2 && head2.type === "text") {
    head2.value = "[" + head2.value;
  } else {
    contents.unshift(unistBuilder("text", "["));
  }
  tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push(unistBuilder("text", suffix));
  }
  return contents;
}
var imageReference_1 = imageReference;
function imageReference(h, node2) {
  var def = h.definition(node2.identifier);
  var props;
  if (!def) {
    return revert_1(h, node2);
  }
  props = { src: encode_1(def.url || ""), alt: node2.alt };
  if (def.title !== null && def.title !== void 0) {
    props.title = def.title;
  }
  return h(node2, "img", props);
}
var image_1 = image$1;
function image$1(h, node2) {
  var props = { src: encode_1(node2.url), alt: node2.alt };
  if (node2.title !== null && node2.title !== void 0) {
    props.title = node2.title;
  }
  return h(node2, "img", props);
}
var inlineCode_1 = inlineCode;
function inlineCode(h, node2) {
  return h(node2, "code", [unistBuilder("text", collapseWhiteSpace(node2.value))]);
}
var linkReference_1 = linkReference;
function linkReference(h, node2) {
  var def = h.definition(node2.identifier);
  var props;
  if (!def) {
    return revert_1(h, node2);
  }
  props = { href: encode_1(def.url || "") };
  if (def.title !== null && def.title !== void 0) {
    props.title = def.title;
  }
  return h(node2, "a", props, all_1$1(h, node2));
}
var link_1 = link;
function link(h, node2) {
  var props = { href: encode_1(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    props.title = node2.title;
  }
  return h(node2, "a", props, all_1$1(h, node2));
}
var listItem_1 = listItem$1;
function listItem$1(h, node2, parent) {
  var children = node2.children;
  var head2 = children[0];
  var raw2 = all_1$1(h, node2);
  var loose = parent ? listLoose(parent) : listItemLoose(node2);
  var props = {};
  var result;
  var container;
  var index2;
  var length2;
  var child;
  if (loose) {
    result = raw2;
  } else {
    result = [];
    length2 = raw2.length;
    index2 = -1;
    while (++index2 < length2) {
      child = raw2[index2];
      if (child.tagName === "p") {
        result = result.concat(child.children);
      } else {
        result.push(child);
      }
    }
  }
  if (typeof node2.checked === "boolean") {
    if (loose && (!head2 || head2.type !== "paragraph")) {
      result.unshift(h(null, "p", []));
    }
    container = loose ? result[0].children : result;
    if (container.length !== 0) {
      container.unshift(unistBuilder("text", " "));
    }
    container.unshift(
      h(null, "input", {
        type: "checkbox",
        checked: node2.checked,
        disabled: true
      })
    );
    props.className = ["task-list-item"];
  }
  if (loose && result.length !== 0) {
    result = wrap_1(result, true);
  }
  return h(node2, "li", props, result);
}
function listLoose(node2) {
  var loose = node2.spread;
  var children = node2.children;
  var length2 = children.length;
  var index2 = -1;
  while (!loose && ++index2 < length2) {
    loose = listItemLoose(children[index2]);
  }
  return loose;
}
function listItemLoose(node2) {
  var spread = node2.spread;
  return spread === void 0 || spread === null ? node2.children.length > 1 : spread;
}
var paragraph_1 = paragraph;
function paragraph(h, node2) {
  return h(node2, "p", all_1$1(h, node2));
}
var root_1 = root;
function root(h, node2) {
  return h.augment(node2, unistBuilder("root", wrap_1(all_1$1(h, node2))));
}
var strong_1 = strong;
function strong(h, node2) {
  return h(node2, "strong", all_1$1(h, node2));
}
var table_1 = table;
function table(h, node2) {
  var rows = node2.children;
  var index2 = rows.length;
  var align = node2.align;
  var alignLength = align.length;
  var result = [];
  var pos;
  var row;
  var out;
  var name2;
  var cell;
  while (index2--) {
    row = rows[index2].children;
    name2 = index2 === 0 ? "th" : "td";
    pos = alignLength;
    out = [];
    while (pos--) {
      cell = row[pos];
      out[pos] = h(cell, name2, { align: align[pos] }, cell ? all_1$1(h, cell) : []);
    }
    result[index2] = h(rows[index2], "tr", wrap_1(out, true));
  }
  return h(
    node2,
    "table",
    wrap_1(
      [
        h(result[0].position, "thead", wrap_1([result[0]], true)),
        h(
          {
            start: unistUtilPosition.start(result[1]),
            end: unistUtilPosition.end(result[result.length - 1])
          },
          "tbody",
          wrap_1(result.slice(1), true)
        )
      ],
      true
    )
  );
}
var trimLines_1 = trimLines2;
var ws = /[ \t]*\n+[ \t]*/g;
var newline$1 = "\n";
function trimLines2(value2) {
  return String(value2).replace(ws, newline$1);
}
var text_1$1 = text$1;
function text$1(h, node2) {
  return h.augment(node2, unistBuilder("text", trimLines_1(node2.value)));
}
var handlers$1 = {
  blockquote: blockquote_1,
  break: _break,
  code: code_1,
  delete: _delete,
  emphasis: emphasis_1,
  footnoteReference: footnoteReference_1,
  footnote: footnote_1,
  heading: heading_1,
  html: html_1$1,
  imageReference: imageReference_1,
  image: image_1,
  inlineCode: inlineCode_1,
  linkReference: linkReference_1,
  link: link_1,
  listItem: listItem_1,
  list: list_1,
  paragraph: paragraph_1,
  root: root_1,
  strong: strong_1,
  table: table_1,
  text: text_1$1,
  thematicBreak: thematicBreak_1,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return null;
}
var lib$2 = toHast;
var own$6 = {}.hasOwnProperty;
var deprecationWarningIssued = false;
function factory(tree, options2) {
  var settings = options2 || {};
  if (settings.allowDangerousHTML !== void 0 && !deprecationWarningIssued) {
    deprecationWarningIssued = true;
    console.warn(
      "mdast-util-to-hast: deprecation: `allowDangerousHTML` is nonstandard, use `allowDangerousHtml` instead"
    );
  }
  var dangerous2 = settings.allowDangerousHtml || settings.allowDangerousHTML;
  var footnoteById = {};
  h.dangerous = dangerous2;
  h.definition = mdastUtilDefinitions(tree, settings);
  h.footnoteById = footnoteById;
  h.footnoteOrder = [];
  h.augment = augment;
  h.handlers = Object.assign({}, handlers$1, settings.handlers);
  h.unknownHandler = settings.unknownHandler;
  unistUtilVisit(tree, "footnoteDefinition", onfootnotedefinition);
  return h;
  function augment(left2, right2) {
    var data3;
    var ctx;
    if (left2 && "data" in left2) {
      data3 = left2.data;
      if (right2.type === "element" && data3.hName) {
        right2.tagName = data3.hName;
      }
      if (right2.type === "element" && data3.hProperties) {
        right2.properties = Object.assign({}, right2.properties, data3.hProperties);
      }
      if (right2.children && data3.hChildren) {
        right2.children = data3.hChildren;
      }
    }
    ctx = left2 && left2.position ? left2 : { position: left2 };
    if (!unistUtilGenerated(ctx)) {
      right2.position = {
        start: unistUtilPosition.start(ctx),
        end: unistUtilPosition.end(ctx)
      };
    }
    return right2;
  }
  function h(node2, tagName, props, children) {
    if ((children === void 0 || children === null) && typeof props === "object" && "length" in props) {
      children = props;
      props = {};
    }
    return augment(node2, {
      type: "element",
      tagName,
      properties: props || {},
      children: children || []
    });
  }
  function onfootnotedefinition(definition2) {
    var id2 = String(definition2.identifier).toUpperCase();
    if (!own$6.call(footnoteById, id2)) {
      footnoteById[id2] = definition2;
    }
  }
}
function toHast(tree, options2) {
  var h = factory(tree, options2);
  var node2 = one_1$1(h, tree);
  var foot = footer(h);
  if (foot) {
    node2.children = node2.children.concat(unistBuilder("text", "\n"), foot);
  }
  return node2;
}
var mdastUtilToHast = lib$2;
var remarkRehype = remark2rehype;
function remark2rehype(destination, options2) {
  if (destination && !destination.process) {
    options2 = destination;
    destination = null;
  }
  return destination ? bridge(destination, options2) : mutate(options2);
}
function bridge(destination, options2) {
  return transformer;
  function transformer(node2, file, next) {
    destination.run(mdastUtilToHast(node2, options2), file, done);
    function done(err) {
      next(err);
    }
  }
}
function mutate(options2) {
  return transformer;
  function transformer(node2) {
    return mdastUtilToHast(node2, options2);
  }
}
var schema$1 = Schema$2;
var proto$2 = Schema$2.prototype;
proto$2.space = null;
proto$2.normal = {};
proto$2.property = {};
function Schema$2(property, normal, space2) {
  this.property = property;
  this.normal = normal;
  if (space2) {
    this.space = space2;
  }
}
var merge_1 = merge$1;
function merge$1(definitions) {
  var length2 = definitions.length;
  var property = [];
  var normal = [];
  var index2 = -1;
  var info2;
  var space2;
  while (++index2 < length2) {
    info2 = definitions[index2];
    property.push(info2.property);
    normal.push(info2.normal);
    space2 = info2.space;
  }
  return new schema$1(
    immutable.apply(null, property),
    immutable.apply(null, normal),
    space2
  );
}
var normalize_1 = normalize2;
function normalize2(value2) {
  return value2.toLowerCase();
}
var info = Info;
var proto$1 = Info.prototype;
proto$1.space = null;
proto$1.attribute = null;
proto$1.property = null;
proto$1.boolean = false;
proto$1.booleanish = false;
proto$1.overloadedBoolean = false;
proto$1.number = false;
proto$1.commaSeparated = false;
proto$1.spaceSeparated = false;
proto$1.commaOrSpaceSeparated = false;
proto$1.mustUseProperty = false;
proto$1.defined = false;
function Info(property, attribute2) {
  this.property = property;
  this.attribute = attribute2;
}
var powers = 0;
var boolean_1 = increment();
var booleanish$2 = increment();
var overloadedBoolean$1 = increment();
var number$3 = increment();
var spaceSeparated$3 = increment();
var commaSeparated$2 = increment();
var commaOrSpaceSeparated$1 = increment();
function increment() {
  return Math.pow(2, ++powers);
}
var types2 = {
  boolean: boolean_1,
  booleanish: booleanish$2,
  overloadedBoolean: overloadedBoolean$1,
  number: number$3,
  spaceSeparated: spaceSeparated$3,
  commaSeparated: commaSeparated$2,
  commaOrSpaceSeparated: commaOrSpaceSeparated$1
};
var definedInfo = DefinedInfo;
DefinedInfo.prototype = new info();
DefinedInfo.prototype.defined = true;
var checks = [
  "boolean",
  "booleanish",
  "overloadedBoolean",
  "number",
  "commaSeparated",
  "spaceSeparated",
  "commaOrSpaceSeparated"
];
var checksLength = checks.length;
function DefinedInfo(property, attribute2, mask, space2) {
  var index2 = -1;
  var check2;
  mark$1(this, "space", space2);
  info.call(this, property, attribute2);
  while (++index2 < checksLength) {
    check2 = checks[index2];
    mark$1(this, check2, (mask & types2[check2]) === types2[check2]);
  }
}
function mark$1(values2, key, value2) {
  if (value2) {
    values2[key] = value2;
  }
}
var create_1 = create2;
function create2(definition2) {
  var space2 = definition2.space;
  var mustUseProperty = definition2.mustUseProperty || [];
  var attributes2 = definition2.attributes || {};
  var props = definition2.properties;
  var transform2 = definition2.transform;
  var property = {};
  var normal = {};
  var prop2;
  var info2;
  for (prop2 in props) {
    info2 = new definedInfo(
      prop2,
      transform2(attributes2, prop2),
      props[prop2],
      space2
    );
    if (mustUseProperty.indexOf(prop2) !== -1) {
      info2.mustUseProperty = true;
    }
    property[prop2] = info2;
    normal[normalize_1(prop2)] = prop2;
    normal[normalize_1(info2.attribute)] = prop2;
  }
  return new schema$1(property, normal, space2);
}
var xlink = create_1({
  space: "xlink",
  transform: xlinkTransform,
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
function xlinkTransform(_, prop2) {
  return "xlink:" + prop2.slice(5).toLowerCase();
}
var xml = create_1({
  space: "xml",
  transform: xmlTransform,
  properties: {
    xmlLang: null,
    xmlBase: null,
    xmlSpace: null
  }
});
function xmlTransform(_, prop2) {
  return "xml:" + prop2.slice(3).toLowerCase();
}
var caseSensitiveTransform_1 = caseSensitiveTransform;
function caseSensitiveTransform(attributes2, attribute2) {
  return attribute2 in attributes2 ? attributes2[attribute2] : attribute2;
}
var caseInsensitiveTransform_1 = caseInsensitiveTransform;
function caseInsensitiveTransform(attributes2, property) {
  return caseSensitiveTransform_1(attributes2, property.toLowerCase());
}
var xmlns = create_1({
  space: "xmlns",
  attributes: {
    xmlnsxlink: "xmlns:xlink"
  },
  transform: caseInsensitiveTransform_1,
  properties: {
    xmlns: null,
    xmlnsXLink: null
  }
});
var booleanish$1 = types2.booleanish;
var number$2 = types2.number;
var spaceSeparated$2 = types2.spaceSeparated;
var aria = create_1({
  transform: ariaTransform,
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish$1,
    ariaAutoComplete: null,
    ariaBusy: booleanish$1,
    ariaChecked: booleanish$1,
    ariaColCount: number$2,
    ariaColIndex: number$2,
    ariaColSpan: number$2,
    ariaControls: spaceSeparated$2,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated$2,
    ariaDetails: null,
    ariaDisabled: booleanish$1,
    ariaDropEffect: spaceSeparated$2,
    ariaErrorMessage: null,
    ariaExpanded: booleanish$1,
    ariaFlowTo: spaceSeparated$2,
    ariaGrabbed: booleanish$1,
    ariaHasPopup: null,
    ariaHidden: booleanish$1,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated$2,
    ariaLevel: number$2,
    ariaLive: null,
    ariaModal: booleanish$1,
    ariaMultiLine: booleanish$1,
    ariaMultiSelectable: booleanish$1,
    ariaOrientation: null,
    ariaOwns: spaceSeparated$2,
    ariaPlaceholder: null,
    ariaPosInSet: number$2,
    ariaPressed: booleanish$1,
    ariaReadOnly: booleanish$1,
    ariaRelevant: null,
    ariaRequired: booleanish$1,
    ariaRoleDescription: spaceSeparated$2,
    ariaRowCount: number$2,
    ariaRowIndex: number$2,
    ariaRowSpan: number$2,
    ariaSelected: booleanish$1,
    ariaSetSize: number$2,
    ariaSort: null,
    ariaValueMax: number$2,
    ariaValueMin: number$2,
    ariaValueNow: number$2,
    ariaValueText: null,
    role: null
  }
});
function ariaTransform(_, prop2) {
  return prop2 === "role" ? prop2 : "aria-" + prop2.slice(4).toLowerCase();
}
var boolean$1 = types2.boolean;
var overloadedBoolean = types2.overloadedBoolean;
var booleanish = types2.booleanish;
var number$1 = types2.number;
var spaceSeparated$1 = types2.spaceSeparated;
var commaSeparated$1 = types2.commaSeparated;
var html$2 = create_1({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform_1,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    abbr: null,
    accept: commaSeparated$1,
    acceptCharset: spaceSeparated$1,
    accessKey: spaceSeparated$1,
    action: null,
    allow: null,
    allowFullScreen: boolean$1,
    allowPaymentRequest: boolean$1,
    allowUserMedia: boolean$1,
    alt: null,
    as: null,
    async: boolean$1,
    autoCapitalize: null,
    autoComplete: spaceSeparated$1,
    autoFocus: boolean$1,
    autoPlay: boolean$1,
    capture: boolean$1,
    charSet: null,
    checked: boolean$1,
    cite: null,
    className: spaceSeparated$1,
    cols: number$1,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean$1,
    controlsList: spaceSeparated$1,
    coords: number$1 | commaSeparated$1,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean$1,
    defer: boolean$1,
    dir: null,
    dirName: null,
    disabled: boolean$1,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean$1,
    formTarget: null,
    headers: spaceSeparated$1,
    height: number$1,
    hidden: boolean$1,
    high: number$1,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated$1,
    httpEquiv: spaceSeparated$1,
    id: null,
    imageSizes: null,
    imageSrcSet: commaSeparated$1,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean$1,
    itemId: null,
    itemProp: spaceSeparated$1,
    itemRef: spaceSeparated$1,
    itemScope: boolean$1,
    itemType: spaceSeparated$1,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loop: boolean$1,
    low: number$1,
    manifest: null,
    max: null,
    maxLength: number$1,
    media: null,
    method: null,
    min: null,
    minLength: number$1,
    multiple: boolean$1,
    muted: boolean$1,
    name: null,
    nonce: null,
    noModule: boolean$1,
    noValidate: boolean$1,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextMenu: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean$1,
    optimum: number$1,
    pattern: null,
    ping: spaceSeparated$1,
    placeholder: null,
    playsInline: boolean$1,
    poster: null,
    preload: null,
    readOnly: boolean$1,
    referrerPolicy: null,
    rel: spaceSeparated$1,
    required: boolean$1,
    reversed: boolean$1,
    rows: number$1,
    rowSpan: number$1,
    sandbox: spaceSeparated$1,
    scope: null,
    scoped: boolean$1,
    seamless: boolean$1,
    selected: boolean$1,
    shape: null,
    size: number$1,
    sizes: null,
    slot: null,
    span: number$1,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: commaSeparated$1,
    start: number$1,
    step: null,
    style: null,
    tabIndex: number$1,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean$1,
    useMap: null,
    value: booleanish,
    width: number$1,
    wrap: null,
    align: null,
    aLink: null,
    archive: spaceSeparated$1,
    axis: null,
    background: null,
    bgColor: null,
    border: number$1,
    borderColor: null,
    bottomMargin: number$1,
    cellPadding: null,
    cellSpacing: null,
    char: null,
    charOff: null,
    classId: null,
    clear: null,
    code: null,
    codeBase: null,
    codeType: null,
    color: null,
    compact: boolean$1,
    declare: boolean$1,
    event: null,
    face: null,
    frame: null,
    frameBorder: null,
    hSpace: number$1,
    leftMargin: number$1,
    link: null,
    longDesc: null,
    lowSrc: null,
    marginHeight: number$1,
    marginWidth: number$1,
    noResize: boolean$1,
    noHref: boolean$1,
    noShade: boolean$1,
    noWrap: boolean$1,
    object: null,
    profile: null,
    prompt: null,
    rev: null,
    rightMargin: number$1,
    rules: null,
    scheme: null,
    scrolling: booleanish,
    standby: null,
    summary: null,
    text: null,
    topMargin: number$1,
    valueType: null,
    version: null,
    vAlign: null,
    vLink: null,
    vSpace: number$1,
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean$1,
    disableRemotePlayback: boolean$1,
    prefix: null,
    property: null,
    results: number$1,
    security: null,
    unselectable: null
  }
});
var html_1 = merge_1([xml, xlink, xmlns, aria, html$2]);
var boolean = types2.boolean;
var number = types2.number;
var spaceSeparated = types2.spaceSeparated;
var commaSeparated = types2.commaSeparated;
var commaOrSpaceSeparated = types2.commaOrSpaceSeparated;
var svg = create_1({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform_1,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    keySplines: null,
    keyTimes: null,
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
var svg_1 = merge_1([xml, xlink, xmlns, aria, svg]);
var index$2 = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "menuitem",
  "meta",
  "nextid",
  "param",
  "source",
  "track",
  "wbr"
];
var htmlVoidElements = Object.freeze({
  __proto__: null,
  "default": index$2
});
var unistUtilIs = is;
function is(test2, node2, index2, parent, context2) {
  var hasParent = parent !== null && parent !== void 0;
  var hasIndex = index2 !== null && index2 !== void 0;
  var check2 = convert(test2);
  if (hasIndex && (typeof index2 !== "number" || index2 < 0 || index2 === Infinity)) {
    throw new Error("Expected positive finite index or child node");
  }
  if (hasParent && (!is(null, parent) || !parent.children)) {
    throw new Error("Expected parent node");
  }
  if (!node2 || !node2.type || typeof node2.type !== "string") {
    return false;
  }
  if (hasParent !== hasIndex) {
    throw new Error("Expected both parent and index");
  }
  return Boolean(check2.call(context2, node2, index2, parent));
}
function convert(test2) {
  if (typeof test2 === "string") {
    return typeFactory(test2);
  }
  if (test2 === null || test2 === void 0) {
    return ok;
  }
  if (typeof test2 === "object") {
    return ("length" in test2 ? anyFactory : matchesFactory)(test2);
  }
  if (typeof test2 === "function") {
    return test2;
  }
  throw new Error("Expected function, string, or object as test");
}
function convertAll(tests2) {
  var results = [];
  var length2 = tests2.length;
  var index2 = -1;
  while (++index2 < length2) {
    results[index2] = convert(tests2[index2]);
  }
  return results;
}
function matchesFactory(test2) {
  return matches2;
  function matches2(node2) {
    var key;
    for (key in test2) {
      if (node2[key] !== test2[key]) {
        return false;
      }
    }
    return true;
  }
}
function anyFactory(tests2) {
  var checks2 = convertAll(tests2);
  var length2 = checks2.length;
  return matches2;
  function matches2() {
    var index2 = -1;
    while (++index2 < length2) {
      if (checks2[index2].apply(this, arguments)) {
        return true;
      }
    }
    return false;
  }
}
function typeFactory(test2) {
  return type2;
  function type2(node2) {
    return Boolean(node2 && node2.type === test2);
  }
}
function ok() {
  return true;
}
var hastUtilIsElement = isElement;
function isElement(node2, tagNames) {
  var name2;
  if (!(tagNames === null || tagNames === void 0 || typeof tagNames === "string" || typeof tagNames === "object" && tagNames.length !== 0)) {
    throw new Error(
      "Expected `string` or `Array.<string>` for `tagNames`, not `" + tagNames + "`"
    );
  }
  if (!node2 || typeof node2 !== "object" || node2.type !== "element" || typeof node2.tagName !== "string") {
    return false;
  }
  if (tagNames === null || tagNames === void 0) {
    return true;
  }
  name2 = node2.tagName;
  if (typeof tagNames === "string") {
    return name2 === tagNames;
  }
  return tagNames.indexOf(name2) !== -1;
}
var hastUtilWhitespace = interElementWhiteSpace;
var re2 = /[ \t\n\f\r]/g;
function interElementWhiteSpace(node2) {
  var value2;
  if (node2 && typeof node2 === "object" && node2.type === "text") {
    value2 = node2.value || "";
  } else if (typeof node2 === "string") {
    value2 = node2;
  } else {
    return false;
  }
  return value2.replace(re2, "") === "";
}
var before$1 = siblings(-1);
var after$2 = siblings(1);
function siblings(increment2) {
  return sibling;
  function sibling(parent, index2, includeWhiteSpace) {
    var siblings2 = parent && parent.children;
    var next;
    index2 += increment2;
    next = siblings2 && siblings2[index2];
    if (!includeWhiteSpace) {
      while (next && hastUtilWhitespace(next)) {
        index2 += increment2;
        next = siblings2[index2];
      }
    }
    return next;
  }
}
var siblings_1 = {
  before: before$1,
  after: after$2
};
var after$1 = siblings_1.after;
var first_1 = first;
function first(parent, includeWhiteSpace) {
  return after$1(parent, -1, includeWhiteSpace);
}
var place_1 = place;
function place(parent, child) {
  return parent && parent.children && parent.children.indexOf(child);
}
var whiteSpaceLeft_1 = whiteSpaceLeft;
function whiteSpaceLeft(node2) {
  return unistUtilIs("text", node2) && hastUtilWhitespace(node2.value.charAt(0));
}
var omission_1 = omission$1;
var own$5 = {}.hasOwnProperty;
function omission$1(handlers3) {
  return omit;
  function omit(node2, index2, parent) {
    var name2 = node2.tagName;
    var fn = own$5.call(handlers3, name2) ? handlers3[name2] : false;
    return fn ? fn(node2, index2, parent) : false;
  }
}
var after = siblings_1.after;
var optionGroup = "optgroup";
var options = ["option"].concat(optionGroup);
var dataListItem = ["dt", "dd"];
var listItem = "li";
var menuContent = ["menuitem", "hr", "menu"];
var ruby = ["rp", "rt"];
var tableContainer = ["tbody", "tfoot"];
var tableRow$1 = "tr";
var tableCell = ["td", "th"];
var confusingParagraphParent = ["a", "audio", "del", "ins", "map", "noscript", "video"];
var clearParagraphSibling = [
  "address",
  "article",
  "aside",
  "blockquote",
  "details",
  "div",
  "dl",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "hr",
  "main",
  "menu",
  "nav",
  "ol",
  "p",
  "pre",
  "section",
  "table",
  "ul"
];
var closing$1 = omission_1({
  html: html$1,
  head: headOrColgroupOrCaption,
  body: body$1,
  p,
  li,
  dt,
  dd,
  rt: rubyElement,
  rp: rubyElement,
  optgroup,
  option,
  menuitem,
  colgroup: headOrColgroupOrCaption,
  caption: headOrColgroupOrCaption,
  thead,
  tbody: tbody$1,
  tfoot,
  tr,
  td: cells,
  th: cells
});
function headOrColgroupOrCaption(node2, index2, parent) {
  var next = after(parent, index2, true);
  return !next || !unistUtilIs("comment", next) && !whiteSpaceLeft_1(next);
}
function html$1(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || !unistUtilIs("comment", next);
}
function body$1(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || !unistUtilIs("comment", next);
}
function p(node2, index2, parent) {
  var next = after(parent, index2);
  return next ? hastUtilIsElement(next, clearParagraphSibling) : !parent || !hastUtilIsElement(parent, confusingParagraphParent);
}
function li(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, listItem);
}
function dt(node2, index2, parent) {
  var next = after(parent, index2);
  return next && hastUtilIsElement(next, dataListItem);
}
function dd(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, dataListItem);
}
function rubyElement(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, ruby);
}
function optgroup(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, optionGroup);
}
function option(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, options);
}
function menuitem(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, menuContent);
}
function thead(node2, index2, parent) {
  var next = after(parent, index2);
  return next && hastUtilIsElement(next, tableContainer);
}
function tbody$1(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, tableContainer);
}
function tfoot(node2, index2, parent) {
  return !after(parent, index2);
}
function tr(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, tableRow$1);
}
function cells(node2, index2, parent) {
  var next = after(parent, index2);
  return !next || hastUtilIsElement(next, tableCell);
}
var before = siblings_1.before;
var own$4 = {}.hasOwnProperty;
var uniqueHeadMetadata = ["title", "base"];
var meta = ["meta", "link", "script", "style", "template"];
var tableContainers = ["thead", "tbody"];
var tableRow = "tr";
var opening$1 = omission_1({
  html,
  head,
  body,
  colgroup,
  tbody
});
function html(node2) {
  var head2 = first_1(node2);
  return !head2 || !unistUtilIs("comment", head2);
}
function head(node2) {
  var children = node2.children;
  var length2 = children.length;
  var map2 = {};
  var index2 = -1;
  var child;
  var name2;
  while (++index2 < length2) {
    child = children[index2];
    name2 = child.tagName;
    if (hastUtilIsElement(child, uniqueHeadMetadata)) {
      if (own$4.call(map2, name2)) {
        return false;
      }
      map2[name2] = true;
    }
  }
  return Boolean(length2);
}
function body(node2) {
  var head2 = first_1(node2, true);
  return !head2 || !unistUtilIs("comment", head2) && !whiteSpaceLeft_1(head2) && !hastUtilIsElement(head2, meta);
}
function colgroup(node2, index2, parent) {
  var prev = before(parent, index2);
  var head2 = first_1(node2, true);
  if (hastUtilIsElement(prev, "colgroup") && closing$1(prev, place_1(parent, prev), parent)) {
    return false;
  }
  return head2 && hastUtilIsElement(head2, "col");
}
function tbody(node2, index2, parent) {
  var prev = before(parent, index2);
  var head2 = first_1(node2);
  if (hastUtilIsElement(prev, tableContainers) && closing$1(prev, place_1(parent, prev), parent)) {
    return false;
  }
  return head2 && hastUtilIsElement(head2, tableRow);
}
var opening = opening$1;
var closing = closing$1;
var omission = {
  opening,
  closing
};
var index$1 = [
  "script",
  "style",
  "pre",
  "textarea"
];
var htmlWhitespaceSensitiveTagNames = Object.freeze({
  __proto__: null,
  "default": index$1
});
var sensitive = getCjsExportFromNamespace(htmlWhitespaceSensitiveTagNames);
var all_1 = all$1;
function all$1(ctx, parent) {
  var children = parent && parent.children;
  var length2 = children && children.length;
  var index2 = -1;
  var results = [];
  let printWidthOffset = 0;
  let innerTextLength = 0;
  while (++index2 < length2) {
    innerTextLength = getInnerTextLength(children[index2]);
    results[index2] = one_1(ctx, children[index2], index2, parent, printWidthOffset, innerTextLength);
    printWidthOffset = results[index2].replace(/\n+/g, "").length;
  }
  return results.join("");
}
function getInnerTextLength(node2) {
  if (sensitive.indexOf(node2.tagName) !== -1) {
    return 0;
  }
  if (!node2.children || !node2.children.length) {
    return 0;
  }
  var child = node2.children[0];
  if (child.type === "text" || child.type === "comment") {
    return child.value.split("\n")[0].length;
  }
  return 0;
}
var text_1 = text2;
function text2(ctx, node2, index2, parent) {
  var value2 = node2.value;
  return value2;
}
var data2 = "data";
var find_1 = find;
var valid = /^data[-\w.:]+$/i;
var dash = /-[a-z]/g;
var cap$1 = /[A-Z]/g;
function find(schema2, value2) {
  var normal = normalize_1(value2);
  var prop2 = value2;
  var Type2 = info;
  if (normal in schema2.normal) {
    return schema2.property[schema2.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === data2 && valid.test(value2)) {
    if (value2.charAt(4) === "-") {
      prop2 = datasetToProperty(value2);
    } else {
      value2 = datasetToAttribute(value2);
    }
    Type2 = definedInfo;
  }
  return new Type2(prop2, value2);
}
function datasetToProperty(attribute2) {
  var value2 = attribute2.slice(5).replace(dash, camelcase);
  return data2 + value2.charAt(0).toUpperCase() + value2.slice(1);
}
function datasetToAttribute(property) {
  var value2 = property.slice(4);
  if (dash.test(value2)) {
    return property;
  }
  value2 = value2.replace(cap$1, kebab);
  if (value2.charAt(0) !== "-") {
    value2 = "-" + value2;
  }
  return data2 + value2;
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
var parse_1 = parse$22;
var stringify_1 = stringify$2;
var comma = ",";
var space$2 = " ";
var empty$12 = "";
function parse$22(value2) {
  var values2 = [];
  var input = String(value2 || empty$12);
  var index2 = input.indexOf(comma);
  var lastIndex = 0;
  var end2 = false;
  var val;
  while (!end2) {
    if (index2 === -1) {
      index2 = input.length;
      end2 = true;
    }
    val = input.slice(lastIndex, index2).trim();
    if (val || !end2) {
      values2.push(val);
    }
    lastIndex = index2 + 1;
    index2 = input.indexOf(comma, lastIndex);
  }
  return values2;
}
function stringify$2(values2, options2) {
  var settings = options2 || {};
  var left2 = settings.padLeft === false ? empty$12 : space$2;
  var right2 = settings.padRight ? space$2 : empty$12;
  if (values2[values2.length - 1] === empty$12) {
    values2 = values2.concat(empty$12);
  }
  return values2.join(right2 + comma + left2).trim();
}
var commaSeparatedTokens = {
  parse: parse_1,
  stringify: stringify_1
};
var nbsp = "\xA0";
var iexcl = "\xA1";
var cent = "\xA2";
var pound = "\xA3";
var curren = "\xA4";
var yen = "\xA5";
var brvbar = "\xA6";
var sect = "\xA7";
var uml = "\xA8";
var copy = "\xA9";
var ordf = "\xAA";
var laquo = "\xAB";
var not2 = "\xAC";
var shy = "\xAD";
var reg = "\xAE";
var macr = "\xAF";
var deg = "\xB0";
var plusmn = "\xB1";
var sup2 = "\xB2";
var sup3 = "\xB3";
var acute = "\xB4";
var micro = "\xB5";
var para = "\xB6";
var middot = "\xB7";
var cedil = "\xB8";
var sup1 = "\xB9";
var ordm = "\xBA";
var raquo = "\xBB";
var frac14 = "\xBC";
var frac12 = "\xBD";
var frac34 = "\xBE";
var iquest = "\xBF";
var Agrave = "\xC0";
var Aacute = "\xC1";
var Acirc = "\xC2";
var Atilde = "\xC3";
var Auml = "\xC4";
var Aring = "\xC5";
var AElig = "\xC6";
var Ccedil = "\xC7";
var Egrave = "\xC8";
var Eacute = "\xC9";
var Ecirc = "\xCA";
var Euml = "\xCB";
var Igrave = "\xCC";
var Iacute = "\xCD";
var Icirc = "\xCE";
var Iuml = "\xCF";
var ETH = "\xD0";
var Ntilde = "\xD1";
var Ograve = "\xD2";
var Oacute = "\xD3";
var Ocirc = "\xD4";
var Otilde = "\xD5";
var Ouml = "\xD6";
var times = "\xD7";
var Oslash = "\xD8";
var Ugrave = "\xD9";
var Uacute = "\xDA";
var Ucirc = "\xDB";
var Uuml = "\xDC";
var Yacute = "\xDD";
var THORN = "\xDE";
var szlig = "\xDF";
var agrave = "\xE0";
var aacute = "\xE1";
var acirc = "\xE2";
var atilde = "\xE3";
var auml = "\xE4";
var aring = "\xE5";
var aelig = "\xE6";
var ccedil = "\xE7";
var egrave = "\xE8";
var eacute = "\xE9";
var ecirc = "\xEA";
var euml = "\xEB";
var igrave = "\xEC";
var iacute = "\xED";
var icirc = "\xEE";
var iuml = "\xEF";
var eth = "\xF0";
var ntilde = "\xF1";
var ograve = "\xF2";
var oacute = "\xF3";
var ocirc = "\xF4";
var otilde = "\xF5";
var ouml = "\xF6";
var divide = "\xF7";
var oslash = "\xF8";
var ugrave = "\xF9";
var uacute = "\xFA";
var ucirc = "\xFB";
var uuml = "\xFC";
var yacute = "\xFD";
var thorn = "\xFE";
var yuml = "\xFF";
var fnof = "\u0192";
var Alpha = "\u0391";
var Beta = "\u0392";
var Gamma = "\u0393";
var Delta = "\u0394";
var Epsilon = "\u0395";
var Zeta = "\u0396";
var Eta = "\u0397";
var Theta = "\u0398";
var Iota = "\u0399";
var Kappa = "\u039A";
var Lambda = "\u039B";
var Mu = "\u039C";
var Nu = "\u039D";
var Xi = "\u039E";
var Omicron = "\u039F";
var Pi = "\u03A0";
var Rho = "\u03A1";
var Sigma = "\u03A3";
var Tau = "\u03A4";
var Upsilon = "\u03A5";
var Phi = "\u03A6";
var Chi = "\u03A7";
var Psi = "\u03A8";
var Omega = "\u03A9";
var alpha = "\u03B1";
var beta = "\u03B2";
var gamma = "\u03B3";
var delta = "\u03B4";
var epsilon = "\u03B5";
var zeta = "\u03B6";
var eta = "\u03B7";
var theta = "\u03B8";
var iota = "\u03B9";
var kappa = "\u03BA";
var lambda = "\u03BB";
var mu = "\u03BC";
var nu = "\u03BD";
var xi = "\u03BE";
var omicron = "\u03BF";
var pi = "\u03C0";
var rho = "\u03C1";
var sigmaf = "\u03C2";
var sigma = "\u03C3";
var tau = "\u03C4";
var upsilon = "\u03C5";
var phi = "\u03C6";
var chi = "\u03C7";
var psi = "\u03C8";
var omega = "\u03C9";
var thetasym = "\u03D1";
var upsih = "\u03D2";
var piv = "\u03D6";
var bull = "\u2022";
var hellip = "\u2026";
var prime = "\u2032";
var Prime = "\u2033";
var oline = "\u203E";
var frasl = "\u2044";
var weierp = "\u2118";
var image = "\u2111";
var real = "\u211C";
var trade = "\u2122";
var alefsym = "\u2135";
var larr = "\u2190";
var uarr = "\u2191";
var rarr = "\u2192";
var darr = "\u2193";
var harr = "\u2194";
var crarr = "\u21B5";
var lArr = "\u21D0";
var uArr = "\u21D1";
var rArr = "\u21D2";
var dArr = "\u21D3";
var hArr = "\u21D4";
var forall = "\u2200";
var part = "\u2202";
var exist = "\u2203";
var empty2 = "\u2205";
var nabla = "\u2207";
var isin = "\u2208";
var notin = "\u2209";
var ni = "\u220B";
var prod = "\u220F";
var sum2 = "\u2211";
var minus = "\u2212";
var lowast = "\u2217";
var radic = "\u221A";
var prop = "\u221D";
var infin = "\u221E";
var ang = "\u2220";
var and = "\u2227";
var or = "\u2228";
var cap = "\u2229";
var cup = "\u222A";
var int = "\u222B";
var there4 = "\u2234";
var sim = "\u223C";
var cong = "\u2245";
var asymp = "\u2248";
var ne = "\u2260";
var equiv = "\u2261";
var le = "\u2264";
var ge = "\u2265";
var sub = "\u2282";
var sup = "\u2283";
var nsub = "\u2284";
var sube = "\u2286";
var supe = "\u2287";
var oplus = "\u2295";
var otimes = "\u2297";
var perp = "\u22A5";
var sdot = "\u22C5";
var lceil = "\u2308";
var rceil = "\u2309";
var lfloor = "\u230A";
var rfloor = "\u230B";
var lang2 = "\u2329";
var rang = "\u232A";
var loz = "\u25CA";
var spades = "\u2660";
var clubs = "\u2663";
var hearts = "\u2665";
var diams = "\u2666";
var quot = '"';
var amp = "&";
var lt = "<";
var gt = ">";
var OElig = "\u0152";
var oelig = "\u0153";
var Scaron = "\u0160";
var scaron = "\u0161";
var Yuml = "\u0178";
var circ = "\u02C6";
var tilde = "\u02DC";
var ensp = "\u2002";
var emsp = "\u2003";
var thinsp = "\u2009";
var zwnj = "\u200C";
var zwj = "\u200D";
var lrm = "\u200E";
var rlm = "\u200F";
var ndash = "\u2013";
var mdash = "\u2014";
var lsquo = "\u2018";
var rsquo = "\u2019";
var sbquo = "\u201A";
var ldquo = "\u201C";
var rdquo = "\u201D";
var bdquo = "\u201E";
var dagger = "\u2020";
var Dagger = "\u2021";
var permil = "\u2030";
var lsaquo = "\u2039";
var rsaquo = "\u203A";
var euro = "\u20AC";
var index = {
  nbsp,
  iexcl,
  cent,
  pound,
  curren,
  yen,
  brvbar,
  sect,
  uml,
  copy,
  ordf,
  laquo,
  not: not2,
  shy,
  reg,
  macr,
  deg,
  plusmn,
  sup2,
  sup3,
  acute,
  micro,
  para,
  middot,
  cedil,
  sup1,
  ordm,
  raquo,
  frac14,
  frac12,
  frac34,
  iquest,
  Agrave,
  Aacute,
  Acirc,
  Atilde,
  Auml,
  Aring,
  AElig,
  Ccedil,
  Egrave,
  Eacute,
  Ecirc,
  Euml,
  Igrave,
  Iacute,
  Icirc,
  Iuml,
  ETH,
  Ntilde,
  Ograve,
  Oacute,
  Ocirc,
  Otilde,
  Ouml,
  times,
  Oslash,
  Ugrave,
  Uacute,
  Ucirc,
  Uuml,
  Yacute,
  THORN,
  szlig,
  agrave,
  aacute,
  acirc,
  atilde,
  auml,
  aring,
  aelig,
  ccedil,
  egrave,
  eacute,
  ecirc,
  euml,
  igrave,
  iacute,
  icirc,
  iuml,
  eth,
  ntilde,
  ograve,
  oacute,
  ocirc,
  otilde,
  ouml,
  divide,
  oslash,
  ugrave,
  uacute,
  ucirc,
  uuml,
  yacute,
  thorn,
  yuml,
  fnof,
  Alpha,
  Beta,
  Gamma,
  Delta,
  Epsilon,
  Zeta,
  Eta,
  Theta,
  Iota,
  Kappa,
  Lambda,
  Mu,
  Nu,
  Xi,
  Omicron,
  Pi,
  Rho,
  Sigma,
  Tau,
  Upsilon,
  Phi,
  Chi,
  Psi,
  Omega,
  alpha,
  beta,
  gamma,
  delta,
  epsilon,
  zeta,
  eta,
  theta,
  iota,
  kappa,
  lambda,
  mu,
  nu,
  xi,
  omicron,
  pi,
  rho,
  sigmaf,
  sigma,
  tau,
  upsilon,
  phi,
  chi,
  psi,
  omega,
  thetasym,
  upsih,
  piv,
  bull,
  hellip,
  prime,
  Prime,
  oline,
  frasl,
  weierp,
  image,
  real,
  trade,
  alefsym,
  larr,
  uarr,
  rarr,
  darr,
  harr,
  crarr,
  lArr,
  uArr,
  rArr,
  dArr,
  hArr,
  forall,
  part,
  exist,
  empty: empty2,
  nabla,
  isin,
  notin,
  ni,
  prod,
  sum: sum2,
  minus,
  lowast,
  radic,
  prop,
  infin,
  ang,
  and,
  or,
  cap,
  cup,
  int,
  there4,
  sim,
  cong,
  asymp,
  ne,
  equiv,
  le,
  ge,
  sub,
  sup,
  nsub,
  sube,
  supe,
  oplus,
  otimes,
  perp,
  sdot,
  lceil,
  rceil,
  lfloor,
  rfloor,
  lang: lang2,
  rang,
  loz,
  spades,
  clubs,
  hearts,
  diams,
  quot,
  amp,
  lt,
  gt,
  OElig,
  oelig,
  Scaron,
  scaron,
  Yuml,
  circ,
  tilde,
  ensp,
  emsp,
  thinsp,
  zwnj,
  zwj,
  lrm,
  rlm,
  ndash,
  mdash,
  lsquo,
  rsquo,
  sbquo,
  ldquo,
  rdquo,
  bdquo,
  dagger,
  Dagger,
  permil,
  lsaquo,
  rsaquo,
  euro
};
var characterEntitiesHtml4 = Object.freeze({
  __proto__: null,
  nbsp,
  iexcl,
  cent,
  pound,
  curren,
  yen,
  brvbar,
  sect,
  uml,
  copy,
  ordf,
  laquo,
  not: not2,
  shy,
  reg,
  macr,
  deg,
  plusmn,
  sup2,
  sup3,
  acute,
  micro,
  para,
  middot,
  cedil,
  sup1,
  ordm,
  raquo,
  frac14,
  frac12,
  frac34,
  iquest,
  Agrave,
  Aacute,
  Acirc,
  Atilde,
  Auml,
  Aring,
  AElig,
  Ccedil,
  Egrave,
  Eacute,
  Ecirc,
  Euml,
  Igrave,
  Iacute,
  Icirc,
  Iuml,
  ETH,
  Ntilde,
  Ograve,
  Oacute,
  Ocirc,
  Otilde,
  Ouml,
  times,
  Oslash,
  Ugrave,
  Uacute,
  Ucirc,
  Uuml,
  Yacute,
  THORN,
  szlig,
  agrave,
  aacute,
  acirc,
  atilde,
  auml,
  aring,
  aelig,
  ccedil,
  egrave,
  eacute,
  ecirc,
  euml,
  igrave,
  iacute,
  icirc,
  iuml,
  eth,
  ntilde,
  ograve,
  oacute,
  ocirc,
  otilde,
  ouml,
  divide,
  oslash,
  ugrave,
  uacute,
  ucirc,
  uuml,
  yacute,
  thorn,
  yuml,
  fnof,
  Alpha,
  Beta,
  Gamma,
  Delta,
  Epsilon,
  Zeta,
  Eta,
  Theta,
  Iota,
  Kappa,
  Lambda,
  Mu,
  Nu,
  Xi,
  Omicron,
  Pi,
  Rho,
  Sigma,
  Tau,
  Upsilon,
  Phi,
  Chi,
  Psi,
  Omega,
  alpha,
  beta,
  gamma,
  delta,
  epsilon,
  zeta,
  eta,
  theta,
  iota,
  kappa,
  lambda,
  mu,
  nu,
  xi,
  omicron,
  pi,
  rho,
  sigmaf,
  sigma,
  tau,
  upsilon,
  phi,
  chi,
  psi,
  omega,
  thetasym,
  upsih,
  piv,
  bull,
  hellip,
  prime,
  Prime,
  oline,
  frasl,
  weierp,
  image,
  real,
  trade,
  alefsym,
  larr,
  uarr,
  rarr,
  darr,
  harr,
  crarr,
  lArr,
  uArr,
  rArr,
  dArr,
  hArr,
  forall,
  part,
  exist,
  empty: empty2,
  nabla,
  isin,
  notin,
  ni,
  prod,
  sum: sum2,
  minus,
  lowast,
  radic,
  prop,
  infin,
  ang,
  and,
  or,
  cap,
  cup,
  int,
  there4,
  sim,
  cong,
  asymp,
  ne,
  equiv,
  le,
  ge,
  sub,
  sup,
  nsub,
  sube,
  supe,
  oplus,
  otimes,
  perp,
  sdot,
  lceil,
  rceil,
  lfloor,
  rfloor,
  lang: lang2,
  rang,
  loz,
  spades,
  clubs,
  hearts,
  diams,
  quot,
  amp,
  lt,
  gt,
  OElig,
  oelig,
  Scaron,
  scaron,
  Yuml,
  circ,
  tilde,
  ensp,
  emsp,
  thinsp,
  zwnj,
  zwj,
  lrm,
  rlm,
  ndash,
  mdash,
  lsquo,
  rsquo,
  sbquo,
  ldquo,
  rdquo,
  bdquo,
  dagger,
  Dagger,
  permil,
  lsaquo,
  rsaquo,
  euro,
  "default": index
});
var dangerous$1 = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
];
var dangerous$2 = Object.freeze({
  __proto__: null,
  "default": dangerous$1
});
var entities2 = getCjsExportFromNamespace(characterEntitiesHtml4);
var dangerous = getCjsExportFromNamespace(dangerous$2);
var decimal = isDecimal;
var stringifyEntities = encode2;
encode2.escape = escape;
var own$3 = {}.hasOwnProperty;
var escapes = ['"', "'", "<", ">", "&", "`"];
var characters = construct();
var defaultEscapes = toExpression(escapes);
var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var bmp = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
function encode2(value2, options2) {
  var settings = options2 || {};
  var subset2 = settings.subset;
  var set2 = subset2 ? toExpression(subset2) : defaultEscapes;
  var escapeOnly = settings.escapeOnly;
  var omit = settings.omitOptionalSemicolons;
  value2 = value2.replace(set2, replace);
  if (subset2 || escapeOnly) {
    return value2;
  }
  return value2.replace(surrogatePair, replaceSurrogatePair).replace(bmp, replace);
  function replaceSurrogatePair(pair, pos, val) {
    return toHexReference(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      val.charAt(pos + 2),
      omit
    );
  }
  function replace(char, pos, val) {
    return one$1(char, val.charAt(pos + 1), settings);
  }
}
function escape(value2) {
  return encode2(value2, { escapeOnly: true, useNamedReferences: true });
}
function one$1(char, next, options2) {
  var shortest = options2.useShortestReferences;
  var omit = options2.omitOptionalSemicolons;
  var named;
  var code2;
  var numeric;
  var decimal2;
  if ((shortest || options2.useNamedReferences) && own$3.call(characters, char)) {
    named = toNamed(characters[char], next, omit, options2.attribute);
  }
  if (shortest || !named) {
    code2 = char.charCodeAt(0);
    numeric = toHexReference(code2, next, omit);
    if (shortest) {
      decimal2 = toDecimalReference(code2, next, omit);
      if (decimal2.length < numeric.length) {
        numeric = decimal2;
      }
    }
  }
  if (named && (!shortest || named.length < numeric.length)) {
    return named;
  }
  return numeric;
}
function toNamed(name2, next, omit, attribute2) {
  var value2 = "&" + name2;
  if (omit && own$3.call(legacy, name2) && dangerous.indexOf(name2) === -1 && (!attribute2 || next && next !== "=" && !isAlphanumerical(next))) {
    return value2;
  }
  return value2 + ";";
}
function toHexReference(code2, next, omit) {
  var value2 = "&#x" + code2.toString(16).toUpperCase();
  return omit && next && !isHexadecimal(next) ? value2 : value2 + ";";
}
function toDecimalReference(code2, next, omit) {
  var value2 = "&#" + String(code2);
  return omit && next && !decimal(next) ? value2 : value2 + ";";
}
function toExpression(characters2) {
  return new RegExp("[" + characters2.join("") + "]", "g");
}
function construct() {
  var chars2 = {};
  var name2;
  for (name2 in entities2) {
    chars2[entities2[name2]] = name2;
  }
  return chars2;
}
var NULL2 = "\0";
var AMP = "&";
var SP = " ";
var TB = "	";
var GR = "`";
var DQ$1 = '"';
var SQ$1 = "'";
var EQ = "=";
var LT = "<";
var GT = ">";
var SO = "/";
var LF = "\n";
var CR = "\r";
var FF = "\f";
var whitespace = [SP, TB, LF, CR, FF];
var name = whitespace.concat(AMP, SO, GT, EQ);
var unquoted$1 = whitespace.concat(AMP, GT);
var unquotedSafe = unquoted$1.concat(NULL2, DQ$1, SQ$1, LT, EQ, GR);
var singleQuoted$1 = [AMP, SQ$1];
var doubleQuoted$1 = [AMP, DQ$1];
var constants = {
  name: [[name, name.concat(DQ$1, SQ$1, GR)], [name.concat(NULL2, DQ$1, SQ$1, LT), name.concat(NULL2, DQ$1, SQ$1, LT, GR)]],
  unquoted: [[unquoted$1, unquotedSafe], [unquotedSafe, unquotedSafe]],
  single: [
    [singleQuoted$1, singleQuoted$1.concat(DQ$1, GR)],
    [singleQuoted$1.concat(NULL2), singleQuoted$1.concat(NULL2, DQ$1, GR)]
  ],
  double: [
    [doubleQuoted$1, doubleQuoted$1.concat(SQ$1, GR)],
    [doubleQuoted$1.concat(NULL2), doubleQuoted$1.concat(NULL2, SQ$1, GR)]
  ]
};
var spaces = spaceSeparatedTokens.stringify;
var commas = commaSeparatedTokens.stringify;
var element_1 = element;
var emptyString = "";
var space$1 = " ";
var quotationMark = '"';
var apostrophe$1 = "'";
var equalsTo = "=";
var lessThan$1 = "<";
var greaterThan = ">";
var slash$1 = "/";
var newLine = "\n";
function element(ctx, node2, index2, parent, printWidthOffset, innerTextLength) {
  var parentSchema = ctx.schema;
  var name2 = node2.tagName;
  var value2 = "";
  var selfClosing;
  var close;
  var omit;
  var root2 = node2;
  var content;
  var attrs2;
  var indentLevel = getNodeData(node2, "indentLevel", 0);
  var printContext = {
    offset: printWidthOffset,
    wrapAttributes: false,
    indentLevel
  };
  var isVoid = ctx.voids.indexOf(name2) !== -1;
  var ignoreAttrCollapsing = getNodeData(node2, "ignore", false) || getNodeData(node2, "preserveAttrWrapping", false);
  if (parentSchema.space === "html" && name2 === "svg") {
    ctx.schema = svg_1;
  }
  if (ctx.schema.space === "svg") {
    omit = false;
    close = true;
    selfClosing = ctx.closeEmpty;
  } else {
    omit = ctx.omit;
    close = ctx.close;
    selfClosing = isVoid;
  }
  if (selfClosing === false) {
    selfClosing = getNodeData(node2, "selfClosing", false);
  }
  printContext.offset += lessThan$1.length;
  printContext.offset += node2.tagName.length;
  if (selfClosing && !isVoid) {
    printContext.offset += slash$1.length;
  }
  printContext.offset += greaterThan.length;
  const propertyCount = Object.keys(node2.properties).length;
  if (propertyCount > 1 && ctx.wrapAttributes) {
    printContext.wrapAttributes = true;
  }
  if (propertyCount) {
    printContext.offset += propertyCount * space$1.length;
  }
  printContext.offset += innerTextLength;
  attrs2 = attributes(ctx, node2.properties, printContext, ignoreAttrCollapsing);
  const shouldCollapse = ignoreAttrCollapsing === false && printContext.wrapAttributes;
  content = all_1(ctx, root2);
  selfClosing = content ? false : selfClosing;
  if (attrs2 || !omit || !omit.opening(node2, index2, parent)) {
    value2 = lessThan$1 + name2;
    if (attrs2) {
      if (shouldCollapse) {
        value2 += attrs2;
      } else {
        value2 += space$1 + attrs2;
      }
    }
    let selfClosed = false;
    if (selfClosing && close) {
      if ((!ctx.tightClose || attrs2.charAt(attrs2.length - 1) === slash$1) && !shouldCollapse) {
        value2 += space$1;
      }
      if (shouldCollapse) {
        value2 += newLine + repeatString(ctx.tabWidth, printContext.indentLevel);
      }
      selfClosed = true;
      value2 += slash$1;
    } else if (selfClosing && !isVoid) {
      if (shouldCollapse) {
        value2 += newLine + repeatString(ctx.tabWidth, printContext.indentLevel);
      }
      selfClosed = true;
      value2 += slash$1;
    }
    if (shouldCollapse && !selfClosed) {
      value2 += newLine + repeatString(ctx.tabWidth, printContext.indentLevel);
    }
    value2 += greaterThan;
  }
  value2 += content;
  if (!selfClosing && (!omit || !omit.closing(node2, index2, parent))) {
    value2 += lessThan$1 + slash$1 + name2 + greaterThan;
  }
  ctx.schema = parentSchema;
  return value2;
}
function attributes(ctx, props, printContext, ignoreIndent) {
  var values2 = [];
  var key;
  var value2;
  var result;
  var length2;
  var index2;
  var last;
  for (key in props) {
    value2 = props[key];
    if (value2 == null) {
      continue;
    }
    result = attribute$1(ctx, key, value2);
    printContext.offset += result.length;
    if (ignoreIndent === false && printContext.offset > ctx.printWidth) {
      printContext.wrapAttributes = true;
    }
    if (result) {
      values2.push(result);
    }
  }
  length2 = values2.length;
  index2 = -1;
  while (++index2 < length2) {
    result = values2[index2];
    last = null;
    if (last !== quotationMark && last !== apostrophe$1) {
      if (printContext.wrapAttributes) {
        values2[index2] = newLine + repeatString(ctx.tabWidth, printContext.indentLevel + 1) + result;
      } else if (index2 !== length2 - 1) {
        values2[index2] = result + space$1;
      } else {
        values2[index2] = result;
      }
    }
  }
  return values2.join(emptyString);
}
function attribute$1(ctx, key, value2) {
  var schema2 = ctx.schema;
  var info2 = find_1(schema2, key);
  var name2 = info2.attribute;
  if (value2 == null || typeof value2 === "number" && isNaN(value2) || value2 === false && info2.boolean) {
    return emptyString;
  }
  name2 = attributeName$1(ctx, name2);
  if (value2 === true && info2.boolean || value2 === true && info2.overloadedBoolean) {
    return name2;
  }
  return name2 + attributeValue$1(ctx, key, value2, info2);
}
function attributeName$1(ctx, name2) {
  var valid2 = ctx.schema.space === "html" ? ctx.valid : 1;
  var subset2 = constants.name[valid2][ctx.safe];
  return stringifyEntities(name2, immutable(ctx.entities, { subset: subset2 }));
}
function attributeValue$1(ctx, key, value2, info2) {
  var quote = ctx.quote;
  if (typeof value2 === "object" && "length" in value2) {
    value2 = (info2.commaSeparated ? commas : spaces)(value2, {
      padLeft: !ctx.tightLists
    });
  }
  value2 = String(value2);
  if (value2 === "") {
    return value2;
  } else {
    value2 = equalsTo + quote + value2 + quote;
  }
  return value2;
}
function getNodeData(node2, key, defaultValue) {
  let data3 = node2.data || {};
  return data3[key] || defaultValue;
}
var doctype_1 = doctype;
function doctype(ctx, node2) {
  var sep2 = ctx.tightDoctype ? "" : " ";
  var name2 = node2.name;
  var pub = node2.public;
  var sys = node2.system;
  var val = ["<!doctype"];
  if (name2) {
    val.push(sep2, name2);
    if (pub != null) {
      val.push(" public", sep2, smart(pub));
    } else if (sys != null) {
      val.push(" system");
    }
    if (sys != null) {
      val.push(sep2, smart(sys));
    }
  }
  return val.join("") + ">";
}
function smart(value2) {
  var quote = value2.indexOf('"') === -1 ? '"' : "'";
  return quote + value2 + quote;
}
var comment_1 = comment;
function comment(ctx, node2) {
  return "<!--" + node2.value + "-->";
}
var raw_1 = raw;
function raw(ctx, node2) {
  return node2.value;
}
var one_1 = one;
var own$2 = {}.hasOwnProperty;
var handlers2 = {};
handlers2.root = all_1;
handlers2.text = text_1;
handlers2.element = element_1;
handlers2.doctype = doctype_1;
handlers2.comment = comment_1;
handlers2.raw = raw_1;
function one(ctx, node2, index2, parent, printWidthOffset, innerTextLength) {
  var type2 = node2 && node2.type;
  if (!type2) {
    throw new Error("Expected node, not `" + node2 + "`");
  }
  if (!own$2.call(handlers2, type2)) {
    throw new Error("Cannot compile unknown node `" + type2 + "`");
  }
  return handlers2[type2](ctx, node2, index2, parent, printWidthOffset, innerTextLength);
}
var voids = getCjsExportFromNamespace(htmlVoidElements);
var lib$12 = toHTML;
var DQ = '"';
var SQ = "'";
function toHTML(node2, options2) {
  var settings = options2 || {};
  var quote = settings.singleQuote ? SQ : DQ;
  var printWidth = settings.printWidth === void 0 ? 80 : settings.printWidth;
  var useTabs = settings.useTabs;
  var tabWidth = settings.tabWidth || 2;
  var wrapAttributes = settings.wrapAttributes;
  if (useTabs) {
    tabWidth = "	";
  } else if (typeof tabWidth === "number") {
    tabWidth = repeatString(" ", tabWidth);
  }
  return one_1(
    {
      valid: settings.allowParseErrors ? 0 : 1,
      safe: settings.allowDangerousCharacters ? 0 : 1,
      schema: settings.space === "svg" ? svg_1 : html_1,
      omit: settings.omitOptionalTags && omission,
      quote,
      printWidth,
      tabWidth,
      wrapAttributes,
      tightDoctype: Boolean(settings.tightDoctype),
      tightLists: settings.tightCommaSeparatedLists,
      voids: settings.voids || voids.concat(),
      entities: settings.entities || {},
      close: settings.closeSelfClosing,
      tightClose: settings.tightSelfClosing,
      closeEmpty: settings.closeEmptyElements
    },
    node2
  );
}
var prettyhtmlHastToHtml = lib$12;
var void_els = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
var RE_SVELTE_TAG = /^<svelte:([a-z]*)[\s\S]*(?:(?:svelte:[a-z]*)|(?:\/))>$/;
var RE_SVELTE_TAG_START = /(^\s*)<([\\/\s])*svelte:/;
function parse_svelte_tag(eat2, value2, silent) {
  const is_svelte_tag = RE_SVELTE_TAG_START.exec(value2);
  if (is_svelte_tag) {
    if (silent)
      return true;
    const trimmed_value = value2.trim();
    let cbPos = 0;
    let pos = 1;
    let current_tag = "";
    let in_tag_name = false;
    while (cbPos > -1) {
      if (!trimmed_value[pos]) {
        break;
      }
      if (trimmed_value[pos].match(/</)) {
        cbPos++;
        current_tag = "";
        in_tag_name = true;
      }
      if (in_tag_name && trimmed_value[pos].match(/\s/)) {
        in_tag_name = false;
      }
      if (in_tag_name && !trimmed_value[pos].match(/</)) {
        current_tag += trimmed_value[pos];
      }
      const is_void2 = void_els.includes(current_tag);
      if (is_void2 && trimmed_value[pos].match(/>/) || (trimmed_value[pos - 1] + trimmed_value[pos]).match(/\/>/)) {
        cbPos--;
      }
      if ((trimmed_value[pos - 1] + trimmed_value[pos]).match(/<\//)) {
        let inner_indent = 0;
        while (inner_indent > -1) {
          if (trimmed_value[pos].match(/>/)) {
            pos++;
            inner_indent -= 1;
            cbPos -= 2;
          } else {
            pos++;
          }
        }
      }
      pos++;
    }
    const match = RE_SVELTE_TAG.exec(trimmed_value.substring(0, pos).trim());
    if (!match)
      return;
    return eat2(is_svelte_tag[1] + match[0])({
      type: "svelteTag",
      value: match[0],
      name: match[1]
    });
  }
}
var RE_SVELTE_BLOCK_START = /(^\s*){[#:/@]/;
var RE_SVELTE_BLOCK = /^{[#:/@](else if|[a-z]+).*}$/;
function parse_svelte_block(eat2, value2, silent) {
  const is_svelte_block = RE_SVELTE_BLOCK_START.exec(value2);
  if (is_svelte_block) {
    if (silent)
      return true;
    const trimmed_value = value2.trim();
    let cbPos = 0;
    let pos = 1;
    while (cbPos > -1) {
      if (trimmed_value[pos].match(/{/))
        cbPos++;
      if (trimmed_value[pos].match(/}/))
        cbPos--;
      pos++;
    }
    const match = RE_SVELTE_BLOCK.exec(trimmed_value.substring(0, pos));
    if (!match)
      return;
    return eat2(is_svelte_block[1] + match[0])({
      type: "svelteBlock",
      value: `${is_svelte_block[1]}${match[0]}`,
      name: match[1]
    });
  }
}
var dotAllPolyfill = "[\0-\uFFFF]";
var attributeName = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted = "[^\"'=<>`\\u0000-\\u0020]+";
var singleQuoted = "'[^']*'";
var doubleQuoted = '"[^"]*"';
var jsProps = "{.*}".replace(".", dotAllPolyfill);
var attributeValue = "(?:" + unquoted + "|" + singleQuoted + "|" + doubleQuoted + "|" + jsProps + ")";
var attribute = "(?:\\s+" + attributeName + "(?:\\s*=\\s*" + attributeValue + ")?)";
var openTag = "<[A-Za-z]*[A-Za-z0-9\\.\\-]*" + attribute + "*\\s*\\/?>";
var closeTag = "<\\/[A-Za-z][A-Za-z0-9\\.\\-]*\\s*>";
"<[?].*?[?]>".replace(".", dotAllPolyfill);
var openCloseTag = new RegExp("^(?:" + openTag + "|" + closeTag + ")");
var tab = "	";
var space = " ";
var lineFeed = "\n";
var lessThan = "<";
var rawOpenExpression = /^<(script|pre|style)(?=(\s|>|$))/i;
var rawCloseExpression = /<\/(script|pre|style)>/i;
var commentOpenExpression = /^<!--/;
var commentCloseExpression = /-->/;
var instructionOpenExpression = /^<\?/;
var instructionCloseExpression = /\?>/;
var directiveOpenExpression = /^<![A-Za-z]/;
var directiveCloseExpression = />/;
var cdataOpenExpression = /^<!\[CDATA\[/;
var cdataCloseExpression = /\]\]>/;
var elementCloseExpression = /^$/;
var otherElementOpenExpression = new RegExp(openCloseTag.source + "\\s*$");
var fragmentOpenExpression = /^<>/;
function blockHtml(eat2, value2, silent) {
  const blocks = "[a-z\\.]*(\\.){0,1}[a-z][a-z0-9\\.]*";
  const elementOpenExpression = new RegExp(
    "^</?(" + blocks + ")(?=(\\s|/?>|$))",
    "i"
  );
  const length2 = value2.length;
  let index2 = 0;
  let next;
  let line2;
  let offset2;
  let character;
  let sequence2;
  const sequences = [
    [rawOpenExpression, rawCloseExpression, true],
    [commentOpenExpression, commentCloseExpression, true],
    [instructionOpenExpression, instructionCloseExpression, true],
    [directiveOpenExpression, directiveCloseExpression, true],
    [cdataOpenExpression, cdataCloseExpression, true],
    [elementOpenExpression, elementCloseExpression, true],
    [fragmentOpenExpression, elementCloseExpression, true],
    [otherElementOpenExpression, elementCloseExpression, false]
  ];
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (character !== tab && character !== space) {
      break;
    }
    index2++;
  }
  if (value2.charAt(index2) !== lessThan) {
    return;
  }
  next = value2.indexOf(lineFeed, index2 + 1);
  next = next === -1 ? length2 : next;
  line2 = value2.slice(index2, next);
  offset2 = -1;
  const count = sequences.length;
  while (++offset2 < count) {
    if (sequences[offset2][0].test(line2)) {
      sequence2 = sequences[offset2];
      break;
    }
  }
  if (!sequence2) {
    return;
  }
  if (silent) {
    return sequence2[2];
  }
  index2 = next;
  if (!sequence2[1].test(line2)) {
    while (index2 < length2) {
      next = value2.indexOf(lineFeed, index2 + 1);
      next = next === -1 ? length2 : next;
      line2 = value2.slice(index2 + 1, next);
      if (sequence2[1].test(line2)) {
        if (line2) {
          index2 = next;
        }
        break;
      }
      index2 = next;
    }
  }
  const subvalue = value2.slice(0, index2);
  return eat2(subvalue)({ type: "html", value: subvalue });
}
function mdsvex_parser() {
  const Parser4 = this.Parser;
  const block_tokenizers = Parser4.prototype.blockTokenizers;
  const methods = Parser4.prototype.blockMethods;
  block_tokenizers.svelteBlock = parse_svelte_block;
  block_tokenizers.svelteTag = parse_svelte_tag;
  block_tokenizers.html = blockHtml;
  block_tokenizers.indentedCode = indentedCode;
  methods.splice(methods.indexOf("html"), 0, "svelteBlock");
  methods.splice(methods.indexOf("html"), 0, "svelteTag");
}
function indentedCode() {
  return true;
}
var unified_1 = unified().freeze();
var slice2 = [].slice;
var own$1 = {}.hasOwnProperty;
var pipeline = trough_1().use(pipelineParse).use(pipelineRun).use(pipelineStringify);
function pipelineParse(p2, ctx) {
  ctx.tree = p2.parse(ctx.file);
}
function pipelineRun(p2, ctx, next) {
  p2.run(ctx.tree, ctx.file, done);
  function done(err, tree, file) {
    if (err) {
      next(err);
    } else {
      ctx.tree = tree;
      ctx.file = file;
      next();
    }
  }
}
function pipelineStringify(p2, ctx) {
  ctx.file.contents = p2.stringify(ctx.tree, ctx.file);
}
function unified() {
  var attachers = [];
  var transformers = trough_1();
  var namespace = {};
  var frozen = false;
  var freezeIndex = -1;
  processor.data = data3;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse5;
  processor.stringify = stringify2;
  processor.run = run2;
  processor.runSync = runSync;
  processor.process = process2;
  processor.processSync = processSync;
  return processor;
  function processor() {
    var destination = unified();
    var length2 = attachers.length;
    var index2 = -1;
    while (++index2 < length2) {
      destination.use.apply(null, attachers[index2]);
    }
    destination.data(extend$2(true, {}, namespace));
    return destination;
  }
  function freeze() {
    var values2;
    var plugin;
    var options2;
    var transformer;
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      values2 = attachers[freezeIndex];
      plugin = values2[0];
      options2 = values2[1];
      transformer = null;
      if (options2 === false) {
        continue;
      }
      if (options2 === true) {
        values2[1] = void 0;
      }
      transformer = plugin.apply(processor, values2.slice(1));
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Infinity;
    return processor;
  }
  function data3(key, value2) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", frozen);
        namespace[key] = value2;
        return processor;
      }
      return own$1.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      assertUnfrozen("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function use(value2) {
    var settings;
    assertUnfrozen("use", frozen);
    if (value2 === null || value2 === void 0)
      ;
    else if (typeof value2 === "function") {
      addPlugin.apply(null, arguments);
    } else if (typeof value2 === "object") {
      if ("length" in value2) {
        addList(value2);
      } else {
        addPreset(value2);
      }
    } else {
      throw new Error("Expected usable value, not `" + value2 + "`");
    }
    if (settings) {
      namespace.settings = extend$2(namespace.settings || {}, settings);
    }
    return processor;
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = extend$2(settings || {}, result.settings);
      }
    }
    function add(value3) {
      if (typeof value3 === "function") {
        addPlugin(value3);
      } else if (typeof value3 === "object") {
        if ("length" in value3) {
          addPlugin.apply(null, value3);
        } else {
          addPreset(value3);
        }
      } else {
        throw new Error("Expected usable value, not `" + value3 + "`");
      }
    }
    function addList(plugins) {
      var length2;
      var index2;
      if (plugins === null || plugins === void 0)
        ;
      else if (typeof plugins === "object" && "length" in plugins) {
        length2 = plugins.length;
        index2 = -1;
        while (++index2 < length2) {
          add(plugins[index2]);
        }
      } else {
        throw new Error("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value3) {
      var entry = find2(plugin);
      if (entry) {
        if (isPlainObj(entry[1]) && isPlainObj(value3)) {
          value3 = extend$2(entry[1], value3);
        }
        entry[1] = value3;
      } else {
        attachers.push(slice2.call(arguments));
      }
    }
  }
  function find2(plugin) {
    var length2 = attachers.length;
    var index2 = -1;
    var entry;
    while (++index2 < length2) {
      entry = attachers[index2];
      if (entry[0] === plugin) {
        return entry;
      }
    }
  }
  function parse5(doc) {
    var file = vfile(doc);
    var Parser4;
    freeze();
    Parser4 = processor.Parser;
    assertParser("parse", Parser4);
    if (newable(Parser4, "parse")) {
      return new Parser4(String(file), file).parse();
    }
    return Parser4(String(file), file);
  }
  function run2(node2, file, cb) {
    assertNode(node2);
    freeze();
    if (!cb && typeof file === "function") {
      cb = file;
      file = null;
    }
    if (!cb) {
      return new Promise(executor);
    }
    executor(null, cb);
    function executor(resolve, reject) {
      transformers.run(node2, vfile(file), done);
      function done(err, tree, file2) {
        tree = tree || node2;
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(tree);
        } else {
          cb(null, tree, file2);
        }
      }
    }
  }
  function runSync(node2, file) {
    var complete = false;
    var result;
    run2(node2, file, done);
    assertDone("runSync", "run", complete);
    return result;
    function done(err, tree) {
      complete = true;
      bail_1(err);
      result = tree;
    }
  }
  function stringify2(node2, doc) {
    var file = vfile(doc);
    var Compiler;
    freeze();
    Compiler = processor.Compiler;
    assertCompiler("stringify", Compiler);
    assertNode(node2);
    if (newable(Compiler, "compile")) {
      return new Compiler(node2, file).compile();
    }
    return Compiler(node2, file);
  }
  function process2(doc, cb) {
    freeze();
    assertParser("process", processor.Parser);
    assertCompiler("process", processor.Compiler);
    if (!cb) {
      return new Promise(executor);
    }
    executor(null, cb);
    function executor(resolve, reject) {
      var file = vfile(doc);
      pipeline.run(processor, { file }, done);
      function done(err) {
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(file);
        } else {
          cb(null, file);
        }
      }
    }
  }
  function processSync(doc) {
    var complete = false;
    var file;
    freeze();
    assertParser("processSync", processor.Parser);
    assertCompiler("processSync", processor.Compiler);
    file = vfile(doc);
    process2(file, done);
    assertDone("processSync", "process", complete);
    return file;
    function done(err) {
      complete = true;
      bail_1(err);
    }
  }
}
function newable(value2, name2) {
  return typeof value2 === "function" && value2.prototype && (keys(value2.prototype) || name2 in value2.prototype);
}
function keys(value2) {
  var key;
  for (key in value2) {
    return true;
  }
  return false;
}
function assertParser(name2, Parser4) {
  if (typeof Parser4 !== "function") {
    throw new Error("Cannot `" + name2 + "` without `Parser`");
  }
}
function assertCompiler(name2, Compiler) {
  if (typeof Compiler !== "function") {
    throw new Error("Cannot `" + name2 + "` without `Compiler`");
  }
}
function assertUnfrozen(name2, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot invoke `" + name2 + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!node2 || typeof node2.type !== "string") {
    throw new Error("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name2, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
var nlcstToString_1 = nlcstToString;
function nlcstToString(node2, separator) {
  var sep2 = separator || "";
  var values2;
  var length2;
  var children;
  if (!node2 || !("length" in node2) && !node2.type) {
    throw new Error("Expected node, not `" + node2 + "`");
  }
  if (typeof node2.value === "string") {
    return node2.value;
  }
  children = "length" in node2 ? node2 : node2.children;
  length2 = children.length;
  if (length2 === 1 && "value" in children[0]) {
    return children[0].value;
  }
  values2 = [];
  while (length2--) {
    values2[length2] = nlcstToString(children[length2], sep2);
  }
  return values2.join(sep2);
}
var tokenizer3 = tokenizerFactory;
function tokenizerFactory(childType, expression2) {
  return tokenizer4;
  function tokenizer4(node2) {
    var children = [];
    var tokens = node2.children;
    var type2 = node2.type;
    var length2 = tokens.length;
    var index2 = -1;
    var lastIndex = length2 - 1;
    var start2 = 0;
    var first2;
    var last;
    var parent;
    while (++index2 < length2) {
      if (index2 === lastIndex || tokens[index2].type === childType && expression2.test(nlcstToString_1(tokens[index2]))) {
        first2 = tokens[start2];
        last = tokens[index2];
        parent = {
          type: type2,
          children: tokens.slice(start2, index2 + 1)
        };
        if (first2.position && last.position) {
          parent.position = {
            start: first2.position.start,
            end: last.position.end
          };
        }
        children.push(parent);
        start2 = index2 + 1;
      }
    }
    return children;
  }
}
var parser2 = parserFactory;
function parserFactory(options2) {
  var type2 = options2.type;
  var tokenizerProperty = options2.tokenizer;
  var delimiter = options2.delimiter;
  var tokenize3 = delimiter && tokenizer3(options2.delimiterType, delimiter);
  return parser3;
  function parser3(value2) {
    var children = this[tokenizerProperty](value2);
    return {
      type: type2,
      children: tokenize3 ? tokenize3(children) : children
    };
  }
}
var expressions = {
  affixSymbol: /^([\)\]\}\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63]|["'\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21]|[!\.\?\u2026\u203D])\1*$/,
  newLine: /^[ \t]*((\r?\n|\r)[\t ]*)+$/,
  newLineMulti: /^[ \t]*((\r?\n|\r)[\t ]*){2,}$/,
  terminalMarker: /^((?:[!\.\?\u2026\u203D])+)$/,
  wordSymbolInner: /^((?:[&'\x2D\.:=\?@\xAD\xB7\u2010\u2011\u2019\u2027])|(?:_)+)$/,
  numerical: /^(?:[0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D58-\u0D5E\u0D66-\u0D78\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDD30-\uDD39\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2]|\uD807[\uDC50-\uDC6C\uDD50-\uDD59\uDDA0-\uDDA9\uDFC0-\uDFD4]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C])+$/,
  digitStart: /^\d/,
  lowerInitial: /^(?:[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0560-\u0588\u10D0-\u10FA\u10FD-\u10FF\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7AF\uA7B5\uA7B7\uA7B9\uA7BB\uA7BD\uA7BF\uA7C3\uA7FA\uAB30-\uAB5A\uAB60-\uAB67\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43])/,
  surrogates: /[\uD800-\uDFFF]/,
  punctuation: /[!"'-\),-\/:;\?\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u201F\u2022-\u2027\u2032-\u203A\u203C-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/,
  word: /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D3-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09F4-\u09F9\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BF2\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7E\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D63\u0D66-\u0D78\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F33\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u17F0-\u17F9\u180B-\u180D\u1810-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABE\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u20D0-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BA\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA672\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA827\uA830-\uA835\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE6\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD27\uDD30-\uDD39\uDE60-\uDE7E\uDF00-\uDF27\uDF30-\uDF54\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC52-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD46\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E\uDC5F\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF3B]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCF2\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/,
  whiteSpace: /[\t-\r \x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/
};
var arrayIterate = iterate;
var own = {}.hasOwnProperty;
function iterate(values2, callback, context2) {
  var index2 = -1;
  var result;
  if (!values2) {
    throw new Error("Iterate requires that |this| not be " + values2);
  }
  if (!own.call(values2, "length")) {
    throw new Error("Iterate requires that |this| has a `length`");
  }
  if (typeof callback !== "function") {
    throw new Error("`callback` must be a function");
  }
  while (++index2 < values2.length) {
    if (!(index2 in values2)) {
      continue;
    }
    result = callback.call(context2, values2[index2], index2, values2);
    if (typeof result === "number") {
      if (result < 0) {
        index2 = 0;
      }
      index2 = result - 1;
    }
  }
}
var unistUtilModifyChildren = modifierFactory;
function modifierFactory(callback) {
  return iteratorFactory(wrapperFactory(callback));
}
function iteratorFactory(callback) {
  return iterator;
  function iterator(parent) {
    var children = parent && parent.children;
    if (!children) {
      throw new Error("Missing children in `parent` for `modifier`");
    }
    return arrayIterate(children, callback, parent);
  }
}
function wrapperFactory(callback) {
  return wrapper;
  function wrapper(value2, index2) {
    return callback(value2, index2, this);
  }
}
var mergeInitialWordSymbol_1 = unistUtilModifyChildren(mergeInitialWordSymbol);
function mergeInitialWordSymbol(child, index2, parent) {
  var children;
  var next;
  if (child.type !== "SymbolNode" && child.type !== "PunctuationNode" || nlcstToString_1(child) !== "&") {
    return;
  }
  children = parent.children;
  next = children[index2 + 1];
  if (index2 !== 0 && children[index2 - 1].type === "WordNode" || !(next && next.type === "WordNode")) {
    return;
  }
  children.splice(index2, 1);
  next.children.unshift(child);
  if (next.position && child.position) {
    next.position.start = child.position.start;
  }
  return index2 - 1;
}
var mergeFinalWordSymbol_1 = unistUtilModifyChildren(mergeFinalWordSymbol$1);
function mergeFinalWordSymbol$1(child, index2, parent) {
  var children;
  var prev;
  var next;
  if (index2 !== 0 && (child.type === "SymbolNode" || child.type === "PunctuationNode") && nlcstToString_1(child) === "-") {
    children = parent.children;
    prev = children[index2 - 1];
    next = children[index2 + 1];
    if ((!next || next.type !== "WordNode") && prev && prev.type === "WordNode") {
      children.splice(index2, 1);
      prev.children.push(child);
      if (prev.position && child.position) {
        prev.position.end = child.position.end;
      }
      return index2;
    }
  }
}
var mergeInnerWordSymbol_1 = unistUtilModifyChildren(mergeInnerWordSymbol);
var wordSymbolInner = expressions.wordSymbolInner;
function mergeInnerWordSymbol(child, index2, parent) {
  var siblings2;
  var sibling;
  var prev;
  var last;
  var position2;
  var tokens;
  var queue;
  if (index2 !== 0 && (child.type === "SymbolNode" || child.type === "PunctuationNode")) {
    siblings2 = parent.children;
    prev = siblings2[index2 - 1];
    if (prev && prev.type === "WordNode") {
      position2 = index2 - 1;
      tokens = [];
      queue = [];
      while (siblings2[++position2]) {
        sibling = siblings2[position2];
        if (sibling.type === "WordNode") {
          tokens = tokens.concat(queue, sibling.children);
          queue = [];
        } else if ((sibling.type === "SymbolNode" || sibling.type === "PunctuationNode") && wordSymbolInner.test(nlcstToString_1(sibling))) {
          queue.push(sibling);
        } else {
          break;
        }
      }
      if (tokens.length !== 0) {
        if (queue.length !== 0) {
          position2 -= queue.length;
        }
        siblings2.splice(index2, position2 - index2);
        prev.children = prev.children.concat(tokens);
        last = tokens[tokens.length - 1];
        if (prev.position && last.position) {
          prev.position.end = last.position.end;
        }
        return index2;
      }
    }
  }
}
var mergeInnerWordSlash_1 = unistUtilModifyChildren(mergeInnerWordSlash);
var slash = "/";
function mergeInnerWordSlash(child, index2, parent) {
  var siblings2 = parent.children;
  var prev;
  var next;
  var prevValue;
  var nextValue;
  var queue;
  var tail;
  var count;
  prev = siblings2[index2 - 1];
  next = siblings2[index2 + 1];
  if (prev && prev.type === "WordNode" && (child.type === "SymbolNode" || child.type === "PunctuationNode") && nlcstToString_1(child) === slash) {
    prevValue = nlcstToString_1(prev);
    tail = child;
    queue = [child];
    count = 1;
    if (next && next.type === "WordNode") {
      nextValue = nlcstToString_1(next);
      tail = next;
      queue = queue.concat(next.children);
      count++;
    }
    if (prevValue.length < 3 && (!nextValue || nextValue.length < 3)) {
      prev.children = prev.children.concat(queue);
      siblings2.splice(index2, count);
      if (prev.position && tail.position) {
        prev.position.end = tail.position.end;
      }
      return index2;
    }
  }
}
var mergeInitialisms_1 = unistUtilModifyChildren(mergeInitialisms);
var numerical = expressions.numerical;
function mergeInitialisms(child, index2, parent) {
  var siblings2;
  var prev;
  var children;
  var length2;
  var position2;
  var otherChild;
  var isAllDigits;
  var value2;
  if (index2 !== 0 && nlcstToString_1(child) === ".") {
    siblings2 = parent.children;
    prev = siblings2[index2 - 1];
    children = prev.children;
    length2 = children && children.length;
    if (prev.type === "WordNode" && length2 !== 1 && length2 % 2 !== 0) {
      position2 = length2;
      isAllDigits = true;
      while (children[--position2]) {
        otherChild = children[position2];
        value2 = nlcstToString_1(otherChild);
        if (position2 % 2 === 0) {
          if (value2.length > 1) {
            return;
          }
          if (!numerical.test(value2)) {
            isAllDigits = false;
          }
        } else if (value2 !== ".") {
          if (position2 < length2 - 2) {
            break;
          } else {
            return;
          }
        }
      }
      if (!isAllDigits) {
        siblings2.splice(index2, 1);
        children.push(child);
        if (prev.position && child.position) {
          prev.position.end = child.position.end;
        }
        return index2;
      }
    }
  }
}
var mergeWords = unistUtilModifyChildren(mergeFinalWordSymbol);
function mergeFinalWordSymbol(child, index2, parent) {
  var siblings2 = parent.children;
  var next;
  if (child.type === "WordNode") {
    next = siblings2[index2 + 1];
    if (next && next.type === "WordNode") {
      siblings2.splice(index2 + 1, 1);
      child.children = child.children.concat(next.children);
      if (next.position && child.position) {
        child.position.end = next.position.end;
      }
      return index2;
    }
  }
}
var unistUtilVisitChildren = visitChildren;
function visitChildren(callback) {
  return visitor;
  function visitor(parent) {
    var index2 = -1;
    var children = parent && parent.children;
    if (!children) {
      throw new Error("Missing children in `parent` for `visitor`");
    }
    while (++index2 in children) {
      callback(children[index2], index2, parent);
    }
  }
}
var patchPosition_1 = unistUtilVisitChildren(patchPosition);
function patchPosition(child, index2, node2) {
  var siblings2 = node2.children;
  if (!child.position) {
    return;
  }
  if (index2 === 0 && (!node2.position || !node2.position.start)) {
    patch(node2);
    node2.position.start = child.position.start;
  }
  if (index2 === siblings2.length - 1 && (!node2.position || !node2.position.end)) {
    patch(node2);
    node2.position.end = child.position.end;
  }
}
function patch(node2) {
  if (!node2.position) {
    node2.position = {};
  }
}
var mergeNonWordSentences_1 = unistUtilModifyChildren(mergeNonWordSentences);
function mergeNonWordSentences(child, index2, parent) {
  var children = child.children;
  var position2 = -1;
  var prev;
  var next;
  while (children[++position2]) {
    if (children[position2].type === "WordNode") {
      return;
    }
  }
  prev = parent.children[index2 - 1];
  if (prev) {
    prev.children = prev.children.concat(children);
    parent.children.splice(index2, 1);
    if (prev.position && child.position) {
      prev.position.end = child.position.end;
    }
    return index2;
  }
  next = parent.children[index2 + 1];
  if (next) {
    next.children = children.concat(next.children);
    if (next.position && child.position) {
      next.position.start = child.position.start;
    }
    parent.children.splice(index2, 1);
  }
}
var mergeAffixSymbol_1 = unistUtilModifyChildren(mergeAffixSymbol);
var affixSymbol = expressions.affixSymbol;
function mergeAffixSymbol(child, index2, parent) {
  var children = child.children;
  var first2;
  var second;
  var prev;
  if (children && children.length !== 0 && index2 !== 0) {
    first2 = children[0];
    second = children[1];
    prev = parent.children[index2 - 1];
    if ((first2.type === "SymbolNode" || first2.type === "PunctuationNode") && affixSymbol.test(nlcstToString_1(first2))) {
      prev.children.push(children.shift());
      if (first2.position && prev.position) {
        prev.position.end = first2.position.end;
      }
      if (second && second.position && child.position) {
        child.position.start = second.position.start;
      }
      return index2 - 1;
    }
  }
}
var mergeInitialLowerCaseLetterSentences_1 = unistUtilModifyChildren(mergeInitialLowerCaseLetterSentences);
var lowerInitial = expressions.lowerInitial;
function mergeInitialLowerCaseLetterSentences(child, index2, parent) {
  var children = child.children;
  var position2;
  var node2;
  var siblings2;
  var prev;
  if (children && children.length !== 0 && index2 !== 0) {
    position2 = -1;
    while (children[++position2]) {
      node2 = children[position2];
      if (node2.type === "WordNode") {
        if (!lowerInitial.test(nlcstToString_1(node2))) {
          return;
        }
        siblings2 = parent.children;
        prev = siblings2[index2 - 1];
        prev.children = prev.children.concat(children);
        siblings2.splice(index2, 1);
        if (prev.position && child.position) {
          prev.position.end = child.position.end;
        }
        return index2;
      }
      if (node2.type === "SymbolNode" || node2.type === "PunctuationNode") {
        return;
      }
    }
  }
}
var mergeInitialDigitSentences_1 = unistUtilModifyChildren(mergeInitialDigitSentences);
var digit = expressions.digitStart;
function mergeInitialDigitSentences(child, index2, parent) {
  var children = child.children;
  var siblings2 = parent.children;
  var prev = siblings2[index2 - 1];
  var head2 = children[0];
  if (prev && head2 && head2.type === "WordNode" && digit.test(nlcstToString_1(head2))) {
    prev.children = prev.children.concat(children);
    siblings2.splice(index2, 1);
    if (prev.position && child.position) {
      prev.position.end = child.position.end;
    }
    return index2;
  }
}
var mergePrefixExceptions_1 = unistUtilModifyChildren(mergePrefixExceptions);
var abbreviationPrefix = new RegExp(
  "^([0-9]{1,3}|[a-z]|al|ca|cap|cca|cent|cf|cit|con|cp|cwt|ead|etc|ff|fl|ibid|id|nem|op|pro|seq|sic|stat|tem|viz)$"
);
function mergePrefixExceptions(child, index2, parent) {
  var children = child.children;
  var period2;
  var node2;
  var next;
  if (children && children.length > 1) {
    period2 = children[children.length - 1];
    if (period2 && nlcstToString_1(period2) === ".") {
      node2 = children[children.length - 2];
      if (node2 && node2.type === "WordNode" && abbreviationPrefix.test(nlcstToString_1(node2).toLowerCase())) {
        node2.children.push(period2);
        children.pop();
        if (period2.position && node2.position) {
          node2.position.end = period2.position.end;
        }
        next = parent.children[index2 + 1];
        if (next) {
          child.children = children.concat(next.children);
          parent.children.splice(index2 + 1, 1);
          if (next.position && child.position) {
            child.position.end = next.position.end;
          }
          return index2 - 1;
        }
      }
    }
  }
}
var mergeAffixExceptions_1 = unistUtilModifyChildren(mergeAffixExceptions);
function mergeAffixExceptions(child, index2, parent) {
  var children = child.children;
  var node2;
  var position2;
  var value2;
  var previousChild;
  if (!children || children.length === 0 || index2 === 0) {
    return;
  }
  position2 = -1;
  while (children[++position2]) {
    node2 = children[position2];
    if (node2.type === "WordNode") {
      return;
    }
    if (node2.type === "SymbolNode" || node2.type === "PunctuationNode") {
      value2 = nlcstToString_1(node2);
      if (value2 !== "," && value2 !== ";") {
        return;
      }
      previousChild = parent.children[index2 - 1];
      previousChild.children = previousChild.children.concat(children);
      if (previousChild.position && child.position) {
        previousChild.position.end = child.position.end;
      }
      parent.children.splice(index2, 1);
      return index2;
    }
  }
}
var mergeRemainingFullStops_1 = unistUtilVisitChildren(mergeRemainingFullStops);
var terminalMarker = expressions.terminalMarker;
function mergeRemainingFullStops(child) {
  var children = child.children;
  var position2 = children.length;
  var hasFoundDelimiter = false;
  var grandchild;
  var prev;
  var next;
  var nextNext;
  while (children[--position2]) {
    grandchild = children[position2];
    if (grandchild.type !== "SymbolNode" && grandchild.type !== "PunctuationNode") {
      if (grandchild.type === "WordNode") {
        hasFoundDelimiter = true;
      }
      continue;
    }
    if (!terminalMarker.test(nlcstToString_1(grandchild))) {
      continue;
    }
    if (!hasFoundDelimiter) {
      hasFoundDelimiter = true;
      continue;
    }
    if (nlcstToString_1(grandchild) !== ".") {
      continue;
    }
    prev = children[position2 - 1];
    next = children[position2 + 1];
    if (prev && prev.type === "WordNode") {
      nextNext = children[position2 + 2];
      if (next && nextNext && next.type === "WhiteSpaceNode" && nlcstToString_1(nextNext) === ".") {
        continue;
      }
      children.splice(position2, 1);
      prev.children.push(grandchild);
      if (grandchild.position && prev.position) {
        prev.position.end = grandchild.position.end;
      }
      position2--;
    } else if (next && next.type === "WordNode") {
      children.splice(position2, 1);
      next.children.unshift(grandchild);
      if (grandchild.position && next.position) {
        next.position.start = grandchild.position.start;
      }
    }
  }
}
var makeInitialWhiteSpaceSiblings_1 = unistUtilVisitChildren(makeInitialWhiteSpaceSiblings);
function makeInitialWhiteSpaceSiblings(child, index2, parent) {
  var children = child.children;
  var next;
  if (children && children.length !== 0 && children[0].type === "WhiteSpaceNode") {
    parent.children.splice(index2, 0, children.shift());
    next = children[0];
    if (next && next.position && child.position) {
      child.position.start = next.position.start;
    }
  }
}
var makeFinalWhiteSpaceSiblings_1 = unistUtilModifyChildren(makeFinalWhiteSpaceSiblings);
function makeFinalWhiteSpaceSiblings(child, index2, parent) {
  var children = child.children;
  var prev;
  if (children && children.length !== 0 && children[children.length - 1].type === "WhiteSpaceNode") {
    parent.children.splice(index2 + 1, 0, child.children.pop());
    prev = children[children.length - 1];
    if (prev && prev.position && child.position) {
      child.position.end = prev.position.end;
    }
    return index2;
  }
}
var breakImplicitSentences_1 = unistUtilModifyChildren(breakImplicitSentences);
var multiNewLine = expressions.newLineMulti;
function breakImplicitSentences(child, index2, parent) {
  var children;
  var position2;
  var length2;
  var tail;
  var head2;
  var end2;
  var insertion;
  var node2;
  if (child.type !== "SentenceNode") {
    return;
  }
  children = child.children;
  length2 = children.length - 1;
  position2 = 0;
  while (++position2 < length2) {
    node2 = children[position2];
    if (node2.type !== "WhiteSpaceNode" || !multiNewLine.test(nlcstToString_1(node2))) {
      continue;
    }
    child.children = children.slice(0, position2);
    insertion = {
      type: "SentenceNode",
      children: children.slice(position2 + 1)
    };
    tail = children[position2 - 1];
    head2 = children[position2 + 1];
    parent.children.splice(index2 + 1, 0, node2, insertion);
    if (child.position && tail.position && head2.position) {
      end2 = child.position.end;
      child.position.end = tail.position.end;
      insertion.position = {
        start: head2.position.start,
        end: end2
      };
    }
    return index2 + 1;
  }
}
var removeEmptyNodes_1 = unistUtilModifyChildren(removeEmptyNodes);
function removeEmptyNodes(child, index2, parent) {
  if ("children" in child && child.children.length === 0) {
    parent.children.splice(index2, 1);
    return index2;
  }
}
var lib2 = ParseLatin;
function ParseLatin(doc, file) {
  var value2 = file || doc;
  if (!(this instanceof ParseLatin)) {
    return new ParseLatin(doc, file);
  }
  this.doc = value2 ? String(value2) : null;
}
var proto = ParseLatin.prototype;
proto.position = true;
proto.tokenizeSymbol = createTextFactory("Symbol");
proto.tokenizeWhiteSpace = createTextFactory("WhiteSpace");
proto.tokenizePunctuation = createTextFactory("Punctuation");
proto.tokenizeSource = createTextFactory("Source");
proto.tokenizeText = createTextFactory("Text");
proto.run = run;
proto.use = useFactory(function(context2, key, plugins) {
  context2[key] = context2[key].concat(plugins);
});
proto.useFirst = useFactory(function(context2, key, plugins) {
  context2[key] = plugins.concat(context2[key]);
});
proto.parse = function(value2) {
  return this.tokenizeRoot(value2 || this.doc);
};
proto.tokenize = function(value2) {
  return tokenize2(this, value2);
};
pluggable(ParseLatin, "tokenizeWord", function(value2, eat2) {
  var add = (eat2 || noopEat)("");
  var parent = { type: "WordNode", children: [] };
  this.tokenizeText(value2, eat2, parent);
  return add(parent);
});
pluggable(
  ParseLatin,
  "tokenizeSentence",
  parser2({
    type: "SentenceNode",
    tokenizer: "tokenize"
  })
);
pluggable(
  ParseLatin,
  "tokenizeParagraph",
  parser2({
    type: "ParagraphNode",
    delimiter: expressions.terminalMarker,
    delimiterType: "PunctuationNode",
    tokenizer: "tokenizeSentence"
  })
);
pluggable(
  ParseLatin,
  "tokenizeRoot",
  parser2({
    type: "RootNode",
    delimiter: expressions.newLine,
    delimiterType: "WhiteSpaceNode",
    tokenizer: "tokenizeParagraph"
  })
);
proto.use("tokenizeSentence", [
  mergeInitialWordSymbol_1,
  mergeFinalWordSymbol_1,
  mergeInnerWordSymbol_1,
  mergeInnerWordSlash_1,
  mergeInitialisms_1,
  mergeWords,
  patchPosition_1
]);
proto.use("tokenizeParagraph", [
  mergeNonWordSentences_1,
  mergeAffixSymbol_1,
  mergeInitialLowerCaseLetterSentences_1,
  mergeInitialDigitSentences_1,
  mergePrefixExceptions_1,
  mergeAffixExceptions_1,
  mergeRemainingFullStops_1,
  makeInitialWhiteSpaceSiblings_1,
  makeFinalWhiteSpaceSiblings_1,
  breakImplicitSentences_1,
  removeEmptyNodes_1,
  patchPosition_1
]);
proto.use("tokenizeRoot", [
  makeInitialWhiteSpaceSiblings_1,
  makeFinalWhiteSpaceSiblings_1,
  removeEmptyNodes_1,
  patchPosition_1
]);
function createTextFactory(type2) {
  type2 += "Node";
  return createText;
  function createText(value2, eat2, parent) {
    if (value2 === null || value2 === void 0) {
      value2 = "";
    }
    return (eat2 || noopEat)(value2)(
      {
        type: type2,
        value: String(value2)
      },
      parent
    );
  }
}
function run(key, nodes) {
  var wareKey = key + "Plugins";
  var plugins = this[wareKey];
  var index2 = -1;
  if (plugins) {
    while (plugins[++index2]) {
      plugins[index2](nodes);
    }
  }
  return nodes;
}
function pluggable(Constructor, key, callback) {
  Constructor.prototype[key] = function() {
    return this.run(key, callback.apply(this, arguments));
  };
}
function useFactory(callback) {
  return use;
  function use(key, plugins) {
    var self2 = this;
    var wareKey;
    if (!(key in self2)) {
      throw new Error(
        "Illegal Invocation: Unsupported `key` for `use(key, plugins)`. Make sure `key` is a supported function"
      );
    }
    if (!plugins) {
      return;
    }
    wareKey = key + "Plugins";
    if (typeof plugins === "function") {
      plugins = [plugins];
    } else {
      plugins = plugins.concat();
    }
    if (!self2[wareKey]) {
      self2[wareKey] = [];
    }
    callback(self2, wareKey, plugins);
  }
}
var wordRe = expressions.word;
var surrogatesRe = expressions.surrogates;
var punctuationRe = expressions.punctuation;
var whiteSpaceRe = expressions.whiteSpace;
function tokenize2(parser3, value2) {
  var tokens;
  var offset2;
  var line2;
  var column;
  var index2;
  var length2;
  var character;
  var queue;
  var prev;
  var left2;
  var right2;
  var eater;
  if (value2 === null || value2 === void 0) {
    value2 = "";
  } else if (value2 instanceof String) {
    value2 = value2.toString();
  }
  if (typeof value2 !== "string") {
    if ("length" in value2 && (!value2[0] || value2[0].type)) {
      return value2;
    }
    throw new Error(
      "Illegal invocation: '" + value2 + "' is not a valid argument for 'ParseLatin'"
    );
  }
  tokens = [];
  if (!value2) {
    return tokens;
  }
  index2 = 0;
  offset2 = 0;
  line2 = 1;
  column = 1;
  eater = parser3.position ? eat2 : noPositionEat;
  length2 = value2.length;
  prev = "";
  queue = "";
  while (index2 < length2) {
    character = value2.charAt(index2);
    if (whiteSpaceRe.test(character)) {
      right2 = "WhiteSpace";
    } else if (punctuationRe.test(character)) {
      right2 = "Punctuation";
    } else if (wordRe.test(character)) {
      right2 = "Word";
    } else {
      right2 = "Symbol";
    }
    tick();
    prev = character;
    character = "";
    left2 = right2;
    right2 = null;
    index2++;
  }
  tick();
  return tokens;
  function tick() {
    if (left2 === right2 && (left2 === "Word" || left2 === "WhiteSpace" || character === prev || surrogatesRe.test(character))) {
      queue += character;
    } else {
      if (queue) {
        parser3["tokenize" + left2](queue, eater);
      }
      queue = character;
    }
  }
  function eat2(subvalue) {
    var pos = position2();
    update(subvalue);
    return apply;
    function apply() {
      return pos(add.apply(null, arguments));
    }
  }
  function noPositionEat() {
    return apply;
    function apply() {
      return add.apply(null, arguments);
    }
  }
  function add(node2, parent) {
    if (parent) {
      parent.children.push(node2);
    } else {
      tokens.push(node2);
    }
    return node2;
  }
  function position2() {
    var before2 = now2();
    function patch2(node2) {
      node2.position = new Position3(before2);
      return node2;
    }
    return patch2;
  }
  function update(subvalue) {
    var subvalueLength = subvalue.length;
    var character2 = -1;
    var lastIndex = -1;
    offset2 += subvalueLength;
    while (++character2 < subvalueLength) {
      if (subvalue.charAt(character2) === "\n") {
        lastIndex = character2;
        line2++;
      }
    }
    if (lastIndex === -1) {
      column += subvalueLength;
    } else {
      column = subvalueLength - lastIndex;
    }
  }
  function Position3(start2) {
    this.start = start2;
    this.end = now2();
  }
  function now2() {
    return {
      line: line2,
      column,
      offset: offset2
    };
  }
}
function noopAdd(node2, parent) {
  if (parent) {
    parent.children.push(node2);
  }
  return node2;
}
function noopEat() {
  return noopAdd;
}
var parseLatin = lib2;
var retextLatin = parse$12;
parse$12.Parser = parseLatin;
function parse$12() {
  this.Parser = unherit_1(parseLatin);
}
var retextStringify = stringify$1;
function stringify$1() {
  this.Compiler = compiler;
}
function compiler(tree) {
  return nlcstToString_1(tree);
}
var retext = unified_1().use(retextLatin).use(retextStringify).freeze();
var retextSmartypants = smartypants;
var punctuation = "PunctuationNode";
var symbol = "SymbolNode";
var word = "WordNode";
var whiteSpace = "WhiteSpaceNode";
var decadeExpression = /^\d\ds$/;
var threeFullStopsExpression = /^\.{3,}$/;
var fullStopsExpression = /^\.+$/;
var threeDashes = "---";
var twoDashes = "--";
var emDash = "\u2014";
var enDash = "\u2013";
var ellipsis = "\u2026";
var twoBackticks = "``";
var backtick = "`";
var twoSingleQuotes = "''";
var singleQuote = "'";
var apostrophe = "\u2019";
var doubleQuote = '"';
var openingDoubleQuote = "\u201C";
var closingDoubleQuote = "\u201D";
var openingSingleQuote = "\u2018";
var closingSingleQuote = "\u2019";
var closingQuotes = {};
var openingQuotes = {};
openingQuotes[doubleQuote] = openingDoubleQuote;
closingQuotes[doubleQuote] = closingDoubleQuote;
openingQuotes[singleQuote] = openingSingleQuote;
closingQuotes[singleQuote] = closingSingleQuote;
var educators = {};
educators.dashes = {
  true: dashes,
  oldschool,
  inverted
};
educators.backticks = {
  true: backticks,
  all
};
educators.ellipses = {
  true: ellipses
};
educators.quotes = {
  true: quotes
};
function smartypants(options2) {
  var methods = [];
  var quotes2;
  var ellipses2;
  var backticks2;
  var dashes2;
  if (!options2) {
    options2 = {};
  }
  if ("quotes" in options2) {
    quotes2 = options2.quotes;
    if (quotes2 !== Boolean(quotes2)) {
      throw new TypeError(
        "Illegal invocation: `" + quotes2 + "` is not a valid value for `quotes` in `smartypants`"
      );
    }
  } else {
    quotes2 = true;
  }
  if ("ellipses" in options2) {
    ellipses2 = options2.ellipses;
    if (ellipses2 !== Boolean(ellipses2)) {
      throw new TypeError(
        "Illegal invocation: `" + ellipses2 + "` is not a valid value for `ellipses` in `smartypants`"
      );
    }
  } else {
    ellipses2 = true;
  }
  if ("backticks" in options2) {
    backticks2 = options2.backticks;
    if (backticks2 !== Boolean(backticks2) && backticks2 !== "all") {
      throw new TypeError(
        "Illegal invocation: `" + backticks2 + "` is not a valid value for `backticks` in `smartypants`"
      );
    }
    if (backticks2 === "all" && quotes2 === true) {
      throw new TypeError(
        "Illegal invocation: `backticks: " + backticks2 + "` is not a valid value when `quotes: " + quotes2 + "` in `smartypants`"
      );
    }
  } else {
    backticks2 = true;
  }
  if ("dashes" in options2) {
    dashes2 = options2.dashes;
    if (dashes2 !== Boolean(dashes2) && dashes2 !== "oldschool" && dashes2 !== "inverted") {
      throw new TypeError(
        "Illegal invocation: `" + dashes2 + "` is not a valid value for `dahes` in `smartypants`"
      );
    }
  } else {
    dashes2 = true;
  }
  if (quotes2 !== false) {
    methods.push(educators.quotes[quotes2]);
  }
  if (ellipses2 !== false) {
    methods.push(educators.ellipses[ellipses2]);
  }
  if (backticks2 !== false) {
    methods.push(educators.backticks[backticks2]);
  }
  if (dashes2 !== false) {
    methods.push(educators.dashes[dashes2]);
  }
  return transformFactory(methods);
}
function transformFactory(methods) {
  var length2 = methods.length;
  return transformer;
  function transformer(tree) {
    unistUtilVisit(tree, visitor);
  }
  function visitor(node2, position2, parent) {
    var index2 = -1;
    if (node2.type === punctuation || node2.type === symbol) {
      while (++index2 < length2) {
        methods[index2](node2, position2, parent);
      }
    }
  }
}
function oldschool(node2) {
  if (node2.value === threeDashes) {
    node2.value = emDash;
  } else if (node2.value === twoDashes) {
    node2.value = enDash;
  }
}
function dashes(node2) {
  if (node2.value === twoDashes) {
    node2.value = emDash;
  }
}
function inverted(node2) {
  if (node2.value === threeDashes) {
    node2.value = enDash;
  } else if (node2.value === twoDashes) {
    node2.value = emDash;
  }
}
function backticks(node2) {
  if (node2.value === twoBackticks) {
    node2.value = openingDoubleQuote;
  } else if (node2.value === twoSingleQuotes) {
    node2.value = closingDoubleQuote;
  }
}
function all(node2) {
  backticks(node2);
  if (node2.value === backtick) {
    node2.value = openingSingleQuote;
  } else if (node2.value === singleQuote) {
    node2.value = closingSingleQuote;
  }
}
function ellipses(node2, index2, parent) {
  var value2 = node2.value;
  var siblings2 = parent.children;
  var position2;
  var nodes;
  var sibling;
  var type2;
  var count;
  var queue;
  if (threeFullStopsExpression.test(node2.value)) {
    node2.value = ellipsis;
    return;
  }
  if (!fullStopsExpression.test(value2)) {
    return;
  }
  nodes = [];
  position2 = index2;
  count = 1;
  while (--position2 > 0) {
    sibling = siblings2[position2];
    if (sibling.type !== whiteSpace) {
      break;
    }
    queue = sibling;
    sibling = siblings2[--position2];
    type2 = sibling && sibling.type;
    if (sibling && (type2 === punctuation || type2 === symbol) && fullStopsExpression.test(sibling.value)) {
      nodes.push(queue, sibling);
      count++;
      continue;
    }
    break;
  }
  if (count < 3) {
    return;
  }
  siblings2.splice(index2 - nodes.length, nodes.length);
  node2.value = ellipsis;
}
function quotes(node2, index2, parent) {
  var siblings2 = parent.children;
  var value2 = node2.value;
  var next;
  var nextNext;
  var prev;
  var nextValue;
  if (value2 !== doubleQuote && value2 !== singleQuote) {
    return;
  }
  prev = siblings2[index2 - 1];
  next = siblings2[index2 + 1];
  nextNext = siblings2[index2 + 2];
  nextValue = next && nlcstToString_1(next);
  if (next && nextNext && (next.type === punctuation || next.type === symbol) && nextNext.type !== word) {
    node2.value = closingQuotes[value2];
  } else if (nextNext && (nextValue === doubleQuote || nextValue === singleQuote) && nextNext.type === word) {
    node2.value = openingQuotes[value2];
    next.value = openingQuotes[nextValue];
  } else if (next && decadeExpression.test(nextValue)) {
    node2.value = closingQuotes[value2];
  } else if (prev && next && (prev.type === whiteSpace || prev.type === punctuation || prev.type === symbol) && next.type === word) {
    node2.value = openingQuotes[value2];
  } else if (prev && prev.type !== whiteSpace && prev.type !== symbol && prev.type !== punctuation) {
    node2.value = closingQuotes[value2];
  } else if (!next || next.type === whiteSpace || (value2 === singleQuote || value2 === apostrophe) && nextValue === "s") {
    node2.value = closingQuotes[value2];
  } else {
    node2.value = openingQuotes[value2];
  }
}
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject2(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence2) {
  if (Array.isArray(sequence2))
    return sequence2;
  else if (isNothing(sequence2))
    return [];
  return [sequence2];
}
function extend3(target2, source) {
  var index2, length2, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index2 = 0, length2 = sourceKeys.length; index2 < length2; index2 += 1) {
      key = sourceKeys[index2];
      target2[key] = source[key];
    }
  }
  return target2;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number2) {
  return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject2;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend3;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function YAMLException$1(reason, mark2) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark2;
  this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString6(compact) {
  var result = this.name + ": ";
  result += this.reason || "(unknown reason)";
  if (!compact && this.mark) {
    result += " " + this.mark.toString();
  }
  return result;
};
var exception = YAMLException$1;
function Mark(name2, buffer, position2, line2, column) {
  this.name = name2;
  this.buffer = buffer;
  this.position = position2;
  this.line = line2;
  this.column = column;
}
Mark.prototype.getSnippet = function getSnippet(indent2, maxLength) {
  var head2, start2, tail, end2, snippet;
  if (!this.buffer)
    return null;
  indent2 = indent2 || 4;
  maxLength = maxLength || 75;
  head2 = "";
  start2 = this.position;
  while (start2 > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start2 - 1)) === -1) {
    start2 -= 1;
    if (this.position - start2 > maxLength / 2 - 1) {
      head2 = " ... ";
      start2 += 5;
      break;
    }
  }
  tail = "";
  end2 = this.position;
  while (end2 < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end2)) === -1) {
    end2 += 1;
    if (end2 - this.position > maxLength / 2 - 1) {
      tail = " ... ";
      end2 -= 5;
      break;
    }
  }
  snippet = this.buffer.slice(start2, end2);
  return common.repeat(" ", indent2) + head2 + snippet + tail + "\n" + common.repeat(" ", indent2 + this.position - start2 + head2.length) + "^";
};
Mark.prototype.toString = function toString7(compact) {
  var snippet, where = "";
  if (this.name) {
    where += 'in "' + this.name + '" ';
  }
  where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
  if (!compact) {
    snippet = this.getSnippet();
    if (snippet) {
      where += ":\n" + snippet;
    }
  }
  return where;
};
var mark = Mark;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag3, options2) {
  options2 = options2 || {};
  Object.keys(options2).forEach(function(name2) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name2) === -1) {
      throw new exception('Unknown option "' + name2 + '" is met in definition of "' + tag3 + '" YAML type.');
    }
  });
  this.tag = tag3;
  this.kind = options2["kind"] || null;
  this.resolve = options2["resolve"] || function() {
    return true;
  };
  this.construct = options2["construct"] || function(data3) {
    return data3;
  };
  this.instanceOf = options2["instanceOf"] || null;
  this.predicate = options2["predicate"] || null;
  this.represent = options2["represent"] || null;
  this.defaultStyle = options2["defaultStyle"] || null;
  this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag3 + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name2, result) {
  var exclude = [];
  schema2.include.forEach(function(includedSchema) {
    result = compileList(includedSchema, name2, result);
  });
  schema2[name2].forEach(function(currentType) {
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });
    result.push(currentType);
  });
  return result.filter(function(type2, index2) {
    return exclude.indexOf(index2) === -1;
  });
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {}
  }, index2, length2;
  function collectType(type2) {
    result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
  }
  for (index2 = 0, length2 = arguments.length; index2 < length2; index2 += 1) {
    arguments[index2].forEach(collectType);
  }
  return result;
}
function Schema$1(definition2) {
  this.include = definition2.include || [];
  this.implicit = definition2.implicit || [];
  this.explicit = definition2.explicit || [];
  this.implicit.forEach(function(type2) {
    if (type2.loadKind && type2.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
  });
  this.compiledImplicit = compileList(this, "implicit", []);
  this.compiledExplicit = compileList(this, "explicit", []);
  this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
}
Schema$1.DEFAULT = null;
Schema$1.create = function createSchema() {
  var schemas, types3;
  switch (arguments.length) {
    case 1:
      schemas = Schema$1.DEFAULT;
      types3 = arguments[0];
      break;
    case 2:
      schemas = arguments[0];
      types3 = arguments[1];
      break;
    default:
      throw new exception("Wrong number of arguments for Schema.create function");
  }
  schemas = common.toArray(schemas);
  types3 = common.toArray(types3);
  if (!schemas.every(function(schema2) {
    return schema2 instanceof Schema$1;
  })) {
    throw new exception("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
  }
  if (!types3.every(function(type$1) {
    return type$1 instanceof type;
  })) {
    throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  }
  return new Schema$1({
    include: schemas,
    explicit: types3
  });
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data3) {
    return data3 !== null ? data3 : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data3) {
    return data3 !== null ? data3 : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data3) {
    return data3 !== null ? data3 : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data3) {
  if (data3 === null)
    return true;
  var max = data3.length;
  return max === 1 && data3 === "~" || max === 4 && (data3 === "null" || data3 === "Null" || data3 === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data3) {
  if (data3 === null)
    return false;
  var max = data3.length;
  return max === 4 && (data3 === "true" || data3 === "True" || data3 === "TRUE") || max === 5 && (data3 === "false" || data3 === "False" || data3 === "FALSE");
}
function constructYamlBoolean(data3) {
  return data3 === "true" || data3 === "True" || data3 === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c2) {
  return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
}
function isOctCode(c2) {
  return 48 <= c2 && c2 <= 55;
}
function isDecCode(c2) {
  return 48 <= c2 && c2 <= 57;
}
function resolveYamlInteger(data3) {
  if (data3 === null)
    return false;
  var max = data3.length, index2 = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data3[index2];
  if (ch === "-" || ch === "+") {
    ch = data3[++index2];
  }
  if (ch === "0") {
    if (index2 + 1 === max)
      return true;
    ch = data3[++index2];
    if (ch === "b") {
      index2++;
      for (; index2 < max; index2++) {
        ch = data3[index2];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index2++;
      for (; index2 < max; index2++) {
        ch = data3[index2];
        if (ch === "_")
          continue;
        if (!isHexCode(data3.charCodeAt(index2)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    for (; index2 < max; index2++) {
      ch = data3[index2];
      if (ch === "_")
        continue;
      if (!isOctCode(data3.charCodeAt(index2)))
        return false;
      hasDigits = true;
    }
    return hasDigits && ch !== "_";
  }
  if (ch === "_")
    return false;
  for (; index2 < max; index2++) {
    ch = data3[index2];
    if (ch === "_")
      continue;
    if (ch === ":")
      break;
    if (!isDecCode(data3.charCodeAt(index2))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  if (ch !== ":")
    return true;
  return /^(:[0-5]?[0-9])+$/.test(data3.slice(index2));
}
function constructYamlInteger(data3) {
  var value2 = data3, sign = 1, ch, base, digits = [];
  if (value2.indexOf("_") !== -1) {
    value2 = value2.replace(/_/g, "");
  }
  ch = value2[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value2 = value2.slice(1);
    ch = value2[0];
  }
  if (value2 === "0")
    return 0;
  if (ch === "0") {
    if (value2[1] === "b")
      return sign * parseInt(value2.slice(2), 2);
    if (value2[1] === "x")
      return sign * parseInt(value2, 16);
    return sign * parseInt(value2, 8);
  }
  if (value2.indexOf(":") !== -1) {
    value2.split(":").forEach(function(v) {
      digits.unshift(parseInt(v, 10));
    });
    value2 = 0;
    base = 1;
    digits.forEach(function(d) {
      value2 += d * base;
      base *= 60;
    });
    return sign * value2;
  }
  return sign * parseInt(value2, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int_1 = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data3) {
  if (data3 === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data3) || data3[data3.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data3) {
  var value2, sign, base, digits;
  value2 = data3.replace(/_/g, "").toLowerCase();
  sign = value2[0] === "-" ? -1 : 1;
  digits = [];
  if ("+-".indexOf(value2[0]) >= 0) {
    value2 = value2.slice(1);
  }
  if (value2 === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value2 === ".nan") {
    return NaN;
  } else if (value2.indexOf(":") >= 0) {
    value2.split(":").forEach(function(v) {
      digits.unshift(parseFloat(v, 10));
    });
    value2 = 0;
    base = 1;
    digits.forEach(function(d) {
      value2 += d * base;
      base *= 60;
    });
    return sign * value2;
  }
  return sign * parseFloat(value2, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res2;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res2 = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res2) ? res2.replace("e", ".e") : res2;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float_1 = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = new schema({
  include: [
    failsafe
  ],
  implicit: [
    _null,
    bool,
    int_1,
    float_1
  ]
});
var core = new schema({
  include: [
    json
  ]
});
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data3) {
  if (data3 === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data3) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data3) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data3) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta2 = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data3);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data3);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta2 = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta2 = -delta2;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta2)
    date.setTime(date.getTime() - delta2);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data3) {
  return data3 === "<<" || data3 === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var NodeBuffer;
try {
  _require$1 = commonjsRequire;
  NodeBuffer = _require$1("buffer").Buffer;
} catch (__) {
}
var _require$1;
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data3) {
  if (data3 === null)
    return false;
  var code2, idx, bitlen = 0, max = data3.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code2 = map2.indexOf(data3.charAt(idx));
    if (code2 > 64)
      continue;
    if (code2 < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data3) {
  var idx, tailbits, input = data3.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  if (NodeBuffer) {
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }
  return result;
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data3) {
  if (data3 === null)
    return true;
  var objectKeys = [], index2, length2, pair, pairKey, pairHasKey, object = data3;
  for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
    pair = object[index2];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data3) {
  return data3 !== null ? data3 : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data3) {
  if (data3 === null)
    return true;
  var index2, length2, pair, keys2, result, object = data3;
  result = new Array(object.length);
  for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
    pair = object[index2];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys2 = Object.keys(pair);
    if (keys2.length !== 1)
      return false;
    result[index2] = [keys2[0], pair[keys2[0]]];
  }
  return true;
}
function constructYamlPairs(data3) {
  if (data3 === null)
    return [];
  var index2, length2, pair, keys2, result, object = data3;
  result = new Array(object.length);
  for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
    pair = object[index2];
    keys2 = Object.keys(pair);
    result[index2] = [keys2[0], pair[keys2[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data3) {
  if (data3 === null)
    return true;
  var key, object = data3;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data3) {
  return data3 !== null ? data3 : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var default_safe = new schema({
  include: [
    core
  ],
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
function resolveJavascriptUndefined() {
  return true;
}
function constructJavascriptUndefined() {
  return void 0;
}
function representJavascriptUndefined() {
  return "";
}
function isUndefined(object) {
  return typeof object === "undefined";
}
var _undefined = new type("tag:yaml.org,2002:js/undefined", {
  kind: "scalar",
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});
function resolveJavascriptRegExp(data3) {
  if (data3 === null)
    return false;
  if (data3.length === 0)
    return false;
  var regexp2 = data3, tail = /\/([gim]*)$/.exec(data3), modifiers = "";
  if (regexp2[0] === "/") {
    if (tail)
      modifiers = tail[1];
    if (modifiers.length > 3)
      return false;
    if (regexp2[regexp2.length - modifiers.length - 1] !== "/")
      return false;
  }
  return true;
}
function constructJavascriptRegExp(data3) {
  var regexp2 = data3, tail = /\/([gim]*)$/.exec(data3), modifiers = "";
  if (regexp2[0] === "/") {
    if (tail)
      modifiers = tail[1];
    regexp2 = regexp2.slice(1, regexp2.length - modifiers.length - 1);
  }
  return new RegExp(regexp2, modifiers);
}
function representJavascriptRegExp(object) {
  var result = "/" + object.source + "/";
  if (object.global)
    result += "g";
  if (object.multiline)
    result += "m";
  if (object.ignoreCase)
    result += "i";
  return result;
}
function isRegExp(object) {
  return Object.prototype.toString.call(object) === "[object RegExp]";
}
var regexp = new type("tag:yaml.org,2002:js/regexp", {
  kind: "scalar",
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});
var esprima;
try {
  _require = commonjsRequire;
  esprima = _require("esprima");
} catch (_) {
  if (typeof window !== "undefined")
    esprima = window.esprima;
}
var _require;
function resolveJavascriptFunction(data3) {
  if (data3 === null)
    return false;
  try {
    var source = "(" + data3 + ")", ast2 = esprima.parse(source, { range: true });
    if (ast2.type !== "Program" || ast2.body.length !== 1 || ast2.body[0].type !== "ExpressionStatement" || ast2.body[0].expression.type !== "ArrowFunctionExpression" && ast2.body[0].expression.type !== "FunctionExpression") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
function constructJavascriptFunction(data3) {
  var source = "(" + data3 + ")", ast2 = esprima.parse(source, { range: true }), params = [], body2;
  if (ast2.type !== "Program" || ast2.body.length !== 1 || ast2.body[0].type !== "ExpressionStatement" || ast2.body[0].expression.type !== "ArrowFunctionExpression" && ast2.body[0].expression.type !== "FunctionExpression") {
    throw new Error("Failed to resolve function");
  }
  ast2.body[0].expression.params.forEach(function(param) {
    params.push(param.name);
  });
  body2 = ast2.body[0].expression.body.range;
  if (ast2.body[0].expression.body.type === "BlockStatement") {
    return new Function(params, source.slice(body2[0] + 1, body2[1] - 1));
  }
  return new Function(params, "return " + source.slice(body2[0], body2[1]));
}
function representJavascriptFunction(object) {
  return object.toString();
}
function isFunction(object) {
  return Object.prototype.toString.call(object) === "[object Function]";
}
var _function = new type("tag:yaml.org,2002:js/function", {
  kind: "scalar",
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});
var default_full = schema.DEFAULT = new schema({
  include: [
    default_safe
  ],
  explicit: [
    _undefined,
    regexp,
    _function
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c2) {
  return c2 === 10 || c2 === 13;
}
function is_WHITE_SPACE(c2) {
  return c2 === 9 || c2 === 32;
}
function is_WS_OR_EOL(c2) {
  return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
}
function is_FLOW_INDICATOR(c2) {
  return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
}
function fromHexCode(c2) {
  var lc;
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  lc = c2 | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c2) {
  if (c2 === 120) {
    return 2;
  }
  if (c2 === 117) {
    return 4;
  }
  if (c2 === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c2) {
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  return -1;
}
function simpleEscapeSequence(c2) {
  return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
}
function charFromCodepoint(c2) {
  if (c2 <= 65535) {
    return String.fromCharCode(c2);
  }
  return String.fromCharCode(
    (c2 - 65536 >> 10) + 55296,
    (c2 - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options2) {
  this.input = input;
  this.filename = options2["filename"] || null;
  this.schema = options2["schema"] || default_full;
  this.onWarning = options2["onWarning"] || null;
  this.legacy = options2["legacy"] || false;
  this.json = options2["json"] || false;
  this.listener = options2["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.documents = [];
}
function generateError(state, message2) {
  return new exception(
    message2,
    new mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart)
  );
}
function throwError(state, message2) {
  throw generateError(state, message2);
}
function throwWarning(state, message2) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message2));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name2, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name2, args) {
    var handle2, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle2 = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle2)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle2)) {
      throwError(state, 'there is a previously declared suffix for "' + handle2 + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    state.tagMap[handle2] = prefix;
  }
};
function captureSegment(state, start2, end2, checkJson) {
  var _position, _length, _character, _result;
  if (start2 < end2) {
    _result = state.input.slice(start2, end2);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index2, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
    key = sourceKeys[index2];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index2, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
      if (Array.isArray(keyNode[index2])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
        keyNode[index2] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
        mergeMappings(state, _result, valueNode[index2], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    _pos = state.position;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    } else {
      break;
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if (state.lineIndent > nodeIndent && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag !== null && state.tag !== "!") {
    if (state.tag === "?") {
      if (state.result !== null && state.kind !== "scalar") {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type2 = state.implicitTypes[typeIndex];
        if (type2.resolve(state.result)) {
          state.result = type2.construct(state.result);
          state.tag = type2.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
      if (state.result !== null && type2.kind !== state.kind) {
        throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
      }
      if (!type2.resolve(state.result)) {
        throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
      } else {
        state.result = type2.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options2) {
  input = String(input);
  options2 = options2 || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options2);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options2) {
  if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
    options2 = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options2);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index2 = 0, length2 = documents.length; index2 < length2; index2 += 1) {
    iterator(documents[index2]);
  }
}
function load$1(input, options2) {
  var documents = loadDocuments(input, options2);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
function safeLoadAll$1(input, iterator, options2) {
  if (typeof iterator === "object" && iterator !== null && typeof options2 === "undefined") {
    options2 = iterator;
    iterator = null;
  }
  return loadAll$1(input, iterator, common.extend({ schema: default_safe }, options2));
}
function safeLoad$1(input, options2) {
  return load$1(input, common.extend({ schema: default_safe }, options2));
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var safeLoadAll_1 = safeLoadAll$1;
var safeLoad_1 = safeLoad$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1,
  safeLoadAll: safeLoadAll_1,
  safeLoad: safeLoad_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
function compileStyleMap(schema2, map2) {
  var result, keys2, index2, length2, tag3, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys2 = Object.keys(map2);
  for (index2 = 0, length2 = keys2.length; index2 < length2; index2 += 1) {
    tag3 = keys2[index2];
    style = String(map2[tag3]);
    if (tag3.slice(0, 2) === "!!") {
      tag3 = "tag:yaml.org,2002:" + tag3.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag3];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag3] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle2, length2;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle2 = "x";
    length2 = 2;
  } else if (character <= 65535) {
    handle2 = "u";
    length2 = 4;
  } else if (character <= 4294967295) {
    handle2 = "U";
    length2 = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle2 + common.repeat("0", length2 - string.length) + string;
}
function State(options2) {
  this.schema = options2["schema"] || default_full;
  this.indent = Math.max(1, options2["indent"] || 2);
  this.noArrayIndent = options2["noArrayIndent"] || false;
  this.skipInvalid = options2["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
  this.sortKeys = options2["sortKeys"] || false;
  this.lineWidth = options2["lineWidth"] || 80;
  this.noRefs = options2["noRefs"] || false;
  this.noCompatMode = options2["noCompatMode"] || false;
  this.condenseFlow = options2["condenseFlow"] || false;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces2) {
  var ind = common.repeat(" ", spaces2), position2 = 0, next = -1, result = "", line2, length2 = string.length;
  while (position2 < length2) {
    next = string.indexOf("\n", position2);
    if (next === -1) {
      line2 = string.slice(position2);
      position2 = length2;
    } else {
      line2 = string.slice(position2, next + 1);
      position2 = next + 1;
    }
    if (line2.length && line2 !== "\n")
      result += ind;
    result += line2;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index2, length2, type2;
  for (index2 = 0, length2 = state.implicitTypes.length; index2 < length2; index2 += 1) {
    type2 = state.implicitTypes[index2];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c2) {
  return c2 === CHAR_SPACE || c2 === CHAR_TAB;
}
function isPrintable(c2) {
  return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== 65279 || 65536 <= c2 && c2 <= 1114111;
}
function isNsChar(c2) {
  return isPrintable(c2) && !isWhitespace(c2) && c2 !== 65279 && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
}
function isPlainSafe(c2, prev) {
  return isPrintable(c2) && c2 !== 65279 && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_COLON && (c2 !== CHAR_SHARP || prev && isNsChar(prev));
}
function isPlainSafeFirst(c2) {
  return isPrintable(c2) && c2 !== 65279 && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char, prev_char;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
  if (singleLineOnly) {
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
  } else {
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}
function writeScalar(state, string, level, iskey) {
  state.dump = function() {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }
    var indent2 = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent2);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent2));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent2));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line2 = match[2];
    moreIndented = line2[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line2 !== "" ? "\n" : "") + foldLine(line2, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line2, width) {
  if (line2 === "" || line2[0] === " ")
    return line2;
  var breakRe = / [^ ]/g;
  var match;
  var start2 = 0, end2, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line2)) {
    next = match.index;
    if (next - start2 > width) {
      end2 = curr > start2 ? curr : next;
      result += "\n" + line2.slice(start2, end2);
      start2 = end2 + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line2.length - start2 > width && curr > start2) {
    result += line2.slice(start2, curr) + "\n" + line2.slice(curr + 1);
  } else {
    result += line2.slice(start2);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char, nextChar;
  var escapeSeq;
  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    if (char >= 55296 && char <= 56319) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 56320 && nextChar <= 57343) {
        result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
        i++;
        continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index2, length2;
  for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
    if (writeNode(state, level, object[index2], false, false)) {
      if (index2 !== 0)
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index2, length2;
  for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
    if (writeNode(state, level + 1, object[index2], true, true)) {
      if (!compact || index2 !== 0) {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length2, objectKey, objectValue, pairBuffer;
  for (index2 = 0, length2 = objectKeyList.length; index2 < length2; index2 += 1) {
    pairBuffer = "";
    if (index2 !== 0)
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index2];
    objectValue = object[objectKey];
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length2, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index2 = 0, length2 = objectKeyList.length; index2 < length2; index2 += 1) {
    pairBuffer = "";
    if (!compact || index2 !== 0) {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index2];
    objectValue = object[objectKey];
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index2, length2, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index2 = 0, length2 = typeList.length; index2 < length2; index2 += 1) {
    type2 = typeList[index2];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      state.tag = explicit ? type2.tag : "?";
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block2, compact, iskey) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  if (block2) {
    block2 = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block2 && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
      if (block2 && state.dump.length !== 0) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      state.dump = "!<" + state.tag + "> " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index2, length2;
  inspectNode(object, objects, duplicatesIndexes);
  for (index2 = 0, length2 = duplicatesIndexes.length; index2 < length2; index2 += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index2]]);
  }
  state.usedDuplicates = new Array(length2);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index2, length2;
  if (object !== null && typeof object === "object") {
    index2 = objects.indexOf(object);
    if (index2 !== -1) {
      if (duplicatesIndexes.indexOf(index2) === -1) {
        duplicatesIndexes.push(index2);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
          inspectNode(object[index2], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index2 = 0, length2 = objectKeyList.length; index2 < length2; index2 += 1) {
          inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options2) {
  options2 = options2 || {};
  var state = new State(options2);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  if (writeNode(state, 0, input, true, true))
    return state.dump + "\n";
  return "";
}
function safeDump$1(input, options2) {
  return dump$1(input, common.extend({ schema: default_safe }, options2));
}
var dump_1 = dump$1;
var safeDump_1 = safeDump$1;
var dumper = {
  dump: dump_1,
  safeDump: safeDump_1
};
function deprecated(name2) {
  return function() {
    throw new Error("Function " + name2 + " is deprecated and cannot be used.");
  };
}
var Type = type;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json;
var CORE_SCHEMA = core;
var DEFAULT_SAFE_SCHEMA = default_safe;
var DEFAULT_FULL_SCHEMA = default_full;
var load = loader.load;
var loadAll = loader.loadAll;
var safeLoad = loader.safeLoad;
var safeLoadAll = loader.safeLoadAll;
var dump = dumper.dump;
var safeDump = dumper.safeDump;
var YAMLException = exception;
var MINIMAL_SCHEMA = failsafe;
var SAFE_SCHEMA = default_safe;
var DEFAULT_SCHEMA = default_full;
var scan = deprecated("scan");
var parse4 = deprecated("parse");
var compose = deprecated("compose");
var addConstructor = deprecated("addConstructor");
var jsYaml$1 = {
  Type,
  Schema,
  FAILSAFE_SCHEMA,
  JSON_SCHEMA,
  CORE_SCHEMA,
  DEFAULT_SAFE_SCHEMA,
  DEFAULT_FULL_SCHEMA,
  load,
  loadAll,
  safeLoad,
  safeLoadAll,
  dump,
  safeDump,
  YAMLException,
  MINIMAL_SCHEMA,
  SAFE_SCHEMA,
  DEFAULT_SCHEMA,
  scan,
  parse: parse4,
  compose,
  addConstructor
};
var jsYaml = jsYaml$1;
var matchHtmlRegExp = /["'&<>]/;
var escapeHtml_1 = escapeHtml;
function escapeHtml(string) {
  var str2 = "" + string;
  var match = matchHtmlRegExp.exec(str2);
  if (!match) {
    return str2;
  }
  var escape2;
  var html2 = "";
  var index2 = 0;
  var lastIndex = 0;
  for (index2 = match.index; index2 < str2.length; index2++) {
    switch (str2.charCodeAt(index2)) {
      case 34:
        escape2 = "&quot;";
        break;
      case 38:
        escape2 = "&amp;";
        break;
      case 39:
        escape2 = "&#39;";
        break;
      case 60:
        escape2 = "&lt;";
        break;
      case 62:
        escape2 = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index2) {
      html2 += str2.substring(lastIndex, index2);
    }
    lastIndex = index2 + 1;
    html2 += escape2;
  }
  return lastIndex !== index2 ? html2 + str2.substring(lastIndex, index2) : html2;
}
function _optionalChain(ops) {
  let lastAccessLHS = void 0;
  let value2 = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i];
    const fn = ops[i + 1];
    i += 2;
    if ((op === "optionalAccess" || op === "optionalCall") && value2 == null) {
      return void 0;
    }
    if (op === "access" || op === "optionalAccess") {
      lastAccessLHS = value2;
      value2 = fn(value2);
    } else if (op === "call" || op === "optionalCall") {
      value2 = fn((...args) => value2.call(lastAccessLHS, ...args));
      lastAccessLHS = void 0;
    }
  }
  return value2;
}
var newline = "\n";
function default_frontmatter(value2, messages2) {
  try {
    return jsYaml.safeLoad(value2);
  } catch (e) {
    messages2.push(new vfileMessage("YAML failed to parse"));
  }
}
function parse_frontmatter({
  parse: parse5,
  type: type2
}) {
  const transformer = (tree, vFile) => {
    unistUtilVisit(tree, type2, (node2) => {
      const data3 = parse5(node2.value, vFile.messages);
      if (data3) {
        vFile.data.fm = data3;
      }
    });
  };
  return transformer;
}
var entites = [
  [/</g, "&lt;"],
  [/>/g, "&gt;"],
  [/{/g, "&#123;"],
  [/}/g, "&#125;"]
];
function escape_code({ blocks }) {
  return function(tree) {
    if (!blocks) {
      unistUtilVisit(tree, "code", escape2);
    }
    unistUtilVisit(tree, "inlineCode", escape2);
    function escape2(node2) {
      for (let i = 0; i < entites.length; i += 1) {
        node2.value = node2.value.replace(entites[i][0], entites[i][1]);
      }
    }
  };
}
function smartypants_transformer(options2 = {}) {
  const processor = retext().use(retextSmartypants, options2);
  return function(tree) {
    unistUtilVisit(tree, "text", (node2) => {
      node2.value = String(processor.processSync(node2.value));
    });
  };
}
var attrs = `(?:\\s{0,1}[a-zA-z]+=(?:"){0,1}[a-zA-Z0-9]+(?:"){0,1})*`;
var context = `(?:\\s{0,1}context)=(?:"){0,1}module(?:"){0,1}`;
var RE_BLANK = /^\n+$|^\s+$/;
var RE_SCRIPT = new RegExp(`^(<script` + attrs + `>)`);
var RE_MODULE_SCRIPT = new RegExp(
  `^(<script` + attrs + context + attrs + `>)`
);
function extract_parts(nodes) {
  const parts = {
    special: [],
    html: [],
    instance: [],
    module: [],
    css: []
  };
  children:
    for (let i = 0; i < nodes.length; i += 1) {
      const empty_node = nodes[i].type === "text" && RE_BLANK.exec(nodes[i].value);
      if (empty_node || !nodes[i].value) {
        if (!parts.html.length || !(RE_BLANK.exec(nodes[i].value) && RE_BLANK.exec(parts.html[parts.html.length - 1].value))) {
          parts.html.push(nodes[i]);
        }
        continue children;
      }
      let result;
      try {
        result = parse$3(nodes[i].value);
      } catch (e) {
        parts.html.push(nodes[i]);
        continue children;
      }
      if (!result.html || !result.html.children)
        return parts;
      const _parts = result.html.children.map((v) => {
        if (v.type === "Options" || v.type === "Head" || v.type === "Window" || v.type === "Body") {
          return ["special", v.start, v.end];
        } else {
          return ["html", v.start, v.end];
        }
      });
      results:
        for (const key in result) {
          if (key === "html" || !result[key])
            continue results;
          _parts.push([
            key,
            result[key].start,
            result[key].end
          ]);
        }
      const sorted = _parts.sort((a, b) => a[1] - b[1]);
      sorted.forEach((next) => {
        parts[next[0]].push({
          type: "raw",
          value: nodes[i].value.substring(next[1], next[2])
        });
      });
    }
  return parts;
}
function map_layout_to_path(filename, layout_map) {
  const match = Object.keys(layout_map).find(
    (l2) => new RegExp(`\\${path.sep}${l2}\\${path.sep}`).test(
      path.normalize(filename).replace(process.cwd(), "")
    )
  );
  if (match) {
    return layout_map[match];
  } else {
    return layout_map["_"] ? layout_map["_"] : void 0;
  }
}
function generate_layout_import(layout) {
  if (!layout)
    return false;
  return `import Layout_MDSVEX_DEFAULT${layout.components.length ? `, * as Components` : ""} from '${layout.path}';`;
}
function generate_layout({
  frontmatter_layout,
  layout_options,
  layout_mode,
  filename
}) {
  let selected_layout;
  const error2 = { reason: "" };
  if (!layout_options || frontmatter_layout === false) {
    return [false, false, false];
  } else if (layout_mode === "single") {
    selected_layout = layout_options.__mdsvex_default;
    if (frontmatter_layout)
      error2.reason = `You attempted to apply a named layout in the front-matter of "${filename}", but did not provide any named layouts as options to the preprocessor. `;
  } else if (frontmatter_layout) {
    selected_layout = layout_options[frontmatter_layout];
    if (!selected_layout)
      error2.reason = `Could not find a layout with the name "${frontmatter_layout}" and no fall back layout ("_") was provided.`;
  } else {
    selected_layout = map_layout_to_path(filename, layout_options);
  }
  return [
    generate_layout_import(selected_layout),
    selected_layout !== void 0 && selected_layout.components.length > 0 && selected_layout.components,
    error2.reason ? error2 : false
  ];
}
function transform_hast({
  layout,
  layout_mode
}) {
  return function transformer(tree, vFile) {
    unistUtilVisit(tree, "element", (node2) => {
      if (node2.tagName === "a" && node2.properties && typeof node2.properties.href === "string") {
        node2.properties.href = node2.properties.href.replace(/%7B/g, "{").replace(/%7D/g, "}");
      }
      if (node2.tagName === "img" && node2.properties && typeof node2.properties.src === "string") {
        node2.properties.src = node2.properties.src.replace(/%7B/g, "{").replace(/%7D/g, "}");
      }
    });
    if (!layout && !vFile.data.fm)
      return tree;
    unistUtilVisit(tree, "root", (node2) => {
      const { special, html: html2, instance, module: _module, css } = extract_parts(
        node2.children
      );
      const { fm: metadata } = vFile.data;
      const stringified = metadata && JSON.stringify(metadata).replace(/<(\/?script|\/?style)/g, '<"+"$1');
      const fm = metadata && `export const metadata = ${stringified};${newline}	const { ${Object.keys(metadata).join(", ")} } = metadata;`;
      const frontmatter_layout = metadata && metadata.layout;
      const [import_script, components, error2] = generate_layout({
        frontmatter_layout,
        layout_options: layout,
        layout_mode,
        filename: vFile.filename
      });
      if (error2)
        vFile.messages.push(new vfileMessage(error2.reason));
      if (components) {
        for (let i = 0; i < components.length; i++) {
          unistUtilVisit(tree, "element", (node3) => {
            if (node3.tagName === components[i]) {
              node3.tagName = `Components.${components[i]}`;
            }
          });
        }
      }
      if (import_script && !instance[0]) {
        instance.push({
          type: "raw",
          value: `${newline}<script>${newline}	${import_script}${newline}<\/script>${newline}`
        });
      } else if (import_script) {
        instance[0].value = instance[0].value.replace(
          RE_SCRIPT,
          `$1${newline}	${import_script}`
        );
      }
      if (!_module[0] && fm) {
        _module.push({
          type: "raw",
          value: `<script context="module">${newline}	${fm}${newline}<\/script>`
        });
      } else if (fm) {
        _module[0].value = _module[0].value.replace(
          RE_MODULE_SCRIPT,
          `$1${newline}	${fm}`
        );
      }
      node2.children = [
        ..._module,
        { type: "raw", value: _module[0] ? newline : "" },
        ...instance,
        { type: "raw", value: instance[0] ? newline : "" },
        ...css,
        { type: "raw", value: css[0] ? newline : "" },
        ...special,
        { type: "raw", value: special[0] ? newline : "" },
        {
          type: "raw",
          value: import_script ? `<Layout_MDSVEX_DEFAULT {...$$props}${fm ? " {...metadata}" : ""}>` : ""
        },
        { type: "raw", value: newline },
        ...html2,
        { type: "raw", value: newline },
        { type: "raw", value: import_script ? "</Layout_MDSVEX_DEFAULT>" : "" }
      ];
    });
  };
}
var langs = {};
var Prism;
var make_path = (base_path, id2) => base_path.replace("{id}", id2);
function get_lang_info(name2, lang_meta, base_path) {
  const _lang_meta = {
    name: name2,
    path: `prismjs/${make_path(base_path, name2)}`,
    deps: /* @__PURE__ */ new Set()
  };
  const aliases = /* @__PURE__ */ new Set();
  if (lang_meta.require) {
    if (Array.isArray(lang_meta.require)) {
      lang_meta.require.forEach((id2) => _lang_meta.deps.add(id2));
    } else {
      _lang_meta.deps.add(lang_meta.require);
    }
  }
  if (lang_meta.peerDependencies) {
    if (Array.isArray(lang_meta.peerDependencies)) {
      lang_meta.peerDependencies.forEach((id2) => _lang_meta.deps.add(id2));
    } else {
      _lang_meta.deps.add(lang_meta.peerDependencies);
    }
  }
  if (lang_meta.alias) {
    if (Array.isArray(lang_meta.alias)) {
      lang_meta.alias.forEach((id2) => aliases.add(id2));
    } else {
      aliases.add(lang_meta.alias);
    }
  }
  return [{ ..._lang_meta, aliases }, aliases];
}
function load_language_metadata() {
  if (!process.browser) {
    const {
      meta: meta2,
      ...languages
    } = require_components().languages;
    for (const lang3 in languages) {
      const [lang_info, aliases] = get_lang_info(
        lang3,
        languages[lang3],
        meta2.path
      );
      langs[lang3] = lang_info;
      aliases.forEach((_n) => {
        langs[_n] = langs[lang3];
      });
    }
    const svelte_meta = {
      name: "svelte",
      aliases: /* @__PURE__ */ new Set(["sv"]),
      path: "prism-svelte",
      deps: /* @__PURE__ */ new Set(["javscript", "css"])
    };
    langs.svelte = svelte_meta;
    langs.sv = svelte_meta;
  }
}
function load_language(lang3) {
  if (!process.browser) {
    if (!langs[lang3])
      return;
    langs[lang3].deps.forEach((name2) => load_language(name2));
    __require(langs[lang3].path);
  }
}
function highlight_blocks({
  highlighter: highlight_fn,
  alias
} = {}) {
  if (highlight_fn && !process.browser) {
    load_language_metadata();
    if (alias) {
      for (const lang3 in alias) {
        langs[lang3] = langs[alias[lang3]];
      }
    }
  }
  return async function(tree) {
    if (highlight_fn) {
      const nodes = [];
      unistUtilVisit(tree, "code", (node2) => {
        nodes.push(node2);
      });
      await Promise.all(
        nodes.map(async (node2) => {
          node2.type = "html";
          node2.value = await highlight_fn(
            node2.value,
            node2.lang,
            node2.meta
          );
        })
      );
    }
  };
}
var escape_svelty = (str2) => str2.replace(
  /[{}`]/g,
  (c2) => ({ "{": "&#123;", "}": "&#125;", "`": "&#96;" })[c2]
).replace(/\\([trn])/g, "&#92;$1");
var code_highlight = (code2, lang3) => {
  const normalised_lang = _optionalChain([lang3, "optionalAccess", (_) => _.toLowerCase, "call", (_2) => _2()]);
  if (!process.browser) {
    let _lang = !!normalised_lang && langs[normalised_lang];
    if (!Prism)
      Prism = require_prism();
    if (_lang && !Prism.languages[_lang.name]) {
      load_language(_lang.name);
    }
    if (!_lang && normalised_lang && Prism.languages[normalised_lang]) {
      langs[normalised_lang] = { name: lang3 };
      _lang = langs[normalised_lang];
    }
    const highlighted = escape_svelty(
      _lang ? Prism.highlight(code2, Prism.languages[_lang.name], _lang.name) : escapeHtml_1(code2)
    );
    return `<pre class="language-${normalised_lang}">{@html \`<code class="language-${normalised_lang}">${highlighted}</code>\`}</pre>`;
  } else {
    const highlighted = escape_svelty(escapeHtml_1(code2));
    return `<pre class="language-${normalised_lang}">{@html \`<code class="language-${normalised_lang}">${highlighted}</code>\`}</pre>`;
  }
};
function stringify(options2 = {}) {
  this.Compiler = compiler2;
  function compiler2(tree) {
    return prettyhtmlHastToHtml(tree, options2);
  }
}
var apply_plugins = (plugins, parser3) => {
  plugins.forEach((plugin) => {
    if (Array.isArray(plugin)) {
      if (plugin[1] && plugin[1])
        parser3.use(plugin[0], plugin[1]);
      else
        parser3.use(plugin[0]);
    } else {
      parser3.use(plugin);
    }
  });
  return parser3;
};
function transform({
  remarkPlugins = [],
  rehypePlugins = [],
  frontmatter: frontmatter2,
  smartypants: smartypants2,
  layout,
  layout_mode,
  highlight
} = { layout_mode: "single" }) {
  const fm_opts = frontmatter2 ? frontmatter2 : { parse: default_frontmatter, type: "yaml", marker: "-" };
  const toMDAST = unified_1$1().use(remarkParse).use(mdsvex_parser).use(remarkExternalLinks, { target: false, rel: ["nofollow"] }).use(escape_code, { blocks: !!highlight }).use(remarkFrontmatter, [{ type: fm_opts.type, marker: fm_opts.marker }]).use(parse_frontmatter, { parse: fm_opts.parse, type: fm_opts.type });
  if (smartypants2) {
    toMDAST.use(
      smartypants_transformer,
      typeof smartypants2 === "boolean" ? {} : smartypants2
    );
  }
  apply_plugins(remarkPlugins, toMDAST).use(highlight_blocks, highlight || {});
  const toHAST = toMDAST.use(remarkRehype, {
    allowDangerousHtml: true,
    allowDangerousCharacters: true
  }).use(transform_hast, { layout, layout_mode });
  apply_plugins(rehypePlugins, toHAST);
  const processor = toHAST.use(stringify, {
    allowDangerousHtml: true,
    allowDangerousCharacters: true
  });
  return processor;
}
var defaults = {
  remarkPlugins: [],
  rehypePlugins: [],
  smartypants: true,
  extension: ".svx",
  highlight: { highlighter: code_highlight }
};
function to_posix(_path) {
  const isExtendedLengthPath = /^\\\\\?\\/.test(_path);
  const hasNonAscii = /[^\u0000-\u0080]+/.test(_path);
  if (isExtendedLengthPath || hasNonAscii) {
    return _path;
  }
  return _path.replace(/\\/g, "/");
}
function resolve_layout(layout_path) {
  try {
    return to_posix(__require.resolve(layout_path));
  } catch (e) {
    try {
      const _path = (0, import_path.join)(process.cwd(), layout_path);
      return to_posix(__require.resolve(_path));
    } catch (e2) {
      throw new Error(
        `The layout path you provided couldn't be found at either ${layout_path} or ${(0, import_path.join)(
          process.cwd(),
          layout_path
        )}. Please double-check it and try again.`
      );
    }
  }
}
function process_layouts(layouts) {
  const _layouts = layouts;
  for (const key in _layouts) {
    const layout = import_fs.default.readFileSync(_layouts[key].path, { encoding: "utf8" });
    let ast2;
    try {
      ast2 = parse$3(layout);
    } catch (e) {
      throw new Error(e.toString() + `
	at ${_layouts[key].path}`);
    }
    if (ast2.module) {
      const component_exports = ast2.module.content.body.filter(
        (node2) => node2.type === "ExportNamedDeclaration"
      );
      if (component_exports.length) {
        _layouts[key].components = [];
        for (let i = 0; i < component_exports.length; i++) {
          if (component_exports[i].specifiers && component_exports[i].specifiers.length) {
            for (let j = 0; j < component_exports[i].specifiers.length; j++) {
              _layouts[key].components.push(
                component_exports[i].specifiers[j].exported.name
              );
            }
          } else if (component_exports[i].declaration.declarations) {
            const declarations = component_exports[i].declaration.declarations;
            for (let j = 0; j < declarations.length; j++) {
              _layouts[key].components.push(declarations[j].id.name);
            }
          } else if (component_exports[i].declaration) {
            _layouts[key].components.push(
              component_exports[i].declaration.id.name
            );
          }
        }
      }
    }
  }
  return _layouts;
}
var mdsvex = (options2 = defaults) => {
  const {
    remarkPlugins = [],
    rehypePlugins = [],
    smartypants: smartypants2 = true,
    extension = ".svx",
    extensions,
    layout = false,
    highlight = { highlighter: code_highlight },
    frontmatter: frontmatter2
  } = options2;
  if (options2.layouts) {
    throw new Error(
      `mdsvex: "layouts" is not a valid option. Did you mean "layout"?`
    );
  }
  const unknown_opts = [];
  const known_opts = [
    "filename",
    "remarkPlugins",
    "rehypePlugins",
    "smartypants",
    "extension",
    "extensions",
    "layout",
    "highlight",
    "frontmatter"
  ];
  for (const opt in options2) {
    if (!known_opts.includes(opt))
      unknown_opts.push(opt);
  }
  if (unknown_opts.length) {
    console.warn(
      `mdsvex: Received unknown options: ${unknown_opts.join(
        ", "
      )}. Valid options are: ${known_opts.join(", ")}.`
    );
  }
  let _layout = {};
  let layout_mode = "single";
  if (typeof layout === "string") {
    _layout.__mdsvex_default = { path: resolve_layout(layout), components: [] };
  } else if (typeof layout === "object") {
    layout_mode = "named";
    for (const name2 in layout) {
      _layout[name2] = { path: resolve_layout(layout[name2]), components: [] };
    }
  }
  if (highlight && highlight.highlighter === void 0) {
    highlight.highlighter = code_highlight;
  }
  _layout = process_layouts(_layout);
  const parser3 = transform({
    remarkPlugins,
    rehypePlugins,
    smartypants: smartypants2,
    layout: _layout,
    layout_mode,
    highlight,
    frontmatter: frontmatter2
  });
  return {
    markup: async ({ content, filename }) => {
      const extensionsParts = (extensions || [extension]).map(
        (ext) => ext.split(".").pop()
      );
      if (!extensionsParts.includes(filename.split(".").pop()))
        return;
      const parsed = await parser3.process({ contents: content, filename });
      return {
        code: parsed.contents,
        data: parsed.data,
        map: ""
      };
    }
  };
};
var _compile = (source, opts) => mdsvex(opts).markup({
  content: source,
  filename: opts && opts.filename || `file${opts && (opts.extensions && opts.extensions[0] || opts.extension) || ".svx"}`
});
export {
  _compile as compile,
  defineConfig as defineMDSveXConfig,
  escape_svelty as escapeSvelte,
  mdsvex
};
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
//# sourceMappingURL=mdsvex.js.map
